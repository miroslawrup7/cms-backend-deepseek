__tests__\utils\sanitize.test.js v.2
==================================

const {
  sanitizeTitle,
  sanitizeBody,
  sanitizeComment,
  sanitizeStrict,
} = require('../../utils/sanitize');

describe('Utils: Sanityzacja danych', () => {
  describe('sanitizeTitle', () => {
    it('Powinien usuwaÄ‡ wszystkie tagi HTML', () => {
      const input = '<script>alert("xss")</script>TytuÅ‚ <b>pogrubiony</b>';
      expect(sanitizeTitle(input)).toBe('TytuÅ‚ pogrubiony');
    });

    it('Powinien trimowaÄ‡ biaÅ‚e znaki', () => {
      const input = '   TytuÅ‚ z spacjami   ';
      expect(sanitizeTitle(input)).toBe('TytuÅ‚ z spacjami');
    });
  });

  describe('sanitizeStrict', () => {
    it('Powinien usuwaÄ‡ wszystkie tagi HTML', () => {
      const input = '<script>alert("xss")</script>Tekst <b>pogrubiony</b>';
      expect(sanitizeStrict(input)).toBe('Tekst pogrubiony');
    });

    it('Powinien ograniczaÄ‡ dÅ‚ugoÅ›Ä‡ do 500 znakÃ³w', () => {
      const longInput = 'A'.repeat(600);
      expect(sanitizeStrict(longInput).length).toBe(500);
    });

    it('Powinien radziÄ‡ sobie z null/undefined', () => {
      expect(sanitizeStrict(null)).toBe('');
      expect(sanitizeStrict(undefined)).toBe('');
    });
  });

  describe('sanitizeBody', () => {
    it('Powinien pozwalaÄ‡ na podstawowe tagi formatujÄ…ce', () => {
      const input =
        '<p>Paragraf</p><b>pogrubienie</b><a href="https://example.com">link</a>';
      const result = sanitizeBody(input);

      expect(result).toContain('<p>');
      expect(result).toContain('<b>');
      expect(result).toContain('<a href="https://example.com"');
      expect(result).not.toContain('<script>');
    });

    it('Powinien dodawaÄ‡ atrybuty bezpieczeÅ„stwa do linkÃ³w', () => {
      const input = '<a href="https://example.com">link</a>';
      const result = sanitizeBody(input);

      expect(result).toContain('target="_blank"');
      expect(result).toContain('rel="noopener noreferrer nofollow ugc"');
    });
  });

  describe('sanitizeComment', () => {
    it('Powinien pozwalaÄ‡ na podstawowe formatowanie w komentarzach', () => {
      const input =
        '<b>pogrubienie</b> <i>kursywa</i> <a href="https://example.com">link</a>';
      const result = sanitizeComment(input);

      expect(result).toContain('<b>pogrubienie</b>');
      expect(result).toContain('<i>kursywa</i>');
      expect(result).toContain('<a href="https://example.com"');
      expect(result).not.toContain('<script>');
    });

    it('Powinien usuwaÄ‡ niebezpieczne tagi z komentarzy', () => {
      const input =
        'Safe <b>bold</b> but <img src="x" onerror="alert(1)"> dangerous <script>alert(2)</script>';
      const result = sanitizeComment(input);

      expect(result).toContain('<b>bold</b>'); // Bezpieczne tagi pozostajÄ…
      expect(result).not.toContain('<img'); // Niebezpieczne tagi sÄ… usuwane
      expect(result).not.toContain('<script>'); // Niebezpieczne tagi sÄ… usuwane
      expect(result).not.toContain('onerror'); // Niebezpieczne atrybuty sÄ… usuwane
      expect(result).toBe('Safe <b>bold</b> but  dangerous'); // Tekst pozostaje
    });

    it('Powinien zabezpieczaÄ‡ linki w komentarzach', () => {
      const input = '<a href="https://example.com">link</a>';
      const result = sanitizeComment(input);

      expect(result).toContain('target="_blank"');
      expect(result).toContain('rel="noopener noreferrer nofollow ugc"');
      expect(result).toContain('href="https://example.com"');
    });

    it('Powinien blokowaÄ‡ javascript: w linkach', () => {
      const input = '<a href="javascript:alert(1)">malicious link</a>';
      const result = sanitizeComment(input);

      // Link z javascript: powinien byÄ‡ CAÅKOWICIE usuniÄ™ty
      expect(result).not.toContain('href="javascript:');
      expect(result).not.toContain('malicious link');
      expect(result).toBe(''); // Powinno byÄ‡ puste
    });

    it('Powinien usuwaÄ‡ niebezpieczne atrybuty zdarzeÅ„', () => {
      const input =
        '<span onclick="alert(1)" onmouseover="alert(2)">text</span>';
      const result = sanitizeComment(input);

      // Niebezpieczne atrybuty powinny byÄ‡ usuniÄ™te
      expect(result).not.toContain('onclick');
      expect(result).not.toContain('onmouseover');
      expect(result).toBe('text'); // Tekst powinien pozostaÄ‡
    });
  });
});


==================================
backup\2025-09-05\cms\articles.bson v.1
==================================

<plik binarny, nie wyÅ›wietlono zawartoÅ›ci>

==================================
backup\2025-09-05\cms\articles.metadata.json v.1
==================================

{"indexes":[{"v":{"$numberInt":"2"},"key":{"_id":{"$numberInt":"1"}},"name":"_id_"},{"v":{"$numberInt":"2"},"key":{"author":{"$numberInt":"1"},"createdAt":{"$numberInt":"-1"}},"name":"author_1_createdAt_-1","background":true},{"v":{"$numberInt":"2"},"key":{"_fts":"text","_ftsx":{"$numberInt":"1"}},"name":"title_text_content_text","background":true,"weights":{"content":{"$numberInt":"1"},"title":{"$numberInt":"1"}},"default_language":"english","language_override":"language","textIndexVersion":{"$numberInt":"3"}},{"v":{"$numberInt":"2"},"key":{"createdAt":{"$numberInt":"-1"}},"name":"createdAt_-1","background":true}],"uuid":"da9501f4b0e048c787069ecb917ed339","collectionName":"articles","type":"collection"}

==================================
backup\2025-09-05\cms\comments.bson v.1
==================================

<plik binarny, nie wyÅ›wietlono zawartoÅ›ci>

==================================
backup\2025-09-05\cms\comments.metadata.json v.1
==================================

{"indexes":[{"v":{"$numberInt":"2"},"key":{"_id":{"$numberInt":"1"}},"name":"_id_"},{"v":{"$numberInt":"2"},"key":{"article":{"$numberInt":"1"}},"name":"article_1","background":true},{"v":{"$numberInt":"2"},"key":{"article":{"$numberInt":"1"},"createdAt":{"$numberInt":"-1"}},"name":"article_1_createdAt_-1","background":true},{"v":{"$numberInt":"2"},"key":{"author":{"$numberInt":"1"}},"name":"author_1","background":true}],"uuid":"66d0c0aa257c4c7f96be19954aded15b","collectionName":"comments","type":"collection"}

==================================
backup\2025-09-05\cms\pendingusers.bson v.1
==================================

<plik binarny, nie wyÅ›wietlono zawartoÅ›ci>

==================================
backup\2025-09-05\cms\pendingusers.metadata.json v.1
==================================

{"indexes":[{"v":{"$numberInt":"2"},"key":{"_id":{"$numberInt":"1"}},"name":"_id_"},{"v":{"$numberInt":"2"},"key":{"email":{"$numberInt":"1"}},"name":"email_1","background":true,"unique":true},{"v":{"$numberInt":"2"},"key":{"createdAt":{"$numberInt":"1"}},"name":"createdAt_1","background":true,"expireAfterSeconds":{"$numberInt":"86400"}}],"uuid":"7825ca18c1674e4da2d08d0057e538ef","collectionName":"pendingusers","type":"collection"}

==================================
backup\2025-09-05\cms\prelude.json v.1
==================================

{"ServerVersion":"8.0.13","ToolVersion":"100.13.0"}

==================================
backup\2025-09-05\cms\users.bson v.1
==================================

<plik binarny, nie wyÅ›wietlono zawartoÅ›ci>

==================================
backup\2025-09-05\cms\users.metadata.json v.1
==================================

{"indexes":[{"v":{"$numberInt":"2"},"key":{"_id":{"$numberInt":"1"}},"name":"_id_"},{"v":{"$numberInt":"2"},"key":{"username":{"$numberInt":"1"}},"name":"username_1","background":true,"unique":true},{"v":{"$numberInt":"2"},"key":{"email":{"$numberInt":"1"}},"name":"email_1","background":true,"unique":true},{"v":{"$numberInt":"2"},"key":{"createdAt":{"$numberInt":"-1"}},"name":"createdAt_-1","background":true}],"uuid":"45a48700a8f14fe7ab271a3029364943","collectionName":"users","type":"collection"}

==================================
backup\cms\articles.bson v.1
==================================

<plik binarny, nie wyÅ›wietlono zawartoÅ›ci>

==================================
backup\cms\articles.metadata.json v.1
==================================

{"indexes":[{"v":{"$numberInt":"2"},"key":{"_id":{"$numberInt":"1"}},"name":"_id_"},{"v":{"$numberInt":"2"},"key":{"author":{"$numberInt":"1"},"createdAt":{"$numberInt":"-1"}},"name":"author_1_createdAt_-1","background":true},{"v":{"$numberInt":"2"},"key":{"_fts":"text","_ftsx":{"$numberInt":"1"}},"name":"title_text_content_text","background":true,"weights":{"content":{"$numberInt":"1"},"title":{"$numberInt":"1"}},"default_language":"english","language_override":"language","textIndexVersion":{"$numberInt":"3"}}],"uuid":"7517bc407b74419db0e8624f43a01a0b","collectionName":"articles","type":"collection"}

==================================
backup\cms\comments.bson v.1
==================================

<plik binarny, nie wyÅ›wietlono zawartoÅ›ci>

==================================
backup\cms\comments.metadata.json v.1
==================================

{"indexes":[{"v":{"$numberInt":"2"},"key":{"_id":{"$numberInt":"1"}},"name":"_id_"},{"v":{"$numberInt":"2"},"key":{"article":{"$numberInt":"1"}},"name":"article_1","background":true}],"uuid":"49a1ac7e42a344b6a5c7fb470f3b9416","collectionName":"comments","type":"collection"}

==================================
backup\cms\pendingusers.bson v.1
==================================

<plik binarny, nie wyÅ›wietlono zawartoÅ›ci>

==================================
backup\cms\pendingusers.metadata.json v.1
==================================

{"indexes":[{"v":{"$numberInt":"2"},"key":{"_id":{"$numberInt":"1"}},"name":"_id_"},{"v":{"$numberInt":"2"},"key":{"email":{"$numberInt":"1"}},"name":"email_1","background":true,"unique":true},{"v":{"$numberInt":"2"},"key":{"createdAt":{"$numberInt":"1"}},"name":"createdAt_1","background":true,"expireAfterSeconds":{"$numberInt":"86400"}}],"uuid":"3bca25e0c9ea484484956c2a6730026d","collectionName":"pendingusers","type":"collection"}

==================================
backup\cms\users.bson v.1
==================================

<plik binarny, nie wyÅ›wietlono zawartoÅ›ci>

==================================
backup\cms\users.metadata.json v.1
==================================

{"indexes":[{"v":{"$numberInt":"2"},"key":{"_id":{"$numberInt":"1"}},"name":"_id_"},{"v":{"$numberInt":"2"},"key":{"username":{"$numberInt":"1"}},"name":"username_1","background":true,"unique":true},{"v":{"$numberInt":"2"},"key":{"email":{"$numberInt":"1"}},"name":"email_1","background":true,"unique":true}],"uuid":"fff3b0f67d424a188cedaf8d37c22388","collectionName":"users","type":"collection"}

==================================
controllers\adminController.js v.1
==================================

const logger = require('../utils/logger');
const bcrypt = require('bcryptjs');
const PendingUser = require('../models/PendingUser');
const User = require('../models/User');
const { sanitizeTitle } = require('../utils/sanitize');
const { sendMail } = require('../utils/mailer');
const {
  approvedUserEmail,
  rejectedUserEmail,
} = require('../utils/emailTemplates');
const AppError = require('../utils/AppError');

// GET /api/admin/pending-users
const getPendingUsers = async (req, res, next) => {
  try {
    const { search = '', page = 1, limit = 10 } = req.query;

    const query = {
      $or: [
        { username: { $regex: search, $options: 'i' } },
        { email: { $regex: search, $options: 'i' } },
      ],
    };

    const skip = (parseInt(page) - 1) * parseInt(limit);

    const [total, users] = await Promise.all([
      PendingUser.countDocuments(query),
      PendingUser.find(query)
        .sort({ createdAt: -1 })
        .skip(skip)
        .limit(parseInt(limit))
        .lean(),
    ]);

    res.json({
      total,
      page: parseInt(page),
      limit: parseInt(limit),
      users,
    });
  } catch (error) {
    next(error);
  }
};

// POST /api/admin/approve/:id
const approveUser = async (req, res, next) => {
  try {
    const { id } = req.params;
    const pending = await PendingUser.findById(id);
    if (!pending) return next(new AppError('Wniosek nie istnieje.', 404));

    const exists = await User.findOne({ email: pending.email });
    if (exists) {
      await pending.deleteOne();
      return next(new AppError('Email jest juÅ¼ zajÄ™ty w systemie.', 400));
    }

    const hashed = await bcrypt.hash(String(pending.password), 10);
    const user = new User({
      username: sanitizeTitle(pending.username),
      email: pending.email,
      password: hashed,
      role: pending.role,
    });
    const savedUser = await user.save();

    await pending.deleteOne();

    // wysyÅ‚ka maila (best-effort)
    try {
      const tpl = approvedUserEmail({
        username: user.username,
        email: user.email,
      });
      await sendMail({
        to: user.email,
        subject: tpl.subject,
        text: tpl.text,
        html: tpl.html,
      });
    } catch (mailError) {
      logger.warn(
        'approveUser: mail send failed:',
        mailError?.message || mailError,
      );
    }

    return res.json({
      message: 'UÅ¼ytkownik zatwierdzony i dodany do systemu.',
      userId: savedUser._id, // â† UÅ»YJ ZAPISANEGO DOKUMENTU
    });
  } catch (error) {
    next(error);
  }
};

// DELETE /api/admin/reject/:id
const rejectUser = async (req, res, next) => {
  try {
    const { id } = req.params;
    const pending = await PendingUser.findById(id);
    if (!pending) return next(new AppError('Wniosek nie istnieje.', 404));

    // wysyÅ‚ka maila (best-effort)
    try {
      const tpl = rejectedUserEmail({
        username: pending.username,
        email: pending.email,
      });
      await sendMail({
        to: pending.email,
        subject: tpl.subject,
        text: tpl.text,
        html: tpl.html,
      });
    } catch (mailError) {
      logger.warn(
        'rejectUser: mail send failed:',
        mailError?.message || mailError,
      );
    }

    await pending.deleteOne();
    return res.json({ message: 'Wniosek zostaÅ‚ odrzucony.' });
  } catch (error) {
    next(error);
  }
};

module.exports = {
  getPendingUsers,
  approveUser,
  rejectUser,
};


==================================
controllers\articleController.js v.1
==================================

const logger = require('../utils/logger');
const articleService = require('../services/articleService');
const fs = require('fs');
const path = require('path');

const UPLOADS_DIR = path.join(__dirname, '..', 'uploads');

// Helper function (only what's necessary for the controller)
function toUploadsRel(p) {
  if (!p) return '';
  const s = String(p);
  const m = s.match(/uploads[/\\]+(.+)$/i);
  return m ? m[1] : path.basename(s);
}

// POST /api/articles
const createArticle = async (req, res) => {
  try {
    const { title, content } = req.body;

    // Map uploaded files to image paths
    const imagePaths = (req.files || []).map((f) => `uploads/${f.filename}`.replace(/\\/g, '/'));

    // Authorization check
    const author = req.user ? req.user._id : null;
    if (!author) {
      // Clean up uploads if no authorization
      imagePaths.forEach((rel) => {
        const full = path.join(UPLOADS_DIR, toUploadsRel(rel));
        fs.unlink(full, () => {});
      });
      return res.status(401).json({ message: 'Nieautoryzowany dostÄ™p' });
    }

    // Call service
    const newArticle = await articleService.createArticle(title, content, author, imagePaths);

    return res.status(201).json({ message: 'ArtykuÅ‚ utworzony', article: newArticle });
  } catch (error) {
    // Clean up uploads on error
    if (req.files && req.files.length > 0) {
      for (const f of req.files) {
        const full = path.join(UPLOADS_DIR, toUploadsRel(f.filename || f.path));
        fs.unlink(full, () => {});
      }
    }
    logger.error('BÅ‚Ä…d tworzenia artykuÅ‚u:', error);
    if (error.message.includes('TytuÅ‚ musi mieÄ‡') || error.message.includes('TreÅ›Ä‡ musi mieÄ‡') || error.message.includes('jest wymagana')) {
      return res.status(400).json({ message: error.message });
    }
    return res.status(500).json({ message: 'BÅ‚Ä…d serwera' });
  }
};

// GET /api/articles
const getArticles = async (req, res) => {
  try {
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 5;
    const search = (req.query.q || '').trim();
    const sort = req.query.sort || 'newest';

    const result = await articleService.getArticles(page, limit, search, sort);
    return res.json(result);
  } catch (error) {
    logger.error('BÅ‚Ä…d pobierania artykuÅ‚Ã³w:', error);
    return res.status(500).json({ message: 'BÅ‚Ä…d serwera' });
  }
};

// GET /api/articles/:id
const getArticleById = async (req, res) => {
  try {
    const { id } = req.params;
    const article = await articleService.getArticleById(id);
    return res.status(200).json(article);
  } catch (error) {
    logger.error('BÅ‚Ä…d pobierania artykuÅ‚u:', error);
    if (error.message === 'Nie znaleziono artykuÅ‚u') {
      return res.status(404).json({ message: error.message });
    }
    return res.status(500).json({ message: 'BÅ‚Ä…d serwera' });
  }
};

// PUT /api/articles/:id
const updateArticle = async (req, res) => {
  try {
    const { id } = req.params;
    const { title, content, removeImages } = req.body;

    const updateData = { title, content, removeImages };
    const result = await articleService.updateArticle(
      id,
      updateData,
      req.user._id,
      req.user.role,
      req.files,
    );

    return res.json({ message: 'ArtykuÅ‚ zaktualizowany', article: result });
  } catch (error) {
    logger.error('BÅ‚Ä…d aktualizacji artykuÅ‚u:', error);
    if (error.message === 'ArtykuÅ‚ nie znaleziony') {
      return res.status(404).json({ message: error.message });
    }
    if (error.message === 'Brak uprawnieÅ„ do edycji') {
      return res.status(403).json({ message: error.message });
    }
    if (error.message.includes('TytuÅ‚ musi mieÄ‡') || error.message.includes('TreÅ›Ä‡ musi mieÄ‡')) {
      return res.status(400).json({ message: error.message });
    }
    return res.status(500).json({ message: 'BÅ‚Ä…d serwera' });
  }
};

// DELETE /api/articles/:id
const deleteArticle = async (req, res) => {
  try {
    const { id } = req.params;
    await articleService.deleteArticle(id, req.user._id, req.user.role);
    return res.status(204).end();
  } catch (error) {
    logger.error('BÅ‚Ä…d usuwania artykuÅ‚u:', error);
    if (error.message === 'ArtykuÅ‚ nie istnieje') {
      return res.status(404).json({ message: error.message });
    }
    if (error.message === 'Brak uprawnieÅ„') {
      return res.status(403).json({ message: error.message });
    }
    return res.status(500).json({ message: 'BÅ‚Ä…d serwera' });
  }
};

// POST /api/articles/:id/like
const toggleLikeArticle = async (req, res) => {
  try {
    const { id } = req.params;
    const result = await articleService.toggleLikeArticle(id, req.user._id);
    return res.json(result);
  } catch (error) {
    logger.error('BÅ‚Ä…d toggle lajka artykuÅ‚u:', error);
    if (error.message === 'ArtykuÅ‚ nie znaleziony') {
      return res.status(404).json({ message: error.message });
    }
    if (error.message === 'Autor nie moÅ¼e polubiÄ‡ wÅ‚asnego artykuÅ‚u') {
      return res.status(400).json({
        message: error.message,
        liked: false,
        totalLikes: 0,
      });
    }
    return res.status(500).json({ message: 'BÅ‚Ä…d serwera' });
  }
};

module.exports = {
  createArticle,
  getArticles,
  getArticleById,
  updateArticle,
  deleteArticle,
  toggleLikeArticle,
};

==================================
controllers\authController.js v.1
==================================

const authService = require('../services/authService');

// ZMIANA 1: Uproszczono baseCookieOptions dla lokalnego Å›rodowiska
const baseCookieOptions = {
  httpOnly: true,
  sameSite: 'lax',
  secure: false,
  path: '/',
};

// Rejestracja â€” uÅ¼ytkownik oczekujÄ…cy na zatwierdzenie
const registerPending = async (req, res) => {
  try {
    const { username, email, password, role } = req.body;
    await authService.registerPending(username, email, password, role);
    res.status(201).json({ message: 'Wniosek o rejestracjÄ™ zostaÅ‚ przesÅ‚any.' });
  } catch (error) {
    if (error.message.includes('Email jest juÅ¼ zajÄ™ty') || error.message.includes('jest wymagana')) {
      return res.status(400).json({ message: error.message });
    }
    res.status(500).json({ message: 'BÅ‚Ä…d serwera.', error });
  }
};

// Logowanie
const login = async (req, res) => {
  try {
    const { email, password } = req.body;
    const token = await authService.login(email, password);

    res.cookie('token', token, {
      ...baseCookieOptions,
      maxAge: 24 * 60 * 60 * 1000, // 1 dzieÅ„
    });

    res.json({ message: 'Zalogowano pomyÅ›lnie.' });
  } catch (error) {
    if (error.message.includes('NieprawidÅ‚owy email lub hasÅ‚o') || error.message.includes('jest wymagane')) {
      return res.status(400).json({ message: error.message });
    }
    res.status(500).json({ message: 'BÅ‚Ä…d serwera.', error });
  }
};

// Wylogowanie
const logout = (_req, res) => {
  res.clearCookie('token', {
    ...baseCookieOptions,
  });
  res.json({ message: 'Wylogowano.' });
};

module.exports = {
  registerPending,
  login,
  logout,
};

==================================
controllers\commentController.js v.2
==================================

const logger = require('../utils/logger');
const commentService = require('../services/commentService');

// POST /api/comments/:id
const addComment = async (req, res) => {
  try {
    const articleId = req.params.id;
    const rawText = req.body?.text ?? '';
    const comment = await commentService.addComment(
      articleId,
      req.user._id,
      rawText,
    );
    return res.status(201).json(comment);
  } catch (error) {
    logger.error('BÅ‚Ä…d podczas dodawania komentarza:', error);
    if (
      error.message.includes('Komentarz nie moÅ¼e byÄ‡ pusty') ||
      error.message.includes('co najmniej 6 znakÃ³w') ||
      error.message.includes('odfiltrowaniu')
    ) {
      return res.status(400).json({ message: error.message });
    }
    if (error.message.includes('Nie znaleziono artykuÅ‚u')) {
      return res.status(404).json({ message: error.message });
    }
    return res.status(500).json({ message: 'BÅ‚Ä…d serwera' });
  }
};

// GET /api/comments/:id
const getComments = async (req, res) => {
  try {
    const articleId = req.params.id;
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 20;

    const result = await commentService.getComments(articleId, page, limit);
    return res.json(result);
  } catch (error) {
    logger.error('BÅ‚Ä…d podczas pobierania komentarzy:', error);
    return res.status(500).json({ message: 'BÅ‚Ä…d serwera' });
  }
};

// PUT /api/comments/:id
const updateComment = async (req, res) => {
  try {
    const commentId = req.params.id;
    const rawText = req.body?.text ?? '';
    const comment = await commentService.updateComment(
      commentId,
      req.user._id,
      req.user.role,
      rawText,
    );
    return res.json(comment);
  } catch (error) {
    logger.error('BÅ‚Ä…d podczas edycji komentarza:', error);
    if (
      error.message.includes('Komentarz nie moÅ¼e byÄ‡ pusty') ||
      error.message.includes('co najmniej 6 znakÃ³w') ||
      error.message.includes('odfiltrowaniu')
    ) {
      return res.status(400).json({ message: error.message });
    }
    if (error.message.includes('Komentarz nie istnieje')) {
      return res.status(404).json({ message: error.message });
    }
    if (error.message.includes('Brak uprawnieÅ„')) {
      return res.status(403).json({ message: error.message });
    }
    return res.status(500).json({ message: 'BÅ‚Ä…d serwera' });
  }
};

// DELETE /api/comments/:id
const deleteComment = async (req, res) => {
  try {
    const commentId = req.params.id;
    await commentService.deleteComment(commentId, req.user._id, req.user.role);
    return res.status(204).end();
  } catch (error) {
    logger.error('BÅ‚Ä…d podczas usuwania komentarza:', error);
    if (error.message.includes('Komentarz nie istnieje')) {
      return res.status(404).json({ message: error.message });
    }
    if (error.message.includes('Brak uprawnieÅ„')) {
      return res.status(403).json({ message: error.message });
    }
    return res.status(500).json({ message: 'BÅ‚Ä…d serwera' });
  }
};

module.exports = {
  addComment,
  getComments,
  updateComment,
  deleteComment,
};


==================================
controllers\userController.js v.2
==================================

const logger = require('../utils/logger');
const userService = require('../services/userService');

// GET /api/users/profile
const getProfile = async (req, res) => {
  try {
    if (!req.user) return res.status(401).json({ message: 'Brak autoryzacji' });
    const user = await userService.getProfile(req.user._id);
    return res.json(user);
  } catch (error) {
    logger.error('BÅ‚Ä…d getProfile:', error);
    return res.status(500).json({ message: 'BÅ‚Ä…d serwera' });
  }
};

// PUT /api/users/profile
const updateProfile = async (req, res) => {
  try {
    if (!req.user) return res.status(401).json({ message: 'Brak autoryzacji' });
    const user = await userService.updateProfile(req.user._id, req.body);
    return res.json({ message: 'Profil zaktualizowany', user });
  } catch (error) {
    logger.error('BÅ‚Ä…d updateProfile:', error);
    if (error.message.includes('Nazwa uÅ¼ytkownika')) {
      return res.status(400).json({ message: error.message });
    }
    return res.status(500).json({ message: 'BÅ‚Ä…d serwera' });
  }
};

// PUT /api/users/password
const changePassword = async (req, res) => {
  try {
    if (!req.user) return res.status(401).json({ message: 'Brak autoryzacji' });
    const { oldPassword, newPassword } = req.body;
    await userService.changePassword(req.user._id, oldPassword, newPassword);
    return res.json({ message: 'HasÅ‚o zostaÅ‚o zmienione.' });
  } catch (error) {
    logger.error('BÅ‚Ä…d changePassword:', error);
    if (
      error.message.includes('Stare hasÅ‚o') ||
      error.message.includes('Nowe hasÅ‚o')
    ) {
      return res.status(400).json({ message: error.message });
    }
    return res.status(500).json({ message: 'BÅ‚Ä…d serwera' });
  }
};

// GET /api/users (admin) - âœ… ZMODYFIKOWANE Z PAGINACJÄ„
const listUsers = async (req, res) => {
  try {
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 10;
    const search = req.query.search || '';

    const result = await userService.listUsers(page, limit, search);
    return res.json(result);
  } catch (error) {
    logger.error('BÅ‚Ä…d listUsers:', error);
    return res.status(500).json({ message: 'BÅ‚Ä…d serwera' });
  }
};

// PUT /api/users/:id/role (admin)
const changeRole = async (req, res) => {
  try {
    const { id } = req.params;
    const { role } = req.body;
    const user = await userService.changeRole(id, role);
    return res.json({ message: 'Rola zaktualizowana.', user });
  } catch (error) {
    logger.error('BÅ‚Ä…d changeRole:', error);
    if (
      error.message.includes('Rola') ||
      error.message.includes('NieprawidÅ‚owa')
    ) {
      return res.status(400).json({ message: error.message });
    }
    return res.status(500).json({ message: 'BÅ‚Ä…d serwera' });
  }
};

// DELETE /api/users/:id (admin)
const deleteUser = async (req, res) => {
  try {
    const { id } = req.params;
    await userService.deleteUser(id);
    return res.status(204).end();
  } catch (error) {
    logger.error('BÅ‚Ä…d deleteUser:', error);
    if (error.message.includes('UÅ¼ytkownik nie istnieje')) {
      return res.status(404).json({ message: error.message });
    }
    return res.status(500).json({ message: 'BÅ‚Ä…d serwera' });
  }
};

module.exports = {
  getProfile,
  updateProfile,
  changePassword,
  listUsers,
  changeRole,
  deleteUser,
};


==================================
docker-compose.yml v.1
==================================


services:
  redis:
    image: redis:alpine
    ports:
      - "6379:6379"
    restart: unless-stopped
    volumes:
      - redis_data:/data

volumes:
  redis_data:

==================================
eslint.config.js v.2
==================================

const js = require('@eslint/js');
const globals = require('globals');

module.exports = [
  {
    files: ['**/*.js'],
    ignores: [
      'node_modules/**',
      'uploads/**',
      'logs/**',
      'backup/**',
      '__tests__/coverage/**',
      'dist/**',
    ],
    languageOptions: {
      ecmaVersion: 'latest',
      sourceType: 'commonjs',
      globals: {
        ...globals.node,
        console: 'readonly',
        process: 'readonly',
        __dirname: 'readonly',
        __filename: 'readonly',
      },
    },
    rules: {
      ...js.configs.recommended.rules,
      'no-unused-vars': [
        'error',
        {
          argsIgnorePattern: '^_',
          varsIgnorePattern: '^_',
          caughtErrorsIgnorePattern: '^_',
          destructuredArrayIgnorePattern: '^_',
        },
      ],
      'no-console': 'warn',
      'prefer-const': 'error',
      'no-var': 'error',
      quotes: ['error', 'single', { avoidEscape: true }],
      semi: ['error', 'always'],
      'indent': ['error', 2],
      'comma-dangle': ['error', 'always-multiline'],
      'object-curly-spacing': ['error', 'always'],
      'array-bracket-spacing': ['error', 'never'],
    },
  },
  {
    files: ['__tests__/**/*.js'],
    languageOptions: {
      globals: {
        ...globals.jest, // âœ… DODAJEMY GLOBALNE ZMIENNE JEST
        ...globals.node,
      },
    },
    rules: {
      'no-console': 'off',
      'no-unused-vars': [
        'error',
        {
          argsIgnorePattern: '^_',
          varsIgnorePattern: '^_',
          caughtErrorsIgnorePattern: '^_',
          destructuredArrayIgnorePattern: '^_',
        },
      ],
    },
  },
];


==================================
jest-mongodb-config.js v.1
==================================

// jest-mongodb-config.js (w root projektu)
module.exports = {
  mongodbMemoryServerOptions: {
    instance: {
      dbName: 'cms-test', // nazwa testowej bazy
    },
    binary: {
      version: '6.0.0', // wersja MongoDB
      skipMD5: true,
    },
    autoStart: false,
  },
};


==================================
jest.config.js v.3
==================================

// jest.config.js (poprawiona wersja)
module.exports = {
  testEnvironment: 'node',
  setupFiles: ['<rootDir>/jest.setup.js'],
  collectCoverageFrom: [
    'services/**/*.js',
    'controllers/**/*.js',
    'utils/**/*.js',
    '!**/node_modules/**',
  ],
  coverageThreshold: {
    global: {
      branches: 0,
      functions: 0,
      lines: 0,
      statements: 0,
    },
  },
  testPathIgnorePatterns: [
    '/node_modules/',
    // USUÅƒ lub ZMIEÅƒ tÄ™ liniÄ™:
    // '__tests__/integration/.+',
  ],
  // MoÅ¼esz dodaÄ‡ jawnÄ… definicjÄ™ patternÃ³w testowych:
  testMatch: ['**/__tests__/**/*.test.js', '**/__tests__/**/*.spec.js'],
};


==================================
jest.setup.js v.1
==================================

// jest.setup.js
const path = require('path');
// Åadujemy zmienne Å›rodowiskowe Z PLIKU .env.test
require('dotenv').config({ path: path.resolve(__dirname, '.env.test') });


==================================
middleware\authMiddleware.js v.1
==================================

const jwt = require('jsonwebtoken');
const User = require('../models/User');
const AppError = require('../utils/AppError');

// Middleware sprawdzajÄ…cy czy uÅ¼ytkownik jest zalogowany i waÅ¼ny token
const requireAuth = async (req, res, next) => {
  const token = req.cookies.token;

  if (!token) {
    return next(new AppError('Brak tokena. DostÄ™p zabroniony.', 401));
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    const user = await User.findById(decoded.id).select('-password');

    if (!user) {
      return next(new AppError('UÅ¼ytkownik nie istnieje', 401));
    }

    req.user = user;
    next();
  } catch (_error) {
    next(new AppError('NieprawidÅ‚owy token.', 401));
  }
};

module.exports = requireAuth;

==================================
middleware\cacheMiddleware.js v.1
==================================

// middleware/cacheMiddleware.js
const redisClient = require('../utils/redisClient');

const cacheMiddleware = (duration = 3600) => {
  return async (req, res, next) => {
    // Cache tylko dla GET requests
    if (req.method !== 'GET') {
      return next();
    }

    // Klucz cache na podstawie URL i query params
    const key = `cache:${req.originalUrl}`;

    try {
      // SprawdÅº czy mamy dane w cache
      const cachedData = await redisClient.get(key);
      
      if (cachedData) {
        console.log('Cache HIT:', key);
        return res.json(JSON.parse(cachedData));
      }

      console.log('Cache MISS:', key);

      // Zapisz oryginalnÄ… metodÄ™ res.json
      const originalJson = res.json.bind(res);

      // Nadpisz res.json aby cache'owaÄ‡ odpowiedÅº
      res.json = (body) => {
        // Cache'uj tylko successful responses
        if (res.statusCode >= 200 && res.statusCode < 300) {
          redisClient.set(key, JSON.stringify(body), duration)
            .catch(err => console.error('Cache set error:', err));
        }
        return originalJson(body);
      };

      next();
    } catch (error) {
      console.error('Cache middleware error:', error);
      next();
    }
  };
};

// Specjalny middleware do invalidacji cache
const invalidateCache = (pattern) => {
  return async (req, res, next) => {
    // Po successful POST/PUT/DELETE, invaliduj cache
    const afterResponse = async () => {
      try {
        if (res.statusCode >= 200 && res.statusCode < 300) {
          // Dla uproszczenia - w production uÅ¼yj redis.scan
          // Teraz po prostu logujemy Å¼e trzeba by invalidowaÄ‡
          console.log('Should invalidate cache for pattern:', pattern);
        }
      } catch (error) {
        console.error('Cache invalidation error:', error);
      }
    };

    res.on('finish', afterResponse);
    next();
  };
};

module.exports = { cacheMiddleware, invalidateCache };

==================================
middleware\cspMiddleware.js v.1
==================================

// middleware/cspMiddleware.js
const helmet = require('helmet');

const cspConfig = {
  directives: {
    defaultSrc: ["'self'"],
    scriptSrc: [
      "'self'",
      "'unsafe-inline'", // Tymczasowo dla kompatybilnoÅ›ci
      'https:',
    ],
    styleSrc: [
      "'self'",
      "'unsafe-inline'", // Tymczasowo dla kompatybilnoÅ›ci
      'https:',
    ],
    imgSrc: [
      "'self'",
      'data:',
      'blob:',
      'https:',
    ],
    fontSrc: ["'self'", 'https:', 'data:'],
    objectSrc: ["'none'"],
    mediaSrc: ["'self'"],
    frameSrc: ["'none'"],
    connectSrc: ["'self'"],
    formAction: ["'self'"],
    baseUri: ["'self'"],
    frameAncestors: ["'none'"],
  },
  reportOnly: process.env.NODE_ENV === 'development',
};

const cspMiddleware = helmet.contentSecurityPolicy(cspConfig);

module.exports = cspMiddleware;

==================================
middleware\isAuthor.js v.1
==================================

const Article = require('../models/Article');
const AppError = require('../utils/AppError');

const isAuthor = async (req, res, next) => {
  try {
    const article = await Article.findById(req.params.id);

    if (!article) {
      return next(new AppError('ArtykuÅ‚ nie znaleziony', 404));
    }

    if (article.author.toString() !== req.user._id.toString()) {
      return next(new AppError('Brak uprawnieÅ„ do edycji lub usuniÄ™cia tego artykuÅ‚u', 403));
    }

    next();
  } catch (error) {
    next(error);
  }
};

module.exports = isAuthor;

==================================
middleware\isCommentAuthor.js v.1
==================================

const Comment = require('../models/Comment');
const AppError = require('../utils/AppError');

const isCommentAuthor = async (req, res, next) => {
  try {
    const comment = await Comment.findById(req.params.id);
    if (!comment) return next(new AppError('Komentarz nie znaleziony', 404));

    if (comment.author.toString() !== req.user._id.toString()) {
      return next(new AppError('Brak uprawnieÅ„ do wykonania tej operacji', 403));
    }

    next();
  } catch (error) {
    next(error);
  }
};

module.exports = isCommentAuthor;

==================================
middleware\performanceMiddleware.js v.1
==================================

// middleware/performanceMiddleware.js
const performanceMiddleware = (req, res, next) => {
  const start = Date.now();
  
  res.on('finish', () => {
    const duration = Date.now() - start;
    console.log(`â±ï¸ ${req.method} ${req.url} - ${duration}ms`);
    
    if (duration > 100) {
      console.warn(`ðŸš¨ WOLNE ZAPYTANIE: ${req.url} - ${duration}ms`);
    }
  });
  
  next();
};

module.exports = performanceMiddleware;

==================================
middleware\rateLimit.js v.1
==================================

const rateLimit = require('express-rate-limit');

// Podstawowy rate limiting dla wszystkich endpointÃ³w
const globalLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minut
  max: 1000, // maksymalnie 1000 Å¼Ä…daÅ„ na IP w przedziale czasowym
  message: {
    status: 'error',
    message: 'Zbyt wiele Å¼Ä…daÅ„ z tego adresu IP. SprÃ³buj ponownie za 15 minut.',
  },
  standardHeaders: true, // Zwraca nagÅ‚Ã³wki RateLimit-*
  legacyHeaders: false, // WyÅ‚Ä…cza nagÅ‚Ã³wki X-RateLimit-*
});

// Zaostrzony limiting dla endpointÃ³w autentykacji
const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minut
  max: 50, // tylko 50 prÃ³b logowania/rejestracji na IP
  message: {
    status: 'error',
    message: 'Zbyt wiele prÃ³b autentykacji. SprÃ³buj ponownie za 15 minut.',
  },
  skip: (req) =>
    // Pomijaj limity dla udanych logowaÅ„ (chroni przed blokowaniem prawdziwych uÅ¼ytkownikÃ³w)
    req.path.includes('/login') && req.method === 'POST' && req.user,
});

// Bardzo restrykcyjny limiting dla admin endpoints
const adminLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minut
  max: 200, // 200 Å¼Ä…daÅ„ na IP dla endpointÃ³w admina
  message: {
    status: 'error',
    message: 'Zbyt wiele Å¼Ä…daÅ„ do panelu administracyjnego.',
  },
});

module.exports = {
  globalLimiter,
  authLimiter,
  adminLimiter,
};


==================================
middleware\requireAdmin.js v.1
==================================

const AppError = require('../utils/AppError');

module.exports = (req, res, next) => {
  if (!req.user) {
    return next(new AppError('Brak autoryzacji', 401));
  }
  if (req.user.role !== 'admin') {
    return next(new AppError('Brak dostÄ™pu â€” wymagane uprawnienia administratora', 403));
  }
  next();
};

==================================
middleware\requireAuthorOrAdmin.js v.1
==================================

const Article = require('../models/Article');
const AppError = require('../utils/AppError');

module.exports = async function requireAuthorOrAdmin(req, res, next) {
  try {
    const { id } = req.params;
    const article = await Article.findById(id);
    if (!article) return next(new AppError('ArtykuÅ‚ nie istnieje.', 404));

    const isOwner = String(article.author) === String(req.user._id);
    const isAdmin = req.user.role === 'admin';
    if (!isOwner && !isAdmin) {
      return next(new AppError('Brak uprawnieÅ„.', 403));
    }

    req.article = article;
    next();
  } catch (error) {
    next(error);
  }
};

==================================
middleware\sanitizeMiddleware.js v.2
==================================

const { sanitizeStrict } = require('../utils/sanitize');

const deepSanitize = (req, res, next) => {
  // Tylko dla bardzo podstawowej ochrony - NIE escapuj, tylko usuÅ„ najbardziej niebezpieczne
  const quickSanitize = (text) => {
    if (typeof text !== 'string') return text;

    // UsuÅ„ tylko najbardziej niebezpieczne rzeczy, ale nie escapuj caÅ‚ego HTML
    return text
      .replace(/javascript:/gi, '') // UsuÅ„ javascript:
      .replace(/on\w+=/gi, '') // UsuÅ„ atrybuty zdarzeÅ„
      .substring(0, 1000); // Limit dÅ‚ugoÅ›ci
  };

  // Sanityzacja parametrÃ³w URL
  if (req.params) {
    Object.keys(req.params).forEach((key) => {
      if (typeof req.params[key] === 'string') {
        req.params[key] = quickSanitize(req.params[key]);
      }
    });
  }

  // Sanityzacja query string
  if (req.query) {
    Object.keys(req.query).forEach((key) => {
      if (typeof req.query[key] === 'string') {
        req.query[key] = quickSanitize(req.query[key]);
      }
    });
  }

  // Sanityzacja body (dla JSON) - TUTAJ BARDZIEJ OSTROÅ»NIE
  if (req.body && typeof req.body === 'object') {
    const sanitizeObject = (obj) => {
      Object.keys(obj).forEach((key) => {
        if (typeof obj[key] === 'string') {
          // Dla username, email - uÅ¼yj strict sanitization
          if (['username', 'email', 'password'].includes(key)) {
            obj[key] = sanitizeStrict(obj[key]);
          } else {
            // Dla innych pÃ³l - tylko podstawowe czyszczenie
            obj[key] = quickSanitize(obj[key]);
          }
        } else if (typeof obj[key] === 'object' && obj[key] !== null) {
          sanitizeObject(obj[key]);
        }
      });
    };
    sanitizeObject(req.body);
  }

  next();
};

module.exports = deepSanitize;


==================================
middleware\upload.js v.1
==================================

const multer = require('multer');
const path = require('path');

const storage = multer.diskStorage({
  destination: (_req, _file, cb) => {
    cb(null, path.join(__dirname, '..', 'uploads'));
  },
  filename: (_req, file, cb) => {
    const unique = Date.now() + '-' + Math.round(Math.random() * 1e9);
    const ext = path.extname(file.originalname || '');
    cb(null, `${unique}${ext}`);
  },
});

function fileFilter(_req, file, cb) {
  if (!file.mimetype || !file.mimetype.startsWith('image/')) {
    return cb(new Error('Dozwolone sÄ… tylko pliki graficzne.'), false);
  }
  cb(null, true);
}

const upload = multer({
  storage,
  fileFilter,
  limits: { fileSize: 5 * 1024 * 1024, files: 5 }, // 5MB, max 5 plikÃ³w
});

module.exports = upload;

==================================
middleware\validateObjectId.js v.1
==================================

const mongoose = require('mongoose');
const AppError = require('../utils/AppError');

const validateObjectId = (paramName = 'id') => {
  return (req, res, next) => {
    const id = req.params[paramName];

    if (!mongoose.Types.ObjectId.isValid(id)) {
      return next(new AppError(`NieprawidÅ‚owy format ID: ${id}`, 400));
    }

    next();
  };
};

module.exports = validateObjectId;

==================================
models\Article.js v.4
==================================

// models/Article.js v.2
const mongoose = require('mongoose');

const articleSchema = new mongoose.Schema(
  {
    title: {
      type: String,
      required: true,
      trim: true,
    },
    content: {
      type: String,
      required: true,
    },
    author: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User',
      required: true,
    },
    images: [{ type: String }],
    likes: [{ type: mongoose.Schema.Types.ObjectId, ref: 'User' }],
  },
  {
    timestamps: true,
  },
);

// âœ… POPRAWIONE: UsuniÄ™to duplikaty - ZOSTAW TYLKO JEDNÄ„ DEFINICJÄ˜ KAÅ»DEGO INDEKSU
articleSchema.index({ author: 1, createdAt: -1 }); // dla listy artykuÅ‚Ã³w usera
articleSchema.index({ title: 'text', content: 'text' }); // dla wyszukiwania tekstowego
articleSchema.index({ createdAt: -1 }); // Dla sortowania najnowszych

module.exports = mongoose.model('Article', articleSchema);


==================================
models\Comment.js v.2
==================================

// models/Comment.js v.2
const mongoose = require('mongoose');

const commentSchema = new mongoose.Schema({
  article: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Article',
    required: true,
    index: true, // âœ… Dodany indeks
  },
  author: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true,
  },
  text: {
    type: String,
    required: true,
    trim: true,
  },
  likes: [
    {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User',
    },
  ],
  createdAt: {
    type: Date,
    default: Date.now,
  },
});

commentSchema.index({ article: 1, createdAt: -1 }); // Komentarze dla artykuÅ‚u
commentSchema.index({ author: 1 }); // Komentarze usera

module.exports = mongoose.model('Comment', commentSchema);


==================================
models\PendingUser.js v.1
==================================

// models/PendingUser.js v.2
const mongoose = require("mongoose");

const pendingUserSchema = new mongoose.Schema({
    username: {
        type: String,
        required: true,
        trim: true,
    },
    email: {
        type: String,
        required: true,
        unique: true,
        trim: true,
        lowercase: true,
        match: /^[\w.-]+@([\w-]+\.)+[\w-]{2,4}$/,
    },
    password: {
        type: String,
        required: true,
    },
    role: {
        type: String,
        enum: ["user", "author"],
        default: "user",
    },
    createdAt: {
        type: Date,
        default: Date.now,
        expires: 86400, // âœ… Automatyczne usuwanie po 24 godzinach
    },
});

module.exports = mongoose.model("PendingUser", pendingUserSchema);


==================================
models\User.js v.4
==================================

// models/User.js v.2
const mongoose = require('mongoose');
const bcrypt = require('bcryptjs');

const userSchema = new mongoose.Schema({
  username: {
    type: String,
    required: true,
    unique: true, // âœ… TWORZY INDEX - wystarczy
    trim: true,
  },
  email: {
    type: String,
    required: true,
    unique: true, // âœ… TWORZY INDEX - wystarczy
    lowercase: true,
    trim: true,
    match: [/^[^\s@]+@[^\s@]+\.[^\s@]+$/, 'NieprawidÅ‚owy format adresu e-mail'],
    // âŒ USUÅƒ: index: true - to duplikuje unique: true
  },
  password: {
    type: String,
    required: true,
    minlength: 6,
  },
  role: {
    type: String,
    enum: ['user', 'author', 'admin'],
    default: 'user',
  },
});

userSchema.pre('save', async function (next) {
  if (!this.isModified('password')) return next();

  const isBcrypt =
    typeof this.password === 'string' &&
    /^\$2[aby]\$\d{2}\$[./A-Za-z0-9]{53}$/.test(this.password);
  if (isBcrypt) return next();

  const salt = await bcrypt.genSalt(10);
  this.password = await bcrypt.hash(this.password, salt);
  next();
});

userSchema.methods.comparePassword = async function (candidatePassword) {
  return await bcrypt.compare(candidatePassword, this.password);
};

// âœ… ZOSTAW tylko ten indeks (jeÅ›li potrzebujesz)
userSchema.index({ createdAt: -1 }); // Dla listy uÅ¼ytkownikÃ³w

module.exports = mongoose.model('User', userSchema);


==================================
package.json v.6
==================================

{
  "name": "cms-backend",
  "version": "1.0.0",
  "description": "",
  "main": "server.js",
  "scripts": {
    "redis:up": "node -e \"const { exec } = require('child_process'); exec('docker-compose down', () => { exec('docker-compose up -d redis') })\"",
    "redis:down": "docker-compose down",
    "dev": "npm run redis:up && nodemon server.js",
    "start": "npm run redis:up && node server.js",
    "stop": "npm run redis:down",
    "clean": "docker-compose down -v",
    "docker:status": "docker ps && docker-compose ps",
    "redis:logs": "docker-compose logs redis",
    "test": "jest --config jest.config.js --verbose",
    "test:watch": "jest --config jest.config.js --watch",
    "test:coverage": "jest --config jest.config.js --coverage",
    "test:unit": "jest --testPathIgnorePatterns=\"integration\"",
    "test:integration": "jest --testPathPatterns=\"integration\" --verbose",
    "test:auth": "jest __tests__/integration/auth.test.js --verbose",
    "test:articles": "jest __tests__/integration/articles.test.js --verbose",
    "test:comments": "jest __tests__/integration/comments.test.js --verbose",
    "test:users": "jest __tests__/integration/users.test.js --verbose",
    "test:admin": "jest __tests__/integration/admin.test.js --verbose",
    "test:rateLimit": "jest __tests__/integration/rateLimit.test.js --verbose --testTimeout=30000",
    "test:clean": "jest --clearCache",
    "lint": "eslint .",
    "lint:fix": "eslint . --fix",
    "format": "prettier --write .",
    "check-style": "npm run lint && npx prettier --check .",
    "create-indexes": "node scripts/createIndexes.js",
    "create-indexes:prod": "NODE_ENV=production node scripts/createIndexes.js",
    "test:performance": "node scripts/performanceTest.js",
    "test:performance:prod": "NODE_ENV=production node scripts/performanceTest.js",
    "backup": "node scripts/backup.js",
    "backup:clean": "node scripts/backup.js --clean",
    "backup:list": "node scripts/list-backups.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "engines": {
    "node": ">=18"
  },
  "dependencies": {
    "bcryptjs": "^3.0.2",
    "cookie-parser": "^1.4.7",
    "cors": "^2.8.5",
    "express": "^5.1.0",
    "express-rate-limit": "^8.0.1",
    "express-validator": "^7.2.1",
    "helmet": "^8.1.0",
    "jsonwebtoken": "^9.0.2",
    "mongoose": "^8.17.0",
    "multer": "^2.0.2",
    "nodemailer": "^7.0.5",
    "redis": "^5.8.2",
    "sanitize-html": "^2.17.0",
    "winston": "^3.17.0"
  },
  "devDependencies": {
    "@faker-js/faker": "^8.4.1",
    "@types/redis": "^4.0.10",
    "concurrently": "^9.2.1",
    "dotenv": "^17.2.1",
    "eslint": "^9.34.0",
    "eslint-config-prettier": "^10.1.8",
    "eslint-plugin-prettier": "^5.5.4",
    "globals": "^16.3.0",
    "jest": "^30.1.1",
    "mongodb-memory-server": "^10.2.0",
    "nodemon": "^3.1.10",
    "prettier": "^3.6.2",
    "supertest": "^7.1.4"
  }
}


==================================
routes\adminRoutes.js v.1
==================================

const express = require('express')
const router = express.Router()
const requireAuth = require('../middleware/authMiddleware')
const requireAdmin = require('../middleware/requireAdmin')

const {
  getPendingUsers,
  approveUser,
  rejectUser
} = require('../controllers/adminController')

router.get('/pending-users', requireAuth, requireAdmin, getPendingUsers)
router.post('/approve/:id', requireAuth, requireAdmin, approveUser)
router.delete('/reject/:id', requireAuth, requireAdmin, rejectUser)

module.exports = router

==================================
routes\articleRoutes.js v.3
==================================

const express = require('express');
const router = express.Router();
const {
  createArticle,
  getArticles,
  getArticleById,
  updateArticle,
  deleteArticle,
  toggleLikeArticle,
} = require('../controllers/articleController');
const upload = require('../middleware/upload');
const requireAuth = require('../middleware/authMiddleware');
const requireAuthorOrAdmin = require('../middleware/requireAuthorOrAdmin');
const validateObjectId = require('../middleware/validateObjectId');
const { validateArticle } = require('../utils/advancedValidate');
const { cacheMiddleware } = require('../middleware/cacheMiddleware');

// Lista i pojedynczy artykuÅ‚
router.get('/', cacheMiddleware(300), getArticles); // 5 minut cache
router.get('/:id', validateObjectId(), cacheMiddleware(600), getArticleById); // 10 minut cache

// Tworzenie / edycja / usuwanie (z autoryzacjÄ…)
router.post(
  '/',
  requireAuth,
  upload.array('images', 5),
  validateArticle,
  createArticle,
); // âœ…
router.put(
  '/:id',
  validateObjectId(),
  requireAuth,
  requireAuthorOrAdmin,
  upload.array('images', 5),
  validateArticle,
  updateArticle,
); // âœ…
router.delete(
  '/:id',
  validateObjectId(),
  requireAuth,
  requireAuthorOrAdmin,
  deleteArticle,
); // DODANE

// Lajk artykuÅ‚u
router.post('/:id/like', validateObjectId(), requireAuth, toggleLikeArticle); // DODANE

module.exports = router;


==================================
routes\authRoutes.js v.1
==================================

// routes/authRoutes.js v.2
const express = require("express");
const router = express.Router();
const { login, logout, registerPending } = require("../controllers/authController");
const { validateRegister, validateLogin } = require("../utils/advancedValidate"); // âœ… DODANE

// Logowanie
router.post("/login", validateLogin, login); // âœ… DODANA WALIDACJA

// Wylogowanie
router.post("/logout", logout);

// Rejestracja
router.post("/register-pending", validateRegister, registerPending); // âœ… DODANA WALIDACJA

module.exports = router;


==================================
routes\commentRoutes.js v.1
==================================

const express = require("express");
const router = express.Router();
const { addComment, getComments, deleteComment, updateComment } = require("../controllers/commentController");
const requireAuth = require("../middleware/authMiddleware");
const validateObjectId = require("../middleware/validateObjectId");
const { validateComment } = require("../utils/advancedValidate"); // âœ… DODANE

// Komentarze do artykuÅ‚u (id = articleId)
router.get("/:id", validateObjectId(), getComments); // DODANE
router.post("/:id", validateObjectId(), requireAuth, validateComment, addComment); // âœ…

// Operacje na konkretnym komentarzu (id = commentId)
router.put("/:id", validateObjectId(), requireAuth, validateComment, updateComment); // âœ…
router.delete("/:id", validateObjectId(), requireAuth, deleteComment);

module.exports = router;


==================================
routes\userRoutes.js v.1
==================================

const express = require("express");
const router = express.Router();
const requireAuth = require("../middleware/authMiddleware");
const requireAdmin = require("../middleware/requireAdmin");
const { getProfile, updateProfile, changePassword, listUsers, changeRole, deleteUser } = require("../controllers/userController");
const { validateUserUpdate } = require("../utils/advancedValidate"); // âœ… DODANE (trzeba dodaÄ‡ do advancedValidate)

// Profil zalogowanego uÅ¼ytkownika
router.get("/profile", requireAuth, getProfile);
router.put("/profile", requireAuth, validateUserUpdate, updateProfile);
router.put("/password", requireAuth, changePassword);

// Admin â€“ tylko dla roli 'admin'
router.get("/", requireAuth, requireAdmin, listUsers);
router.put("/:id/role", requireAuth, requireAdmin, changeRole);
router.delete("/:id", requireAuth, requireAdmin, deleteUser);

module.exports = router;


==================================
scripts\backup.js v.1
==================================

// backup.js - POPRAWIONA WERSJA
require('dotenv').config({ path: require('path').join(__dirname, '../.env') });

const { exec } = require('child_process');
const path = require('path');
const fs = require('fs');

const backupDir = path.join(__dirname, '../backup');
const date = new Date().toISOString().split('T')[0];
const backupPath = path.join(backupDir, date);

if (!fs.existsSync(backupDir)) {
  fs.mkdirSync(backupDir, { recursive: true });
}

// âœ… POPRAWIONE: ÅšcieÅ¼ka dla Git Bash na Windows
const mongodumpPath = '"/c/Program Files/MongoDB/Tools/100/bin/mongodump.exe"';
const command = `mongodump --uri="${process.env.MONGO_URI}" --out="./backup/${date}"`;

console.log('ðŸ”„ Tworzenie backupu...');
exec(command, (error, stdout, stderr) => {
  if (error) {
    console.error('âŒ BÅ‚Ä…d backupu:', error.message);
    return;
  }
  console.log('âœ… Backup utworzony:', date);
  console.log('ðŸ“ Lokalizacja:', backupPath);

  // Rotacja backupÃ³w
  const now = Date.now();
  const days30 = 30 * 24 * 60 * 60 * 1000;

  fs.readdir(backupDir, (err, files) => {
    if (err) return;

    files.forEach((file) => {
      const filePath = path.join(backupDir, file);
      fs.stat(filePath, (err, stat) => {
        if (!err && now - stat.mtimeMs > days30) {
          fs.rmSync(filePath, { recursive: true, force: true });
          console.log('ðŸ—‘ï¸ UsuniÄ™to stary backup:', file);
        }
      });
    });
  });
});


==================================
scripts\createIndexes.js v.2
==================================

// scripts/createIndexes.js
const mongoose = require('mongoose');
require('dotenv').config();

const createIndexes = async () => {
  try {
    await mongoose.connect(process.env.MONGO_URI);

    console.log('ðŸ—„ï¸ Tworzenie indeksÃ³w...');

    // WymuÅ› tworzenie indeksÃ³w
    const Article = require('../models/Article');
    const Comment = require('../models/Comment');
    const User = require('../models/User');

    await Article.createIndexes();
    await Comment.createIndexes();
    await User.createIndexes();

    console.log('âœ… Indeksy stworzone pomyÅ›lnie');
    process.exit(0);
  } catch (error) {
    console.error('âŒ BÅ‚Ä…d tworzenia indeksÃ³w:', error);
    process.exit(1);
  }
};

createIndexes();


==================================
scripts\list-backups.js v.1
==================================

const fs = require('fs');
const path = require('path');

const backupDir = path.join(__dirname, '../backup');

console.log('ðŸ“‹ Lista backupÃ³w:');
console.log('=================');

if (!fs.existsSync(backupDir)) {
  console.log('âŒ Brak folderu backup');
  return;
}

const backups = fs.readdirSync(backupDir).sort().reverse();

if (backups.length === 0) {
  console.log('âŒ Brak backupÃ³w');
  return;
}

backups.forEach(backup => {
  const backupPath = path.join(backupDir, backup);
  const stats = fs.statSync(backupPath);
  const size = formatBytes(getFolderSize(backupPath));
  
  console.log(`ðŸ“ ${backup} | ${size} | ${stats.mtime.toLocaleString()}`);
});

function getFolderSize(folderPath) {
  let totalSize = 0;
  const files = fs.readdirSync(folderPath);
  
  files.forEach(file => {
    const filePath = path.join(folderPath, file);
    const stats = fs.statSync(filePath);
    totalSize += stats.size;
  });
  
  return totalSize;
}

function formatBytes(bytes) {
  const sizes = ['B', 'KB', 'MB', 'GB'];
  if (bytes === 0) return '0 B';
  const i = Math.floor(Math.log(bytes) / Math.log(1024));
  return Math.round(bytes / Math.pow(1024, i), 2) + ' ' + sizes[i];
}

==================================
scripts\performanceTest.js v.1
==================================

const mongoose = require('mongoose');
require('dotenv').config();
const { faker } = require('@faker-js/faker');
const Article = require('../models/Article');
const User = require('../models/User');
const Comment = require('../models/Comment');

const PERFORMANCE_TEST_DATA = {
  users: 50,
  articles: 200,
  comments: 1000,
};

async function generateTestData() {
  console.log('ðŸ§ª Generowanie danych testowych...');

  // Generuj uÅ¼ytkownikÃ³w
  const users = [];
  for (let i = 0; i < PERFORMANCE_TEST_DATA.users; i++) {
    users.push({
      username: faker.internet.userName(),
      email: faker.internet.email(),
      password: '$2a$10$exampleHashedPassword', // przykÅ‚adowe zahaszowane hasÅ‚o
      role: faker.helpers.arrayElement(['user', 'author', 'admin']),
    });
  }

  const createdUsers = await User.insertMany(users);
  console.log(`âœ… Wygenerowano ${createdUsers.length} uÅ¼ytkownikÃ³w`);

  // Generuj artykuÅ‚y
  const articles = [];
  for (let i = 0; i < PERFORMANCE_TEST_DATA.articles; i++) {
    articles.push({
      title: faker.lorem.sentence(),
      content: faker.lorem.paragraphs(3),
      author: faker.helpers.arrayElement(createdUsers)._id,
      images: [],
      likes: [],
    });
  }

  const createdArticles = await Article.insertMany(articles);
  console.log(`âœ… Wygenerowano ${createdArticles.length} artykuÅ‚Ã³w`);

  // Generuj komentarze
  const comments = [];
  for (let i = 0; i < PERFORMANCE_TEST_DATA.comments; i++) {
    comments.push({
      text: faker.lorem.sentence(),
      article: faker.helpers.arrayElement(createdArticles)._id,
      author: faker.helpers.arrayElement(createdUsers)._id,
    });
  }

  await Comment.insertMany(comments);
  console.log(`âœ… Wygenerowano ${comments.length} komentarzy`);

  return { users: createdUsers, articles: createdArticles };
}

async function runPerformanceTests() {
  try {
    await mongoose.connect(process.env.MONGO_URI);
    console.log('ðŸš€ Rozpoczynam testy wydajnoÅ›ciowe...\n');

    // Generuj dane testowe
    const testData = await generateTestData();

    // Test 1: Pobieranie artykuÅ‚Ã³w z paginacjÄ…
    console.log('\nðŸ“Š TEST 1: Pobieranie artykuÅ‚Ã³w z paginacjÄ…');
    const start1 = Date.now();
    const articles = await Article.find()
      .populate('author', 'username email')
      .sort({ createdAt: -1 })
      .limit(10)
      .lean();
    const duration1 = Date.now() - start1;
    console.log(`â±ï¸ Czas: ${duration1}ms | IloÅ›Ä‡: ${articles.length}`);

    // Test 2: Wyszukiwanie peÅ‚notekstowe
    console.log('\nðŸ“Š TEST 2: Wyszukiwanie peÅ‚notekstowe');
    const start2 = Date.now();
    const searchResults = await Article.find({ $text: { $search: 'test' } })
      .limit(10)
      .lean();
    const duration2 = Date.now() - start2;
    console.log(`â±ï¸ Czas: ${duration2}ms | Wyniki: ${searchResults.length}`);

    // Test 3: Pobieranie z sortowaniem po polubieniach
    console.log('\nðŸ“Š TEST 3: Sortowanie po polubieniach');
    const start3 = Date.now();
    const likedArticles = await Article.aggregate([
      { $addFields: { likesCount: { $size: '$likes' } } },
      { $sort: { likesCount: -1 } },
      { $limit: 10 },
    ]);
    const duration3 = Date.now() - start3;
    console.log(`â±ï¸ Czas: ${duration3}ms | Wyniki: ${likedArticles.length}`);

    // Test 4: ZÅ‚oÅ¼one zapytanie z joinem
    console.log('\nðŸ“Š TEST 4: ArtykuÅ‚y uÅ¼ytkownika z komentarzami');
    const testUser = testData.users[0];
    const start4 = Date.now();
    const userArticles = await Article.find({ author: testUser._id })
      .populate('author')
      .sort({ createdAt: -1 })
      .lean();

    // Dodaj liczbÄ™ komentarzy
    const articlesWithComments = await Promise.all(
      userArticles.map(async (article) => {
        const commentCount = await Comment.countDocuments({
          article: article._id,
        });
        return { ...article, commentCount };
      }),
    );
    const duration4 = Date.now() - start4;
    console.log(
      `â±ï¸ Czas: ${duration4}ms | ArtykuÅ‚y: ${articlesWithComments.length}`,
    );

    console.log('\nðŸŽ¯ WYNIKI TESTOW:');
    console.log(`ðŸ“„ Pobieranie artykuÅ‚Ã³w: ${duration1}ms`);
    console.log(`ðŸ” Wyszukiwanie tekstowe: ${duration2}ms`);
    console.log(`â¤ï¸ Sortowanie po like'ach: ${duration3}ms`);
    console.log(`ðŸ‘¤ ZÅ‚oÅ¼one zapytania: ${duration4}ms`);

    // CzyÅ›Ä‡ dane testowe
    await Article.deleteMany({});
    await Comment.deleteMany({});
    await User.deleteMany({});
    console.log('\nðŸ§¹ Wyczyszczono dane testowe');
  } catch (error) {
    console.error('âŒ BÅ‚Ä…d testÃ³w:', error);
  } finally {
    await mongoose.disconnect();
    console.log('\nâœ… Testy zakoÅ„czone');
  }
}

// Uruchom testy jeÅ›li skrypt jest wywoÅ‚any bezpoÅ›rednio
if (require.main === module) {
  runPerformanceTests();
}

module.exports = { runPerformanceTests, PERFORMANCE_TEST_DATA };


==================================
server.js v.7
==================================

const express = require('express');
const mongoose = require('mongoose');
const dotenv = require('dotenv');
const helmet = require('helmet');
const cookieParser = require('cookie-parser');
const cors = require('cors');
const path = require('path');
const logger = require('./utils/logger');
const deepSanitize = require('./middleware/sanitizeMiddleware');
const cspMiddleware = require('./middleware/cspMiddleware');
const redisClient = require('./utils/redisClient');
const { cacheMiddleware } = require('./middleware/cacheMiddleware');
const performanceMiddleware = require('./middleware/performanceMiddleware');

// ðŸŽ¯ POPRAWIONE: JEDEN import limitersÃ³w
const {
  globalLimiter,
  authLimiter,
  adminLimiter,
} = require('./middleware/rateLimit');

// ðŸŽ¯ DODANE: Import memory server dla testÃ³w
const { MongoMemoryServer } = require('mongodb-memory-server');

dotenv.config();
const app = express();

// Åšrodowisko
const PORT = process.env.PORT || 5000;
let MONGO_URI = process.env.MONGO_URI;

// ðŸŽ¯ DODANE: Zmienna dla memory server
let mongoServer;

// ðŸŽ¯ DODANE: Funkcja inicjalizacji testowej bazy
const initializeTestDatabase = async () => {
  if (process.env.NODE_ENV === 'test') {
    mongoServer = await MongoMemoryServer.create();
    MONGO_URI = mongoServer.getUri();
    logger.info(`ðŸ§ª Test MongoDB URI: ${MONGO_URI}`);
  }
};

// ðŸŽ¯ DODANE: Funkcja czyszczenia testowej bazy
const cleanupTestDatabase = async () => {
  if (process.env.NODE_ENV === 'test' && mongoServer) {
    await mongoose.disconnect();
    await mongoServer.stop();
    logger.info('ðŸ§ª Test MongoDB stopped');
  }
};

if (process.env.NODE_ENV === 'development') {
  require('./utils/queryLogger');
}

// Middleware
app.use(helmet());
app.use(performanceMiddleware);
app.use(cspMiddleware);
if (process.env.NODE_ENV !== 'test') {
  app.use(deepSanitize);
}
app.use(express.json());
app.use(cookieParser());

const ALLOWED_ORIGINS = ['http://localhost:3000'];

const corsOptions = {
  origin: (origin, cb) => {
    if (!origin || ALLOWED_ORIGINS.includes(origin)) {
      cb(null, true);
    } else {
      cb(new Error('Not allowed by CORS'));
    }
  },
  credentials: true,
};

app.use(cors(corsOptions));

// ðŸŽ¯ ZMIENIONE: Nowa konfiguracja rate limiting
app.use('/api/auth', authLimiter); // ðŸŽ¯ NOWY limiter dla auth
app.use('/api/admin', adminLimiter); // ðŸŽ¯ NOWY limiter dla admin
app.use(globalLimiter); // ðŸŽ¯ NOWY globalny limiter

// Statyczne pliki (obrazki)
app.use(
  '/uploads',
  express.static(path.join(__dirname, 'uploads'), {
    setHeaders: (res) => {
      res.setHeader('Cross-Origin-Resource-Policy', 'cross-origin');
    },
  }),
);

// Trasy API
app.use('/api/auth', require('./routes/authRoutes'));
app.use('/api/articles', require('./routes/articleRoutes'));
app.use('/api/comments', require('./routes/commentRoutes'));
app.use('/api/users', require('./routes/userRoutes'));
app.use('/api/admin', require('./routes/adminRoutes'));

// 404 â€“ brak trasy
app.use((req, res) => {
  res.status(404).json({ message: 'Nie znaleziono endpointu.' });
});

// Globalny error handler
app.use((err, req, res, _next) => {
  if (err && err.code === 'LIMIT_FILE_SIZE') {
    return res.status(413).json({ message: 'Za duÅ¼y plik. Limit 5MB.' });
  }
  if (
    err &&
    err.message &&
    /pliki graficzne|plik[Ã³w]* graficzny|image/i.test(err.message)
  ) {
    return res
      .status(400)
      .json({ message: 'Dozwolone sÄ… tylko pliki graficzne.' });
  }

  err.statusCode = err.statusCode || 500;
  err.status = err.status || 'error';

  if (process.env.NODE_ENV === 'development') {
    logger.error('ERROR ðŸ’¥:', err);
    return res.status(err.statusCode).json({
      status: err.status,
      error: err,
      message: err.message,
      stack: err.stack,
    });
  }

  if (err.isOperational) {
    return res.status(err.statusCode).json({
      status: err.status,
      message: err.message,
    });
  } else {
    logger.error('ERROR ðŸ’¥:', err);
    return res.status(500).json({
      status: 'error',
      message: 'CoÅ› poszÅ‚o nie tak!',
    });
  }
});

// Inicjalizacja Redis przy starcie
const initRedis = async () => {
  try {
    await redisClient.connect();
    logger.info('âœ… Redis connected');
  } catch (error) {
    logger.warn('âŒ Redis not available, continuing without cache');
  }
};

// ðŸŽ¯ ZMODYFIKOWANE: Funkcja startu serwera
const startServer = async () => {
  try {
    // Inicjalizuj testowÄ… bazÄ™ jeÅ›li potrzeba
    await initializeTestDatabase();

    // Inicjalizacja Redis
    await initRedis();

    // PoÅ‚Ä…czenie z MongoDB
    await mongoose.connect(MONGO_URI, {});
    logger.info('âœ… PoÅ‚Ä…czono z MongoDB');

    const conn = mongoose.connection;
    logger.info(`ðŸ“¦ Baza: ${conn.name}`);
    logger.info(`ðŸŒ Host: ${conn.host}`);

    // ðŸ”„ BACKUP MANAGER - DODAJ TUTAJ
    const backupManager = {
      lastBackup: 0,
      
      async performBackup() {
        const now = Date.now();
        const hours24 = 24 * 60 * 60 * 1000;
        
        if (now - this.lastBackup > hours24) {
          logger.info('ðŸ”„ Automatyczny backup...');
          try {
            const backupScript = require('./scripts/backup');
            await backupScript.performBackup();
            this.lastBackup = now;
            logger.info('âœ… Backup wykonany pomyÅ›lnie');
          } catch (error) {
            logger.error('âŒ BÅ‚Ä…d backupu:', error);
          }
        }
      },
    };

    // Backup przy starcie (tylko production)
    if (process.env.NODE_ENV === 'production' || process.env.NODE_ENV === 'development') {
      await backupManager.performBackup();
    }

    // Co godzinÄ™ sprawdzaj czy czas na backup (tylko production)
    if (process.env.NODE_ENV === 'production') {
      setInterval(() => backupManager.performBackup(), 60 * 60 * 1000); // 1 godzina
    }

    // Uruchom serwer tylko jeÅ›li nie jesteÅ›my w testach
    if (process.env.NODE_ENV !== 'test') {
      app.listen(PORT, () => logger.info(`ðŸš€ Serwer dziaÅ‚a na porcie ${PORT}`));
    }
  } catch (err) {
    logger.error('âŒ BÅ‚Ä…d uruchamiania serwera:', err);

    // SprzÄ…tanie testowej bazy w przypadku bÅ‚Ä™du
    await cleanupTestDatabase();
    process.exit(1);
  }
};

// ðŸŽ¯ DODANE: Eksport app dla testÃ³w Supertest
if (process.env.NODE_ENV === 'test') {
  module.exports = { app, startServer, cleanupTestDatabase };
} else {
  // Standardowe uruchomienie
  startServer();
}

// ðŸŽ¯ DODANE: ObsÅ‚uga graceful shutdown
process.on('SIGINT', async () => {
  logger.info('ðŸ›‘ Zamykanie serwera...');
  await redisClient.disconnect();
  await cleanupTestDatabase();
  process.exit(0);
});

process.on('SIGTERM', async () => {
  logger.info('ðŸ›‘ Zamykanie serwera (SIGTERM)...');
  await redisClient.disconnect();
  await cleanupTestDatabase();
  process.exit(0);
});


==================================
services\articleService.js v.4
==================================

// services/articleService.js
const logger = require('../utils/logger');
const Article = require('../models/Article');
const Comment = require('../models/Comment');
const fs = require('fs');
const path = require('path');
const { sanitizeTitle, sanitizeBody } = require('../utils/sanitize');
const validateFields = require('../utils/validate');

const UPLOADS_DIR = path.join(__dirname, '..', 'uploads');

// Helper functions
function toPublicPath(p) {
  if (!p) return null;
  const s = String(p).replace(/\\/g, '/');
  if (s.startsWith('uploads/')) return s;
  const m = s.match(/uploads\/(.+)$/i);
  return m ? `uploads/${m[1]}` : `uploads/${path.basename(s)}`;
}

function toUploadsRel(p) {
  if (!p) return '';
  const s = String(p);
  const m = s.match(/uploads[/\\]+(.+)$/i);
  return m ? m[1] : path.basename(s);
}

// Create article
const createArticle = async (title, content, authorId, imagePaths) => {
  const errors = validateFields({
    title: [title, 'TytuÅ‚ jest wymagany'],
    content: [content, 'TreÅ›Ä‡ jest wymagana'],
  });

  if (title && title.length < 5)
    errors.push('TytuÅ‚ musi mieÄ‡ co najmniej 5 znakÃ³w');
  if (content && content.length < 20)
    errors.push('TreÅ›Ä‡ musi mieÄ‡ co najmniej 20 znakÃ³w');
  if (errors.length) throw new Error(errors.join(' '));

  const sanitizedTitle = sanitizeTitle(title);
  const sanitizedContent = sanitizeBody(content);

  const newArticle = new Article({
    title: sanitizedTitle,
    content: sanitizedContent,
    images: imagePaths,
    author: authorId,
  });

  console.log('RAW TITLE:', title);
  console.log('SANITIZED TITLE:', sanitizeTitle(title));

  await newArticle.save();
  return newArticle;
};

// Get articles with filtering, sorting, and pagination - ZOPTYMALIZOWANE
const getArticles = async (
  page = 1,
  limit = 5,
  search = '',
  sort = 'newest',
) => {
  const skip = (parseInt(page) - 1) * parseInt(limit);

  // âœ… ZOPTYMALIZOWANE: Build query with full-text search if available
  const query = search
    ? { $text: { $search: search } } // âœ… Uses full-text index
    : {};

  // âœ… ZOPTYMALIZOWANE: Sort options that use indexes
  const sortOptions = {
    newest: { createdAt: -1 }, // âœ… Uses index
    oldest: { createdAt: 1 }, // âœ… Uses index
    mostLiked: { likesCount: -1 }, // âœ… Uses index
    titleAZ: { title: 1, createdAt: -1 }, // âœ… Uses compound index
    titleZA: { title: -1, createdAt: -1 }, // âœ… Uses compound index
  };

  // âœ… ZOPTYMALIZOWANE: Use Promise.all for parallel execution
  const [articles, total] = await Promise.all([
    Article.find(query)
      .select('title content author images createdAt likes') // âœ… Only needed fields
      .populate('author', 'email username') // âœ… Only needed author fields
      .sort(sortOptions[sort] || sortOptions.newest)
      .skip(skip)
      .limit(parseInt(limit))
      .lean(), // âœ… Faster data return

    Article.countDocuments(query),
  ]);

  // âœ… ZOPTYMALIZOWANE: Parallel comment counts
  const articlesWithCounts = await Promise.all(
    articles.map(async (article) => {
      const commentCount = await Comment.countDocuments({
        article: article._id,
      });
      return {
        ...article,
        likesCount: Array.isArray(article.likes) ? article.likes.length : 0,
        commentCount,
        thumbnail:
          article.images && article.images.length > 0
            ? toPublicPath(article.images[0])
            : null,
      };
    }),
  );

  return { articles: articlesWithCounts, total };
};

// Get article by ID - ZOPTYMALIZOWANE
const getArticleById = async (id) => {
  // âœ… ZOPTYMALIZOWANE: Single query with projection
  const article = await Article.findById(id)
    .select('-__v') // âœ… Exclude unnecessary fields
    .populate('author', 'username email') // âœ… Only needed author fields
    .lean(); // âœ… Faster data return

  if (!article) throw new Error('Nie znaleziono artykuÅ‚u');

  // âœ… ZOPTYMALIZOWANE: Parallel comment count
  const [commentCount] = await Promise.all([
    Comment.countDocuments({ article: article._id }),
  ]);

  return {
    ...article,
    images: Array.isArray(article.images)
      ? article.images.map(toPublicPath)
      : [],
    commentCount,
  };
};

// Update article
const updateArticle = async (
  articleId,
  updateData,
  userId,
  userRole,
  files,
) => {
  const { title, content, removeImages } = updateData;
  const article = await Article.findById(articleId);
  if (!article) throw new Error('ArtykuÅ‚ nie znaleziony');

  // Check permissions
  if (String(article.author) !== String(userId) && userRole !== 'admin') {
    throw new Error('Brak uprawnieÅ„ do edycji');
  }

  // Handle image removal
  let imagesToRemove = [];
  if (typeof removeImages === 'string') imagesToRemove = [removeImages];
  else if (Array.isArray(removeImages)) imagesToRemove = removeImages;

  const normalizedToRemove = imagesToRemove.map(toUploadsRel);

  // Remove images from disk
  for (const rel of normalizedToRemove) {
    const full = path.join(UPLOADS_DIR, rel);
    if (full.startsWith(UPLOADS_DIR)) {
      fs.unlink(full, (err) => {
        if (err && err.code !== 'ENOENT') {
          logger.error(`BÅ‚Ä…d usuwania pliku: ${full}`, err);
        }
      });
    }
  }

  // Update article images
  article.images = (article.images || []).filter((img) => {
    const rel = toUploadsRel(img);
    return !normalizedToRemove.includes(rel);
  });

  // Add new images
  if (files && files.length > 0) {
    const newImages = files.map((f) =>
      `uploads/${f.filename}`.replace(/\\/g, '/'),
    );
    article.images.push(...newImages);
  }

  // Validate and update title and content
  const errors = [];
  if (title) {
    if (title.length < 5) errors.push('TytuÅ‚ musi mieÄ‡ co najmniej 5 znakÃ³w');
    else article.title = sanitizeTitle(title);
  }
  if (content) {
    if (content.length < 20)
      errors.push('TreÅ›Ä‡ musi mieÄ‡ co najmniej 20 znakÃ³w');
    else article.content = sanitizeBody(content);
  }
  if (errors.length) throw new Error(errors.join(' '));

  await article.save();
  return article;
};

// Delete article
const deleteArticle = async (articleId, userId, userRole) => {
  const article = await Article.findById(articleId);
  if (!article) throw new Error('ArtykuÅ‚ nie istnieje');

  if (String(article.author) !== String(userId) && userRole !== 'admin') {
    throw new Error('Brak uprawnieÅ„');
  }

  // Remove images from disk
  for (const img of article.images || []) {
    const rel = toUploadsRel(img);
    const full = path.join(UPLOADS_DIR, rel);
    if (full.startsWith(UPLOADS_DIR)) {
      fs.unlink(full, (err) => {
        if (err && err.code !== 'ENOENT') {
          logger.error(`BÅ‚Ä…d usuwania pliku ${full}:`, err);
        }
      });
    }
  }

  // âœ… ZOPTYMALIZOWANE: Parallel operations
  await Promise.all([
    Comment.deleteMany({ article: article._id }),
    article.deleteOne(),
  ]);
};

// Toggle like on article
const toggleLikeArticle = async (articleId, userId) => {
  const article = await Article.findById(articleId);
  if (!article) throw new Error('ArtykuÅ‚ nie znaleziony');

  // Author cannot like their own article
  if (article.author && String(article.author) === String(userId)) {
    throw new Error('Autor nie moÅ¼e polubiÄ‡ wÅ‚asnego artykuÅ‚u');
  }

  const alreadyLiked =
    Array.isArray(article.likes) &&
    article.likes.some((id) => String(id) === String(userId));

  if (alreadyLiked) article.likes.pull(userId);
  else article.likes.push(userId);

  await article.save();

  return {
    liked: !alreadyLiked,
    totalLikes: Array.isArray(article.likes) ? article.likes.length : 0,
  };
};

module.exports = {
  createArticle,
  getArticles,
  getArticleById,
  updateArticle,
  deleteArticle,
  toggleLikeArticle,
};


==================================
services\authService.js v.1
==================================

const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const User = require('../models/User');
const PendingUser = require('../models/PendingUser');
const validateFields = require('../utils/validate');

// Register pending user
const registerPending = async (username, email, password, role) => {
  const errors = validateFields({
    username: [username, 'Nazwa uÅ¼ytkownika jest wymagana.'],
    email: [email, 'Email jest wymagany.'],
    password: [password, 'HasÅ‚o jest wymagane.'],
    role: [role, 'Rola jest wymagana.'],
  });
  if (errors.length > 0) throw new Error(errors.join(' '));

  const exists = await PendingUser.findOne({ email });
  const existsReal = await User.findOne({ email });
  if (exists || existsReal) throw new Error('Email jest juÅ¼ zajÄ™ty.');

  const pendingUser = new PendingUser({ username, email, password, role });
  await pendingUser.save();
};

// Login user
const login = async (email, password) => {
  const errors = validateFields({
    email: [email, 'Email jest wymagany.'],
    password: [password, 'HasÅ‚o jest wymagane.'],
  });
  if (errors.length > 0) throw new Error(errors.join(' '));

  const user = await User.findOne({ email });
  if (!user) throw new Error('NieprawidÅ‚owy email lub hasÅ‚o.');

  const isMatch = await bcrypt.compare(password, user.password);
  if (!isMatch) throw new Error('NieprawidÅ‚owy email lub hasÅ‚o.');

  const token = jwt.sign({ id: user._id }, process.env.JWT_SECRET, { expiresIn: '1d' });
  return token;
};

module.exports = {
  registerPending,
  login,
};

==================================
services\commentService.js v.4
==================================

const Comment = require('../models/Comment');
const Article = require('../models/Article');
const validateFields = require('../utils/validate');
const { sanitizeComment } = require('../utils/sanitize');

// Add comment
const addComment = async (articleId, authorId, rawText) => {
  // 1. Walidacja podstawowa
  const errors = validateFields({
    text: [rawText, 'Komentarz nie moÅ¼e byÄ‡ pusty.'],
  });
  if (errors.length) throw new Error(errors.join(' '));

  // 2. Sanityzacja
  const sanitizedText = sanitizeComment(rawText || '');

  // 3. Walidacja po sanityzacji - sprawdÅº czy nie zostaÅ‚ pusty string
  const plainText = sanitizedText.replace(/<[^>]+>/g, '').trim();
  if (!plainText) {
    throw new Error(
      'Komentarz jest pusty po odfiltrowaniu niebezpiecznych elementÃ³w.',
    );
  }

  // 4. Walidacja dÅ‚ugoÅ›ci - DODAJ TEN WARUNEK
  if (plainText.length < 6) {
    throw new Error('Komentarz musi mieÄ‡ co najmniej 6 znakÃ³w.');
  }

  // Check if article exists
  const article = await Article.findById(articleId);
  if (!article) throw new Error('Nie znaleziono artykuÅ‚u.');

  const comment = await Comment.create({
    text: sanitizedText,
    article: articleId,
    author: authorId,
  });

  return comment;
};

// Get comments for article
const getComments = async (articleId, page = 1, limit = 20) => {
  const skip = (page - 1) * limit;

  const [comments, total] = await Promise.all([
    Comment.find({ article: articleId })
      .populate('author', 'username')
      .sort({ createdAt: -1 })
      .skip(skip)
      .limit(limit)
      .lean(),
    Comment.countDocuments({ article: articleId }),
  ]);

  return {
    comments,
    total,
    page,
    limit,
    totalPages: Math.ceil(total / limit),
  };
};

// Update comment
const updateComment = async (commentId, userId, userRole, newText) => {
  // Basic validation
  if (newText == null || String(newText).trim() === '') {
    throw new Error('Komentarz nie moÅ¼e byÄ‡ pusty.');
  }

  // Sanitize + validation
  const text = sanitizeComment(newText);
  const plain = text.replace(/<[^>]+>/g, '').trim();
  if (!plain) {
    throw new Error(
      'Komentarz jest pusty po odfiltrowaniu niebezpiecznych elementÃ³w.',
    );
  }
  if (plain.length < 6) {
    throw new Error('Komentarz musi mieÄ‡ co najmniej 6 znakÃ³w.');
  }

  const comment = await Comment.findById(commentId);
  if (!comment) throw new Error('Komentarz nie istnieje.');

  const isAuthor = String(comment.author) === String(userId);
  const isAdmin = userRole === 'admin';
  if (!isAuthor && !isAdmin)
    throw new Error('Brak uprawnieÅ„ do edycji komentarza.');

  comment.text = text;
  await comment.save();

  return comment;
};

// Delete comment
const deleteComment = async (commentId, userId, userRole) => {
  const comment = await Comment.findById(commentId);
  if (!comment) throw new Error('Komentarz nie istnieje.');

  const isAuthor = String(comment.author) === String(userId);
  const isAdmin = userRole === 'admin';
  if (!isAuthor && !isAdmin)
    throw new Error('Brak uprawnieÅ„ do usuniÄ™cia komentarza.');

  await comment.deleteOne();
};

module.exports = {
  addComment,
  getComments,
  updateComment,
  deleteComment,
};


==================================
services\userService.js v.2
==================================

const bcrypt = require('bcryptjs');
const User = require('../models/User');
const validateFields = require('../utils/validate');
const sanitize = require('sanitize-html');

// Get user profile
const getProfile = async (userId) => {
  const user = await User.findById(userId).select('-password');
  if (!user) throw new Error('UÅ¼ytkownik nie istnieje');
  return user;
};

// Update user profile
const updateProfile = async (userId, updateData) => {
  let { username } = updateData;
  const errors = [];

  if (username != null) {
    username = String(username).trim();
    if (username.length < 3)
      errors.push('Nazwa uÅ¼ytkownika musi mieÄ‡ co najmniej 3 znaki.');
  }

  if (errors.length) throw new Error(errors.join(' '));

  const user = await User.findById(userId);
  if (!user) throw new Error('UÅ¼ytkownik nie istnieje');

  if (username != null) user.username = sanitize(username);
  await user.save();

  const safeUser = user.toObject();
  delete safeUser.password;
  return safeUser;
};

// Change password
const changePassword = async (userId, oldPassword, newPassword) => {
  const errors = validateFields({
    oldPassword: [oldPassword, 'Stare hasÅ‚o jest wymagane.'],
    newPassword: [newPassword, 'Nowe hasÅ‚o jest wymagane.'],
  });

  if (newPassword && String(newPassword).length < 6) {
    errors.push('Nowe hasÅ‚o musi mieÄ‡ co najmniej 6 znakÃ³w.');
  }

  if (errors.length) throw new Error(errors.join(' '));

  const user = await User.findById(userId);
  if (!user) throw new Error('UÅ¼ytkownik nie istnieje');

  const isMatch = await bcrypt.compare(String(oldPassword), user.password);
  if (!isMatch) throw new Error('Stare hasÅ‚o jest nieprawidÅ‚owe.');

  user.password = await bcrypt.hash(String(newPassword), 10);
  await user.save();
};

// Admin: List all users
const listUsers = async (page = 1, limit = 10, search = '') => {
  const skip = (page - 1) * limit;

  // Query z wyszukiwaniem
  const query = search
    ? {
        $or: [
          { username: { $regex: search, $options: 'i' } },
          { email: { $regex: search, $options: 'i' } },
        ],
      }
    : {};

  const [users, total] = await Promise.all([
    User.find(query)
      .select('-password')
      .sort({ createdAt: -1 })
      .skip(skip)
      .limit(limit),
    User.countDocuments(query),
  ]);

  return {
    users,
    total,
    page,
    limit,
    totalPages: Math.ceil(total / limit),
  };
};

// Admin: Change user role
const changeRole = async (userId, role) => {
  // âœ… POPRAWIONE: UÅ¼ywamy zmiennej errors
  const errors = validateFields({
    role: [role, 'Rola jest wymagana.'],
  });

  if (errors.length) {
    throw new Error(errors.join(' '));
  }

  const allowedRoles = ['user', 'author', 'admin'];
  if (!allowedRoles.includes(String(role))) {
    throw new Error('NieprawidÅ‚owa rola.');
  }

  const user = await User.findById(userId);
  if (!user) throw new Error('UÅ¼ytkownik nie istnieje.');

  user.role = role;
  await user.save();

  const safeUser = user.toObject();
  delete safeUser.password;
  return safeUser;
};

// Admin: Delete user
const deleteUser = async (userId) => {
  const user = await User.findById(userId);
  if (!user) throw new Error('UÅ¼ytkownik nie istnieje.');

  await user.deleteOne();
};

module.exports = {
  getProfile,
  updateProfile,
  changePassword,
  listUsers,
  changeRole,
  deleteUser,
};


==================================
utils\AppError.js v.1
==================================

// utils/AppError.js v.1
class AppError extends Error {
  constructor(message, statusCode) {
    super(message);
    this.statusCode = statusCode;
    this.status = `${statusCode}`.startsWith('4') ? 'fail' : 'error';
    this.isOperational = true;

    Error.captureStackTrace(this, this.constructor);
  }
}

module.exports = AppError;

==================================
utils\advancedValidate.js v.2
==================================

// utils/advancedValidate.js v.2
const { validationResult, body } = require('express-validator');

// Middleware do obsÅ‚ugi bÅ‚Ä™dÃ³w walidacji
const handleValidationErrors = (req, res, next) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    const errorMessages = errors.array().map((error) => error.msg);
    return res.status(400).json({
      status: 'fail',
      message: errorMessages.join(' '),
    });
  }
  next();
};

// Walidacja rejestracji
const validateRegister = [
  body('username')
    .isLength({ min: 3 })
    .withMessage('Nazwa uÅ¼ytkownika musi mieÄ‡ co najmniej 3 znaki')
    .trim(),
  body('email')
    .isEmail()
    .withMessage('Podaj prawidÅ‚owy adres email')
    .normalizeEmail(),
  body('password')
    .isLength({ min: 6 })
    .withMessage('HasÅ‚o musi mieÄ‡ co najmniej 6 znakÃ³w'),
  body('role').isIn(['user', 'author']).withMessage('NieprawidÅ‚owa rola'),
  handleValidationErrors,
];

// Walidacja logowania
const validateLogin = [
  body('email')
    .isEmail()
    .withMessage('Podaj prawidÅ‚owy adres email')
    .normalizeEmail(),
  body('password').notEmpty().withMessage('HasÅ‚o jest wymagane'),
  handleValidationErrors,
];

// Walidacja artykuÅ‚u
const validateArticle = [
  body('title')
    .isLength({ min: 5 })
    .withMessage('TytuÅ‚ musi mieÄ‡ co najmniej 5 znakÃ³w')
    .trim(),
  body('content')
    .isLength({ min: 20 })
    .withMessage('TreÅ›Ä‡ musi mieÄ‡ co najmniej 20 znakÃ³w')
    .trim(),
  handleValidationErrors,
];

// Walidacja komentarza
const validateComment = [
  body('text')
    .isLength({ min: 6 })
    .withMessage('Komentarz musi mieÄ‡ co najmniej 6 znakÃ³w')
    .trim(),
  handleValidationErrors,
];

// Walidacja zmiany hasÅ‚a
const validatePasswordChange = [
  body('oldPassword').notEmpty().withMessage('Stare hasÅ‚o jest wymagane'),
  body('newPassword')
    .isLength({ min: 6 })
    .withMessage('Nowe hasÅ‚o musi mieÄ‡ co najmniej 6 znakÃ³w'),
  handleValidationErrors,
];

// Walidacja zmiany roli (admin)
const validateRoleChange = [
  body('role')
    .isIn(['user', 'author', 'admin'])
    .withMessage('NieprawidÅ‚owa rola'),
  handleValidationErrors,
];

// Walidacja update'u usera
const validateUserUpdate = [
  body('username')
    .optional()
    .isLength({ min: 3 })
    .withMessage('Nazwa uÅ¼ytkownika musi mieÄ‡ co najmniej 3 znaki')
    .trim(),
  handleValidationErrors,
];

module.exports = {
  validateRegister,
  validateLogin,
  validateArticle,
  validateComment,
  validatePasswordChange,
  validateRoleChange,
  validateUserUpdate,
  handleValidationErrors,
};


==================================