Backend v.23

==================================
STRUKTURA PROJEKTU
==================================

+ 
  - .editorconfig
  - .env
  - .env.test
  # [EXCLUDED] .git
  - .gitattributes
  - .gitignore
  - .prettierrc
  + .vscode
    - .vscode\settings.json
  - Plan Backend.txt
  # [EXCLUDED] README.md
  + __tests__
    + __tests__\controllers
      - __tests__\controllers\adminController.test.js
    + __tests__\integration
      - __tests__\integration\admin.test.js
      - __tests__\integration\articles.test.js
      - __tests__\integration\auth.test.js
      - __tests__\integration\cache.test.js
      - __tests__\integration\comments.test.js
      - __tests__\integration\csp.test.js
      - __tests__\integration\performance.test.js
      - __tests__\integration\rateLimit.test.js
      - __tests__\integration\sanitization.test.js
      - __tests__\integration\users.test.js
    + __tests__\services
      - __tests__\services\articleService.createArticle.test.js
      - __tests__\services\articleService.getArticles.test.js
      - __tests__\services\articleService.toggleLikeArticle.test.js
      - __tests__\services\authService.register.pending.test.js
      - __tests__\services\authService.test.js
      - __tests__\services\commentService.test.js
      - __tests__\services\userService.integration.test.js
      - __tests__\services\userService.test.js
    + __tests__\utils
      - __tests__\utils\sanitize.test.js
  + backup
    + backup\cms
      - backup\cms\articles.bson
      - backup\cms\articles.metadata.json
      - backup\cms\comments.bson
      - backup\cms\comments.metadata.json
      - backup\cms\pendingusers.bson
      - backup\cms\pendingusers.metadata.json
      - backup\cms\users.bson
      - backup\cms\users.metadata.json
  + controllers
    - controllers\adminController.js
    - controllers\articleController.js
    - controllers\authController.js
    - controllers\commentController.js
    - controllers\userController.js
  - eslint.config.js
  - jest-mongodb-config.js
  - jest.config.js
  - jest.setup.js
  + middleware
    - middleware\authMiddleware.js
    - middleware\cacheMiddleware.js
    - middleware\cspMiddleware.js
    - middleware\isAuthor.js
    - middleware\isCommentAuthor.js
    - middleware\performanceMiddleware.js
    - middleware\rateLimit.js
    - middleware\requireAdmin.js
    - middleware\requireAuthorOrAdmin.js
    - middleware\sanitizeMiddleware.js
    - middleware\upload.js
    - middleware\validateObjectId.js
  + models
    - models\Article.js
    - models\Comment.js
    - models\PendingUser.js
    - models\User.js
  # [EXCLUDED] node_modules
  # [EXCLUDED] package-lock.json
  - package.json
  + routes
    - routes\adminRoutes.js
    - routes\articleRoutes.js
    - routes\authRoutes.js
    - routes\commentRoutes.js
    - routes\userRoutes.js
  # [EXCLUDED] scalacz_backendu
  + scripts
    - scripts\createIndexes.js
  - server.js
  + services
    - services\articleService.js
    - services\authService.js
    - services\commentService.js
    - services\userService.js
  + uploads
    - uploads\1754068886780-2025-05-08_17-46-27(1)-01.jpg
    - uploads\1754152749228-92812186_3218584588186739_8353233957860409344_n.jpg
    - uploads\1754156567535-92989817_3218584841520047_9082093743397404672_n.jpg
    - uploads\1754241925862-92989817_3218584841520047_9082093743397404672_n.jpg
    - uploads\1754310977682-92812186_3218584588186739_8353233957860409344_n.jpg
    - uploads\1754310977688-92948159_3218584998186698_4977806751773491200_n.jpg
    - uploads\1754310977693-92989817_3218584841520047_9082093743397404672_n.jpg
    - uploads\1754310977698-93254356_3218584681520063_688158527956451328_n.jpg
    - uploads\1754310977702-93303604_3218584784853386_6430330249937944576_n.jpg
    - uploads\1754332478792-93254356_3218584681520063_688158527956451328_n.jpg
    - uploads\1754332492051-93254356_3218584681520063_688158527956451328_n.jpg
    - uploads\1754332582184-93303604_3218584784853386_6430330249937944576_n.jpg
    - uploads\1754332738296-92948159_3218584998186698_4977806751773491200_n.jpg
    - uploads\1754332774555-92989817_3218584841520047_9082093743397404672_n.jpg
    - uploads\1754367503118-93303604_3218584784853386_6430330249937944576_n.jpg
    - uploads\1754387409764-92948159_3218584998186698_4977806751773491200_n.jpg
    - uploads\1754462018664-415954181.jpg
    - uploads\1754462123958-301796897.jpg
    - uploads\1754462384224-743992369.jpg
    - uploads\1754462515056-53701265.jpg
    - uploads\1754466490832-679145436.jpg
    - uploads\1754487751546-136461086.jpg
    - uploads\1754487788362-92598928.jpg
    - uploads\1754487826811-398469964.jpg
    - uploads\1754487826814-856807431.jpg
    - uploads\1754487826816-273726342.jpg
    - uploads\1754488665308-463888655.jpg
    - uploads\1754491303538-69773656.jpg
    - uploads\1754497317961-377443572.jpg
    - uploads\1754497317966-945997040.jpg
    - uploads\1756234408292-979512228.jpg
    - uploads\1756318975759-173818095.jpg
    - uploads\1756657307658-499081012.jpg
    - uploads\1756657756825-346829626.jpg
    - uploads\1756660214711-314048676.jpg
    - uploads\1756660258451-415853295.jpg
    - uploads\1756666053549-600682487.jpg
    - uploads\1756666082989-109778181.jpg
    - uploads\1756744162941-217753623.jpg
    - uploads\1756744538323-605333134.jpg
    - uploads\1756744538482-68374677.jpg
    - uploads\1756745272824-824896344.jpg
    - uploads\1756745273002-44688382.jpg
    - uploads\1756745273027-493877727.jpg
    - uploads\1756745811922-747871621.jpg
    - uploads\1756745812075-501152157.jpg
    - uploads\1756745812104-105262893.jpg
    - uploads\1756745873396-210006023.jpg
    - uploads\1756745873555-546599603.jpg
    - uploads\1756745873579-506963760.jpg
    - uploads\1756746218568-965732117.jpg
    - uploads\1756746218719-971552728.jpg
    - uploads\1756746218745-850609998.jpg
    - uploads\1756746282522-535178564.jpg
    - uploads\1756746282682-616618260.jpg
    - uploads\1756746282706-178996590.jpg
    - uploads\1756746481683-500058792.jpg
    - uploads\1756746481836-337460984.jpg
    - uploads\1756746481860-936692384.jpg
    - uploads\1756746538450-581221730.jpg
    - uploads\1756746538604-660689319.jpg
    - uploads\1756746538627-560811603.jpg
    - uploads\1756746717467-978772927.jpg
    - uploads\1756746717622-669638575.jpg
    - uploads\1756746717647-904674377.jpg
    - uploads\1756746804710-597519531.jpg
    - uploads\1756746804864-726654006.jpg
    - uploads\1756746804888-908441161.jpg
    - uploads\1756748436539-837513395.jpg
    - uploads\1756748436697-184509137.jpg
    - uploads\1756748436720-644344373.jpg
    - uploads\1756748591145-616193290.jpg
    - uploads\1756748591309-857443350.jpg
    - uploads\1756748591334-436700840.jpg
    - uploads\1756748903181-441438040.jpg
    - uploads\1756748903362-64697141.jpg
    - uploads\1756748903398-813462936.jpg
    - uploads\1756749131394-563604330.jpg
    - uploads\1756749131579-114911805.jpg
    - uploads\1756749131608-175554828.jpg
    - uploads\1756749401413-295028329.jpg
    - uploads\1756749401601-994645613.jpg
    - uploads\1756749401629-433218701.jpg
    - uploads\1756749668873-273283291.jpg
    - uploads\1756749669055-329166563.jpg
    - uploads\1756749669083-769996504.jpg
    - uploads\1756751265309-698354318.jpg
    - uploads\1756751265493-994886699.jpg
    - uploads\1756751265523-985679947.jpg
    - uploads\1756751529000-357944819.jpg
    - uploads\1756751529185-646635373.jpg
    - uploads\1756751529216-246750683.jpg
    - uploads\1756752724739-505985337.jpg
    - uploads\1756752724922-289345804.jpg
    - uploads\1756752724949-104778983.jpg
    - uploads\1756752753654-358592865.jpg
    - uploads\1756752754940-59077898.jpg
    - uploads\1756752755119-712420293.jpg
    - uploads\1756752755148-159481951.jpg
  + utils
    - utils\AppError.js
    - utils\advancedValidate.js
    - utils\emailTemplates.js
    - utils\logger.js
    - utils\mailer.js
    - utils\queryLogger.js
    - utils\redisClient.js
    - utils\sanitize.js
    - utils\validate.js

==================================
.editorconfig v.1
==================================

root = true

[*]
indent_style = space
indent_size = 2
end_of_line = lf
charset = utf-8
trim_trailing_whitespace = true
insert_final_newline = true

[*.js]
quote_type = single

[*.json]
quote_type = double

==================================
.env v.1
==================================

# Serwer aplikacji
PORT=5000
MONGO_URI=mongodb+srv://miroslawrup7:4snR6SR5f8RPM@cms-cluster.ippwmyf.mongodb.net/cms?retryWrites=true&w=majority
# MONGO_URI=mongodb://localhost:27017/cms
JWT_SECRET=twoj_tajny_klucz_ktory_nie_jest_prosty^%45
FRONTEND_URL=http://localhost:3000

# SMTP / Email
SMTP_HOST=smtp.gmail.com
SMTP_PORT=587
SMTP_SECURE=false
SMTP_USER=mirruptek7@gmail.com
SMTP_PASS=jcrjnhkarjnjvnql
MAIL_FROM="CMS <no-reply@twojadomena.pl>"

# Inne
APP_NAME=CMS

==================================
.env.test v.2
==================================

# .env.test
JWT_SECRET="super-tajny-testowy-klucz-ktory-nie-jest-tajny"
MONGO_URI="mongodb+srv://miroslawrup7:4snR6SR5f8RPM@cms-cluster.ippwmyf.mongodb.net/cms-test?retryWrites=true&w=majority"

# .env.test
REDIS_URL=redis://localhost:6379
REDIS_CACHE_TTL=60 # Krótszy TTL dla testów

==================================
.gitattributes v.1
==================================

* text=auto

==================================
.gitignore v.2
==================================

# Node modules
**/node_modules/

# Env files
**/.env

# System files
.DS_Store
Thumbs.db

# Logs
**/logs/
**/*.log


==================================
.prettierrc v.1
==================================

{
  "semi": true,
  "trailingComma": "all",
  "singleQuote": true,
  "printWidth": 80,
  "tabWidth": 2,
  "useTabs": false,
  "endOfLine": "lf"
}

==================================
.vscode\settings.json v.1
==================================

{
  "[javascript]": {
    "editor.defaultFormatter": "esbenp.prettier-vscode",
    "editor.formatOnSave": true
  },
  "editor.codeActionsOnSave": {
    "source.fixAll.eslint": "explicit"
  },
  "eslint.validate": ["javascript"],
  "prettier.requireConfig": true
}


==================================
Plan Backend.txt v.1
==================================

🟢 ETAP 1: TESTY JEDNOSTKOWE I INTEGRACYJNE USŁUG - ✅ 100%

1.1. Testy jednostkowe Services
    ✅ articleService (create, get, toggleLike)
    ✅ authService (login, registerPending)
    ✅ commentService
    ✅ userService (jednostkowe)
    ✅ adminController
1.2. Testy integracyjne Services
    ✅ userService.integration.test.js z MongoDB Memory Server
    ✅ Konfiguracja testowej bazy w pamięci
    ✅ Bezpieczne zarządzanie połączeniami
1.3. Konfiguracja i tooling
    ✅ ESLint + Prettier skonfigurowane
    ✅ Automatyczne formatowanie
    ✅ MongoDB Memory Server 

🟡 ETAP 2: TESTY INTEGRACYJNE ENDPOINTÓW HTTP - 🔄 0%

2.1. Endpointy autentykacji
    ✅ POST /api/auth/login - logowanie
    ✅ POST /api/auth/register-pending - rejestracja oczekująca
    ✅ POST /api/auth/logout - wylogowanie
2.2. Endpointy artykułów
    ✅ GET /api/articles - lista z paginacją
    ✅ POST /api/articles - tworzenie artykułu
    ✅ GET /api/articles/:id - pojedynczy artykuł
    ✅ PUT /api/articles/:id - edycja artykułu
    ✅ DELETE /api/articles/:id - usuwanie artykułu
    ✅ POST /api/articles/:id/like - like/dislike
2.3. Endpointy komentarzy
    ✅ GET /api/comments/:id - komentarze artykułu
    ✅ POST /api/comments/:id - dodawanie komentarza
    ✅ PUT /api/comments/:id - edycja komentarza
    ✅ DELETE /api/comments/:id - usuwanie komentarza
2.4. Endpointy użytkowników
    ✅ GET /api/users/profile - profil użytkownika
    ✅ PUT /api/users/profile - edycja profilu
    ✅ PUT /api/users/password - zmiana hasła
2.5. Endpointy administracyjne
    ✅ GET /api/admin/pending-users - lista użytkowników oczekujących
    ✅ POST /api/admin/approve/:id - zatwierdzanie użytkownika
    ✅ DELETE /api/admin/reject/:id - odrzucanie użytkownika

🔵 ETAP 3: OPTYMALIZACJA I ZABEZPIECZENIA - 🔄 0%

3.1. Bezpieczeństwo
    ✅ Rate limiting dla wszystkich endpointów
    ✅ Weryfikacja sanitization
    ✅ Content Security Policy headers

3.2. Wydajność
    ✅ Cache'owanie odpowiedzi (Redis)
    ⚪ Optymalizacja zapytań MongoDB
    ⚪ Paginacja dla wszystkich list

3.3. Logowanie i monitoring
    ⚪ Strukturalne logowanie (JSON)
    ⚪ Dodanie request IDs
    ⚪ Metryki wydajności

🟣 ETAP 4: ROZSZERZENIE FUNKCJONALNOŚCI - 🔄 0%

4.1. API Documentation
    ⚪ Swagger/OpenAPI documentation
    ⚪ API versioning przygotowanie

4.2. Zaawansowane features
    ⚪ Full-text search (Elasticsearch)
    ⚪ Notifications system
    ⚪ File upload optimization
    ⚪ Background jobs (bull.js)

4.3. DevOps przygotowanie
    ⚪ Dockerfile i docker-compose
    ⚪ Environment-based configuration
    ⚪ Health checks i readiness probe


==================================
__tests__\controllers\adminController.test.js v.1
==================================

// __tests__/controllers/adminController.test.js
const adminController = require('../../controllers/adminController');
const PendingUser = require('../../models/PendingUser');
const User = require('../../models/User');
const { sendMail } = require('../../utils/mailer');
/* eslint-disable no-unused-vars */
const AppError = require('../../utils/AppError');
/* eslint-enable no-unused-vars */
const bcrypt = require('bcryptjs');

// Mockujemy zależności
jest.mock('../../models/PendingUser');
jest.mock('../../models/User');
jest.mock('../../utils/mailer');
jest.mock('bcryptjs');
jest.mock('../../utils/AppError', () => {
  return jest.fn().mockImplementation((message, statusCode) => {
    const error = new Error(message);
    error.statusCode = statusCode;
    return error;
  });
});

describe('Kontroler: adminController', () => {
  let req, res, next;

  beforeEach(() => {
    jest.clearAllMocks();

    // Mock request, response i next
    req = {
      query: {},
      params: {},
      body: {},
    };
    res = {
      json: jest.fn(),
      status: jest.fn().mockReturnThis(),
    };
    next = jest.fn();
  });

  describe('getPendingUsers', () => {
    it('Powinien zwrócić listę użytkowników oczekujących z paginacją', async () => {
      // ARRANGE
      req.query = { page: '1', limit: '10', search: 'test' };
      const mockUsers = [
        { _id: '1', username: 'testuser1', email: 'test1@example.com' },
        { _id: '2', username: 'testuser2', email: 'test2@example.com' },
      ];

      PendingUser.countDocuments.mockResolvedValue(2);
      PendingUser.find.mockReturnValue({
        sort: jest.fn().mockReturnThis(),
        skip: jest.fn().mockReturnThis(),
        limit: jest.fn().mockReturnThis(),
        lean: jest.fn().mockResolvedValue(mockUsers),
      });

      // ACT
      await adminController.getPendingUsers(req, res, next);

      // ASSERT
      expect(PendingUser.countDocuments).toHaveBeenCalledWith({
        $or: [
          { username: { $regex: 'test', $options: 'i' } },
          { email: { $regex: 'test', $options: 'i' } },
        ],
      });
      expect(res.json).toHaveBeenCalledWith({
        total: 2,
        page: 1,
        limit: 10,
        users: mockUsers,
      });
    });

    it('Powinien obsłużyć błąd podczas pobierania użytkowników', async () => {
      // ARRANGE
      const error = new Error('Database error');
      PendingUser.countDocuments.mockRejectedValue(error);

      // ACT
      await adminController.getPendingUsers(req, res, next);

      // ASSERT
      expect(next).toHaveBeenCalledWith(error);
    });
  });

  describe('approveUser', () => {
    it('Powinien zatwierdzić użytkownika i wysłać email', async () => {
      // ARRANGE
      req.params = { id: 'pending123' };
      const mockPendingUser = {
        _id: 'pending123',
        username: 'testuser',
        email: 'test@example.com',
        password: 'rawpassword',
        role: 'user',
        deleteOne: jest.fn().mockResolvedValue(true),
      };

      const mockSavedUser = {
        _id: 'newUserId123', // ✅ TUTAJ JEST _id
        username: 'testuser',
        email: 'test@example.com',
        role: 'user',
      };

      PendingUser.findById.mockResolvedValue(mockPendingUser);
      User.findOne.mockResolvedValue(null);

      // Mock bcrypt.hash
      bcrypt.hash.mockResolvedValue('hashedpassword');

      // Mock User constructor and save - ZWRACA OBIEKT Z _id
      const mockSave = jest.fn().mockResolvedValue(mockSavedUser);
      User.mockImplementation(() => ({
        save: mockSave,
      }));

      sendMail.mockResolvedValue(true);

      // ACT
      await adminController.approveUser(req, res, next);

      // ASSERT
      expect(PendingUser.findById).toHaveBeenCalledWith('pending123');
      expect(User.findOne).toHaveBeenCalledWith({ email: 'test@example.com' });
      expect(bcrypt.hash).toHaveBeenCalledWith('rawpassword', 10);
      expect(User).toHaveBeenCalledWith({
        username: 'testuser',
        email: 'test@example.com',
        password: 'hashedpassword',
        role: 'user',
      });
      expect(mockSave).toHaveBeenCalled();
      expect(sendMail).toHaveBeenCalled();
      expect(res.json).toHaveBeenCalledWith({
        message: 'Użytkownik zatwierdzony i dodany do systemu.',
        userId: 'newUserId123', // ✅ TERAZ BĘDZIE PASOWAĆ
      });
    });

    it('Powinien rzucić błąd gdy wniosek nie istnieje', async () => {
      // ARRANGE
      req.params = { id: 'nonexistent' };
      PendingUser.findById.mockResolvedValue(null);

      // ACT
      await adminController.approveUser(req, res, next);

      // ASSERT
      expect(next).toHaveBeenCalledWith(expect.any(Error));
      expect(next.mock.calls[0][0].statusCode).toBe(404);
    });

    it('Powinien rzucić błąd gdy email już istnieje w systemie', async () => {
      // ARRANGE
      req.params = { id: 'pending123' };
      const mockPendingUser = {
        _id: 'pending123',
        email: 'existing@example.com',
        deleteOne: jest.fn().mockResolvedValue(true),
      };

      PendingUser.findById.mockResolvedValue(mockPendingUser);
      User.findOne.mockResolvedValue({ email: 'existing@example.com' });

      // ACT
      await adminController.approveUser(req, res, next);

      // ASSERT
      expect(next).toHaveBeenCalledWith(expect.any(Error));
      expect(next.mock.calls[0][0].statusCode).toBe(400);
    });
  });

  describe('rejectUser', () => {
    it('Powinien odrzucić użytkownika i wysłać email', async () => {
      // ARRANGE
      req.params = { id: 'pending123' };
      const mockPendingUser = {
        _id: 'pending123',
        username: 'testuser',
        email: 'test@example.com',
        deleteOne: jest.fn().mockResolvedValue(true),
      };

      PendingUser.findById.mockResolvedValue(mockPendingUser);
      sendMail.mockResolvedValue(true);

      // ACT
      await adminController.rejectUser(req, res, next);

      // ASSERT
      expect(PendingUser.findById).toHaveBeenCalledWith('pending123');
      expect(sendMail).toHaveBeenCalled();
      expect(mockPendingUser.deleteOne).toHaveBeenCalled();
      expect(res.json).toHaveBeenCalledWith({
        message: 'Wniosek został odrzucony.',
      });
    });

    it('Powinien obsłużyć błąd wysyłki emaila przy odrzuceniu', async () => {
      // ARRANGE
      req.params = { id: 'pending123' };
      const mockPendingUser = {
        _id: 'pending123',
        username: 'testuser',
        email: 'test@example.com',
        deleteOne: jest.fn().mockResolvedValue(true),
      };

      PendingUser.findById.mockResolvedValue(mockPendingUser);
      const mailError = new Error('SMTP error');
      sendMail.mockRejectedValue(mailError);

      // ACT
      await adminController.rejectUser(req, res, next);

      // ASSERT
      expect(sendMail).toHaveBeenCalled();
      expect(mockPendingUser.deleteOne).toHaveBeenCalled();
      expect(res.json).toHaveBeenCalledWith({
        message: 'Wniosek został odrzucony.',
      });
    });

    it('Powinien rzucić błąd gdy wniosek nie istnieje', async () => {
      // ARRANGE
      req.params = { id: 'nonexistent' };
      PendingUser.findById.mockResolvedValue(null);

      // ACT
      await adminController.rejectUser(req, res, next);

      // ASSERT
      expect(next).toHaveBeenCalledWith(expect.any(Error));
      expect(next.mock.calls[0][0].statusCode).toBe(404);
    });
  });
});


==================================
__tests__\integration\admin.test.js v.2
==================================

const request = require('supertest');
const mongoose = require('mongoose');
const { app, startServer, cleanupTestDatabase } = require('../../server');
const PendingUser = require('../../models/PendingUser');
const User = require('../../models/User');
const bcrypt = require('bcryptjs');

describe('Integracja: Endpointy Administracyjne', () => {
  let adminAuthToken;
  let userAuthToken;
  let _adminUser;
  let _regularUser;
  let pendingUser1;
  let pendingUser2;

  beforeAll(async () => {
    await startServer();

    // Utwórz administratora
    const hashedAdminPassword = await bcrypt.hash('admin123', 10);
    _adminUser = await User.create({
      email: 'admin@example.com',
      password: hashedAdminPassword,
      username: 'adminuser',
      role: 'admin',
    });

    // Utwórz zwykłego użytkownika
    const hashedUserPassword = await bcrypt.hash('user123', 10);
    _regularUser = await User.create({
      email: 'regular@example.com',
      password: hashedUserPassword,
      username: 'regularuser',
      role: 'user',
    });

    // Utwórz użytkowników oczekujących
    pendingUser1 = await PendingUser.create({
      username: 'pendinguser1',
      email: 'pending1@example.com',
      password: 'pendingpass1',
      role: 'user',
    });

    pendingUser2 = await PendingUser.create({
      username: 'pendinguser2',
      email: 'pending2@example.com',
      password: 'pendingpass2',
      role: 'author',
    });

    // Login jako admin aby dostać token
    const adminLoginResponse = await request(app).post('/api/auth/login').send({
      email: 'admin@example.com',
      password: 'admin123',
    });
    adminAuthToken = adminLoginResponse.headers['set-cookie'][0];

    // Login jako zwykły użytkownik
    const userLoginResponse = await request(app).post('/api/auth/login').send({
      email: 'regular@example.com',
      password: 'user123',
    });
    userAuthToken = userLoginResponse.headers['set-cookie'][0];
  });

  afterAll(async () => {
    await PendingUser.deleteMany({});
    await User.deleteMany({});
    await cleanupTestDatabase();
  });

  // 1. GET /api/admin/pending-users
  describe('GET /api/admin/pending-users', () => {
    it('Powinien zwrócić listę użytkowników oczekujących dla administratora', async () => {
      const response = await request(app)
        .get('/api/admin/pending-users')
        .set('Cookie', adminAuthToken);

      expect(response.status).toBe(200);
      expect(response.body).toHaveProperty('users');
      expect(Array.isArray(response.body.users)).toBe(true);
      expect(response.body.users.length).toBe(2);
      expect(response.body).toHaveProperty('total', 2);
    });

    it('Powinien zwrócić błąd 403 dla zwykłego użytkownika', async () => {
      const response = await request(app)
        .get('/api/admin/pending-users')
        .set('Cookie', userAuthToken);

      expect(response.status).toBe(403);
    });

    it('Powinien zwrócić błąd 401 gdy brak autoryzacji', async () => {
      const response = await request(app).get('/api/admin/pending-users');

      expect(response.status).toBe(401);
    });
  });

  // 2. POST /api/admin/approve/:id
  describe('POST /api/admin/approve/:id', () => {
    it('Powinien zatwierdzić użytkownika oczekującego', async () => {
      const response = await request(app)
        .post(`/api/admin/approve/${pendingUser1._id}`)
        .set('Cookie', adminAuthToken);

      expect(response.status).toBe(200);
      expect(response.body).toHaveProperty(
        'message',
        'Użytkownik zatwierdzony i dodany do systemu.',
      );
      expect(response.body).toHaveProperty('userId');

      // Sprawdź czy użytkownik został przeniesiony do kolekcji User
      const approvedUser = await User.findOne({
        email: 'pending1@example.com',
      });
      expect(approvedUser).not.toBeNull();
      expect(approvedUser.username).toBe('pendinguser1');

      // Sprawdź czy użytkownik został usunięty z kolekcji PendingUser
      const pendingUser = await PendingUser.findById(pendingUser1._id);
      expect(pendingUser).toBeNull();
    });

    it('Powinien zwrócić błąd 404 dla nieistniejącego użytkownika oczekującego', async () => {
      const fakeId = new mongoose.Types.ObjectId();

      const response = await request(app)
        .post(`/api/admin/approve/${fakeId}`)
        .set('Cookie', adminAuthToken);

      expect(response.status).toBe(404);
    });

    it('Powinien zwrócić błąd 403 dla zwykłego użytkownika', async () => {
      const response = await request(app)
        .post(`/api/admin/approve/${pendingUser2._id}`)
        .set('Cookie', userAuthToken);

      expect(response.status).toBe(403);
    });
  });

  // 3. DELETE /api/admin/reject/:id
  describe('DELETE /api/admin/reject/:id', () => {
    it('Powinien odrzucić użytkownika oczekującego', async () => {
      const response = await request(app)
        .delete(`/api/admin/reject/${pendingUser2._id}`)
        .set('Cookie', adminAuthToken);

      expect(response.status).toBe(200);
      expect(response.body).toHaveProperty(
        'message',
        'Wniosek został odrzucony.',
      );

      // Sprawdź czy użytkownik został usunięty z kolekcji PendingUser
      const rejectedUser = await PendingUser.findById(pendingUser2._id);
      expect(rejectedUser).toBeNull();

      // Sprawdź czy użytkownik NIE został dodany do kolekcji User
      const userInSystem = await User.findOne({
        email: 'pending2@example.com',
      });
      expect(userInSystem).toBeNull();
    });

    it('Powinien zwrócić błąd 404 dla nieistniejącego użytkownika oczekującego', async () => {
      const fakeId = new mongoose.Types.ObjectId();

      const response = await request(app)
        .delete(`/api/admin/reject/${fakeId}`)
        .set('Cookie', adminAuthToken);

      expect(response.status).toBe(404);
    });

    it('Powinien zwrócić błąd 403 dla zwykłego użytkownika', async () => {
      // Utwórz kolejnego użytkownika oczekującego do testu
      const testPendingUser = await PendingUser.create({
        username: 'testreject',
        email: 'testreject@example.com',
        password: 'testpass',
        role: 'user',
      });

      const response = await request(app)
        .delete(`/api/admin/reject/${testPendingUser._id}`)
        .set('Cookie', userAuthToken);

      expect(response.status).toBe(403);

      // Posprzątaj
      await PendingUser.findByIdAndDelete(testPendingUser._id);
    });
  });
});


==================================
__tests__\integration\articles.test.js v.2
==================================

// __tests__/integration/articles.test.js
const request = require('supertest');
const mongoose = require('mongoose');
const { app, startServer, cleanupTestDatabase } = require('../../server');
const Article = require('../../models/Article');
const User = require('../../models/User');
const bcrypt = require('bcryptjs');

describe('Integracja: Endpointy Artykułów', () => {
  let authToken;
  let testUser;

  beforeAll(async () => {
    await startServer();

    // Utwórz testowego użytkownika i zaloguj
    const hashedPassword = await bcrypt.hash('test123', 10);
    testUser = await User.create({
      email: 'author@example.com',
      password: hashedPassword,
      username: 'author',
      role: 'author',
    });

    // Login aby dostać token
    const loginResponse = await request(app).post('/api/auth/login').send({
      email: 'author@example.com',
      password: 'test123',
    });

    authToken = loginResponse.headers['set-cookie'][0];
  });

  afterEach(async () => {
    await Article.deleteMany({});
  });

  afterAll(async () => {
    await User.deleteMany({});
    await cleanupTestDatabase();
  });

  // ✅ TEST 1: GET /api/articles - lista z paginacją
  describe('GET /api/articles', () => {
    it('Powinien zwrócić listę artykułów z paginacją', async () => {
      // Utwórz testowe artykuły
      await Article.create([
        {
          title: 'Test Article 1',
          content: 'Content of article 1',
          author: testUser._id,
          images: [],
        },
        {
          title: 'Test Article 2',
          content: 'Content of article 2',
          author: testUser._id,
          images: [],
        },
      ]);

      const response = await request(app)
        .get('/api/articles?page=1&limit=2')
        .set('Cookie', authToken);

      expect(response.status).toBe(200);
      expect(response.body).toHaveProperty('articles');
      expect(response.body).toHaveProperty('total');
      expect(response.body.articles).toHaveLength(2);
    });
  });

  // ✅ TEST 2: POST /api/articles - tworzenie artykułu
  describe('POST /api/articles', () => {
    it('Powinien utworzyć nowy artykuł', async () => {
      const response = await request(app)
        .post('/api/articles')
        .set('Cookie', authToken)
        .field('title', 'New Test Article')
        .field('content', 'This is the content of the new article')
        .attach('images', Buffer.from('test'), 'test.jpg');

      expect(response.status).toBe(201);
      expect(response.body).toHaveProperty('message', 'Artykuł utworzony');
      expect(response.body).toHaveProperty('article');
    });
  });

  // ✅ TEST 3: GET /api/articles/:id - pojedynczy artykuł
  describe('GET /api/articles/:id', () => {
    it('Powinien zwrócić pojedynczy artykuł', async () => {
      const article = await Article.create({
        title: 'Single Article',
        content: 'Content for single article',
        author: testUser._id,
        images: [],
      });

      const response = await request(app)
        .get(`/api/articles/${article._id}`)
        .set('Cookie', authToken);

      expect(response.status).toBe(200);
      expect(response.body).toHaveProperty('title', 'Single Article');
    });
  });

  // ✅ TEST 4: PUT /api/articles/:id - edycja artykułu
  describe('PUT /api/articles/:id', () => {
    it('Powinien zaktualizować artykuł', async () => {
      const article = await Article.create({
        title: 'Old Title',
        content: 'Old content',
        author: testUser._id,
        images: [],
      });

      const response = await request(app)
        .put(`/api/articles/${article._id}`)
        .set('Cookie', authToken)
        .send({
          title: 'Updated Title',
          content: 'This is updated content that is longer than 20 characters', // Minimum 20 znaków
        });

      expect(response.status).toBe(200);
      expect(response.body).toHaveProperty('message', 'Artykuł zaktualizowany');
    });
  });

  // ✅ TEST 5: DELETE /api/articles/:id - usuwanie artykułu
  describe('DELETE /api/articles/:id', () => {
    it('Powinien usunąć artykuł', async () => {
      const article = await Article.create({
        title: 'Article to delete',
        content: 'Content to delete',
        author: testUser._id,
        images: [],
      });

      const response = await request(app)
        .delete(`/api/articles/${article._id}`)
        .set('Cookie', authToken);

      expect(response.status).toBe(204);
    });
  });

  // ✅ TEST 6: POST /api/articles/:id/like - like/dislike
  describe('POST /api/articles/:id/like', () => {
    it('Powinien dodać like do artykułu', async () => {
      const article = await Article.create({
        title: 'Article to like',
        content: 'Content to like',
        author: new mongoose.Types.ObjectId(), // Inny autor
        images: [],
      });

      const response = await request(app)
        .post(`/api/articles/${article._id}/like`)
        .set('Cookie', authToken);

      expect(response.status).toBe(200);
      expect(response.body).toHaveProperty('liked', true);
    });
  });
});


==================================
__tests__\integration\auth.test.js v.1
==================================

// __tests__/integration/auth.test.js
const request = require('supertest');
const { app, startServer, cleanupTestDatabase } = require('../../server');
const User = require('../../models/User');
const PendingUser = require('../../models/PendingUser');
const bcrypt = require('bcryptjs');

describe('Integracja: Endpointy Autentykacji', () => {
  beforeAll(async () => {
    await startServer();
  });

  afterEach(async () => {
    // Czyść wszystkie kolekcje po każdym teście
    await User.deleteMany({});
    await PendingUser.deleteMany({});
  });

  afterAll(async () => {
    await cleanupTestDatabase();
  });

  describe('POST /api/auth/login', () => {
    it('Powinien zalogować użytkownika i zwrócić cookie z tokenem', async () => {
      // 1. Utwórz aktywnego użytkownika
      const hashedPassword = await bcrypt.hash('test123', 10);
      await User.create({
        email: 'test@example.com',
        password: hashedPassword,
        username: 'testuser',
        role: 'user',
      });

      // 2. Wyślij request login
      const response = await request(app).post('/api/auth/login').send({
        email: 'test@example.com',
        password: 'test123',
      });

      // 3. Sprawdź response
      expect(response.status).toBe(200);
      expect(response.body).toEqual({ message: 'Zalogowano pomyślnie.' });

      // 4. Sprawdź czy token jest w cookies
      const cookies = response.headers['set-cookie'];
      expect(cookies).toBeDefined();
      expect(cookies.some((cookie) => cookie.includes('token'))).toBe(true);
    });

    it('Powinien zwrócić błąd 400 dla nieprawidłowych danych', async () => {
      const response = await request(app).post('/api/auth/login').send({
        email: 'wrong@example.com',
        password: 'wrongpassword',
      });

      expect(response.status).toBe(400);
      expect(response.body).toEqual({
        message: 'Nieprawidłowy email lub hasło.',
      });
    });

    it('Powinien zwrócić błąd 400 dla brakującego emaila', async () => {
      const response = await request(app).post('/api/auth/login').send({
        password: 'test123',
      });

      expect(response.status).toBe(400);
      expect(response.body).toHaveProperty('message');
    });
  });

  describe('POST /api/auth/register-pending', () => {
    it('Powinien zarejestrować użytkownika oczekującego', async () => {
      const response = await request(app)
        .post('/api/auth/register-pending')
        .send({
          username: 'newuser',
          email: 'new@example.com',
          password: 'password123',
          role: 'user',
        });

      expect(response.status).toBe(201);
      expect(response.body).toEqual({
        message: 'Wniosek o rejestrację został przesłany.',
      });

      // Sprawdź czy użytkownik jest w kolekcji pending
      const pendingUser = await PendingUser.findOne({
        email: 'new@example.com',
      });
      expect(pendingUser).not.toBeNull();
      expect(pendingUser.username).toBe('newuser');
    });

    it('Powinien zwrócić błąd 400 dla zajętego emaila', async () => {
      // Najpierw utwórz użytkownika
      await PendingUser.create({
        username: 'existing',
        email: 'existing@example.com',
        password: 'password123',
        role: 'user',
      });

      const response = await request(app)
        .post('/api/auth/register-pending')
        .send({
          username: 'newuser',
          email: 'existing@example.com', // Ten sam email
          password: 'password123',
          role: 'user',
        });

      expect(response.status).toBe(400);
      expect(response.body).toEqual({ message: 'Email jest już zajęty.' });
    });
  });

  describe('POST /api/auth/logout', () => {
    it('Powinien wylogować użytkownika i wyczyścić cookie', async () => {
      const response = await request(app).post('/api/auth/logout').send();

      expect(response.status).toBe(200);
      expect(response.body).toEqual({ message: 'Wylogowano.' });

      // Sprawdź czy cookie jest czyszczone
      const cookies = response.headers['set-cookie'];
      expect(cookies).toBeDefined();
      expect(cookies.some((cookie) => cookie.includes('token=;'))).toBe(true);
    });
  });
});


==================================
__tests__\integration\cache.test.js v.1
==================================

// __tests__/integration/cache.test.js
const request = require('supertest');
const { app, startServer, cleanupTestDatabase } = require('../../server');
const redisClient = require('../../utils/redisClient');

describe('Integracja: Cache Redis', () => {
  beforeAll(async () => {
    await startServer();
  });

  afterAll(async () => {
    await redisClient.disconnect();
    await cleanupTestDatabase();
  });

  it('Powinien cache\'ować odpowiedzi GET /api/articles', async () => {
    // Pierwsze request - cache MISS
    const response1 = await request(app).get('/api/articles');
    expect(response1.status).toBe(200);

    // Drugie request - cache HIT
    const response2 = await request(app).get('/api/articles');
    expect(response2.status).toBe(200);

    // Sprawdź nagłówki lub czas odpowiedzi
    // (w rzeczywistości cache jest transparentny dla klienta)
  });

  it('Nie powinien cache\'ować POST requests', async () => {
    const response = await request(app)
      .post('/api/articles')
      .set('Cookie', authToken) // potrzebny token
      .send({ title: 'Test', content: 'Content' });
    
    expect(response.status).toBe(201);
    // POST nie powinien być cache'owany
  });
});

==================================
__tests__\integration\comments.test.js v.2
==================================

const request = require('supertest');
const mongoose = require('mongoose');
const { app, startServer, cleanupTestDatabase } = require('../../server');
const Article = require('../../models/Article');
const Comment = require('../../models/Comment');
const User = require('../../models/User');
const bcrypt = require('bcryptjs');

describe('Integracja: Endpointy Komentarzy', () => {
  let authToken;
  let testUser;
  let testArticle;
  let testComment;

  beforeAll(async () => {
    await startServer();

    // Utwórz testowego użytkownika i zaloguj
    const hashedPassword = await bcrypt.hash('test123', 10);
    testUser = await User.create({
      email: 'commenter@example.com',
      password: hashedPassword,
      username: 'commenter',
      role: 'user',
    });

    // Login aby dostać token
    const loginResponse = await request(app).post('/api/auth/login').send({
      email: 'commenter@example.com',
      password: 'test123',
    });

    authToken = loginResponse.headers['set-cookie'][0];
  });

  beforeEach(async () => {
    // Utwórz testowy artykuł przed każdym testem
    testArticle = await Article.create({
      title: 'Test Article for Comments',
      content:
        'Content for comments test. This should be long enough for validation.',
      author: testUser._id,
      images: [],
    });

    // Utwórz testowy komentarz
    testComment = await Comment.create({
      text: 'Initial test comment for testing purposes',
      article: testArticle._id,
      author: testUser._id,
    });
  });

  afterEach(async () => {
    await Comment.deleteMany({});
    await Article.deleteMany({});
  });

  afterAll(async () => {
    await User.deleteMany({});
    await cleanupTestDatabase();
  });

  // 1. GET /api/comments/:id (articleId)
  describe('GET /api/comments/:id', () => {
    it('Powinien zwrócić listę komentarzy dla artykułu', async () => {
      const response = await request(app)
        .get(`/api/comments/${testArticle._id}`)
        .set('Cookie', authToken);

      expect(response.status).toBe(200);
      expect(Array.isArray(response.body)).toBe(true);
      expect(response.body.length).toBe(1);
      expect(response.body[0]).toHaveProperty(
        'text',
        'Initial test comment for testing purposes',
      );
    });

    it('Powinien zwrócić pustą listę gdy brak komentarzy', async () => {
      await Comment.deleteMany({});

      const response = await request(app)
        .get(`/api/comments/${testArticle._id}`)
        .set('Cookie', authToken);

      expect(response.status).toBe(200);
      expect(Array.isArray(response.body)).toBe(true);
      expect(response.body.length).toBe(0);
    });

    it('Powinien zwrócić pustą listę dla nieistniejącego artykułu', async () => {
      const fakeArticleId = new mongoose.Types.ObjectId();

      const response = await request(app)
        .get(`/api/comments/${fakeArticleId}`)
        .set('Cookie', authToken);

      expect(response.status).toBe(200);
      expect(Array.isArray(response.body)).toBe(true);
      expect(response.body.length).toBe(0); // Pusta tablica zamiast błędu 404
    });
  });

  // 2. POST /api/comments/:id (articleId)
  describe('POST /api/comments/:id', () => {
    it('Powinien dodać komentarz do artykułu', async () => {
      const newComment = {
        text: 'This is a new test comment with sufficient length',
      };

      const response = await request(app)
        .post(`/api/comments/${testArticle._id}`)
        .set('Cookie', authToken)
        .send(newComment);

      expect(response.status).toBe(201);
      expect(response.body).toHaveProperty('text', newComment.text);
      expect(response.body).toHaveProperty(
        'article',
        testArticle._id.toString(),
      );
      expect(response.body).toHaveProperty('author');

      // Sprawdź czy komentarz jest w bazie
      const comments = await Comment.find({ article: testArticle._id });
      expect(comments).toHaveLength(2);
    });

    it('Powinien zwrócić błąd 400 dla zbyt krótkiego komentarza', async () => {
      const shortComment = {
        text: 'Short', // 5 znaków < 6 wymaganych
      };

      const response = await request(app)
        .post(`/api/comments/${testArticle._id}`)
        .set('Cookie', authToken)
        .send(shortComment);

      expect(response.status).toBe(400);
      expect(response.body).toHaveProperty('message');
    });

    it('Powinien zwrócić błąd 404 dla nieistniejącego artykułu', async () => {
      const fakeArticleId = new mongoose.Types.ObjectId();
      const newComment = {
        text: 'Comment for non-existent article',
      };

      const response = await request(app)
        .post(`/api/comments/${fakeArticleId}`)
        .set('Cookie', authToken)
        .send(newComment);

      expect(response.status).toBe(404);
    });
  });

  // 3. PUT /api/comments/:id (commentId)
  describe('PUT /api/comments/:id', () => {
    it('Powinien zaktualizować komentarz', async () => {
      const updatedText = 'This is an updated comment with sufficient length';

      const response = await request(app)
        .put(`/api/comments/${testComment._id}`)
        .set('Cookie', authToken)
        .send({ text: updatedText });

      expect(response.status).toBe(200);
      expect(response.body).toHaveProperty('text', updatedText);

      // Sprawdź czy komentarz został zaktualizowany w bazie
      const updatedComment = await Comment.findById(testComment._id);
      expect(updatedComment.text).toBe(updatedText);
    });

    it('Powinien zwrócić błąd 403 przy próbie edycji cudzego komentarza', async () => {
      // Utwórz innego użytkownika
      const otherUser = await User.create({
        email: 'other@example.com',
        password: await bcrypt.hash('test123', 10),
        username: 'otheruser',
        role: 'user',
      });

      // Utwórz komentarz jako inny użytkownik
      const otherComment = await Comment.create({
        text: 'Other user comment',
        article: testArticle._id,
        author: otherUser._id,
      });

      const response = await request(app)
        .put(`/api/comments/${otherComment._id}`)
        .set('Cookie', authToken)
        .send({ text: 'Trying to edit someone else comment' });

      expect(response.status).toBe(403);
    });

    it('Powinien zwrócić błąd 404 dla nieistniejącego komentarza', async () => {
      const fakeCommentId = new mongoose.Types.ObjectId();

      const response = await request(app)
        .put(`/api/comments/${fakeCommentId}`)
        .set('Cookie', authToken)
        .send({ text: 'Trying to update non-existent comment' });

      expect(response.status).toBe(404);
    });
  });

  // 4. DELETE /api/comments/:id (commentId)
  describe('DELETE /api/comments/:id', () => {
    it('Powinien usunąć komentarz', async () => {
      const response = await request(app)
        .delete(`/api/comments/${testComment._id}`)
        .set('Cookie', authToken);

      expect(response.status).toBe(204);

      // Sprawdź czy komentarz został usunięty z bazy
      const deletedComment = await Comment.findById(testComment._id);
      expect(deletedComment).toBeNull();
    });

    it('Powinien zwrócić błąd 403 przy próbie usunięcia cudzego komentarza', async () => {
      // Utwórz innego użytkownika
      const otherUser = await User.create({
        email: 'other2@example.com',
        password: await bcrypt.hash('test123', 10),
        username: 'otheruser2',
        role: 'user',
      });

      // Utwórz komentarz jako inny użytkownik
      const otherComment = await Comment.create({
        text: 'Other user comment to delete',
        article: testArticle._id,
        author: otherUser._id,
      });

      const response = await request(app)
        .delete(`/api/comments/${otherComment._id}`)
        .set('Cookie', authToken);

      expect(response.status).toBe(403);
    });

    it('Powinien zwrócić błąd 404 dla nieistniejącego komentarza', async () => {
      const fakeCommentId = new mongoose.Types.ObjectId();

      const response = await request(app)
        .delete(`/api/comments/${fakeCommentId}`)
        .set('Cookie', authToken);

      expect(response.status).toBe(404);
    });
  });
});


==================================
__tests__\integration\csp.test.js v.1
==================================

// __tests__/integration/csp.test.js
const request = require('supertest');
const { app, startServer, cleanupTestDatabase } = require('../../server');

describe('Integracja: Content Security Policy', () => {
  beforeAll(async () => {
    await startServer();
  });

  afterAll(async () => {
    await cleanupTestDatabase();
  });

  it('Powinien zwracać nagłówki Content-Security-Policy', async () => {
    const response = await request(app).get('/api/articles');

    expect(response.status).toBe(200);
    expect(response.headers).toHaveProperty('content-security-policy');
    
    const cspHeader = response.headers['content-security-policy'];
    expect(cspHeader).toBeDefined();
    expect(cspHeader).toContain("default-src 'self'");
  });

  it('Powinien pozwalać na obrazy z data URI', async () => {
    const response = await request(app).get('/api/articles');
    
    const cspHeader = response.headers['content-security-policy'];
    expect(cspHeader).toContain("img-src 'self' data:");
  });

  it('Powinien blokować obiekty embedded', async () => {
    const response = await request(app).get('/api/articles');
    
    const cspHeader = response.headers['content-security-policy'];
    expect(cspHeader).toContain("object-src 'none'");
  });
});

==================================
__tests__\integration\performance.test.js v.1
==================================

// __tests__/integration/performance.test.js
const { app, startServer } = require('../../server');

describe('Wydajność: Testy optymalizacji', () => {
  beforeAll(async () => {
    await startServer();
  });

  it('GET /api/articles powinien być szybki (<100ms)', async () => {
    const start = Date.now();
    const response = await request(app).get('/api/articles');
    const duration = Date.now() - start;
    
    expect(response.status).toBe(200);
    expect(duration).toBeLessThan(100); // ✅ Szybko!
  });

  it('GET /api/articles?search=test powinien używać full-text index', async () => {
    const response = await request(app).get('/api/articles?search=test');
    expect(response.status).toBe(200);
    // Sprawdź w logach czy używa $text index
  });
});

==================================
__tests__\integration\rateLimit.test.js v.1
==================================

const request = require('supertest');
const { app, startServer, cleanupTestDatabase } = require('../../server');
const User = require('../../models/User');
const bcrypt = require('bcryptjs');

describe('Integracja: Rate Limiting', () => {
  let authToken;

  beforeAll(async () => {
    await startServer();

    // Utwórz testowego użytkownika
    const hashedPassword = await bcrypt.hash('test123', 10);
    await User.create({
      email: 'ratelimit@example.com',
      password: hashedPassword,
      username: 'ratelimituser',
      role: 'user',
    });

    // Zaloguj się aby dostać token
    const loginResponse = await request(app).post('/api/auth/login').send({
      email: 'ratelimit@example.com',
      password: 'test123',
    });
    authToken = loginResponse.headers['set-cookie'][0];
  });

  afterAll(async () => {
    await User.deleteMany({});
    await cleanupTestDatabase();
  });

  describe('Global Rate Limiting', () => {
    it('Powinien pozwolić na normalną liczbę żądań', async () => {
      const requests = [];
      for (let i = 0; i < 100; i++) {
        requests.push(
          request(app).get('/api/articles').set('Cookie', authToken),
        );
      }

      const responses = await Promise.all(requests);
      const successResponses = responses.filter((r) => r.status === 200);

      expect(successResponses.length).toBe(100);
    }, 30000);

    it('Powinien blokować przy zbyt wielu żądaniach z tego samego IP', async () => {
      const requests = [];
      for (let i = 0; i < 1001; i++) {
        requests.push(request(app).get('/api/articles'));
      }

      const responses = await Promise.all(requests);
      const blockedResponses = responses.filter((r) => r.status === 429);

      expect(blockedResponses.length).toBeGreaterThan(0);
      expect(blockedResponses[0].body.message).toContain('Zbyt wiele żądań');
    }, 30000);
  });

  describe('Auth Rate Limiting', () => {
    it('Powinien blokować przy zbyt wielu próbach logowania', async () => {
      const requests = [];
      // Użyj UNIKALNYCH adresów IP dla każdego żądania (omijają globalny limiter)
      for (let i = 0; i < 51; i++) {
        requests.push(
          request(app)
            .post('/api/auth/login')
            .set('X-Forwarded-For', `192.168.1.${i}`) // 🎯 RÓŻNE IP
            .send({
              email: `test${i}@example.com`,
              password: 'wrongpassword',
            }),
        );
      }

      const responses = await Promise.all(requests);
      const blockedResponses = responses.filter((r) => r.status === 429);

      expect(blockedResponses.length).toBeGreaterThan(0);
    }, 30000);
  });

  describe('Admin Rate Limiting', () => {
    it('Powinien blokować przy zbyt wielu żądaniach do admin endpointów', async () => {
      // 🎯 UTWÓRZ admina PRZED testami (bez logowania przez API)
      const adminPassword = await bcrypt.hash('admin123', 10);
      await User.create({
        email: 'adminlimit@example.com',
        password: adminPassword,
        username: 'adminlimit',
        role: 'admin',
      });

      // 🎯 SYMULOWANY token admina (omijamy rate limiting logowania)
      const adminToken =
        'token=simulated_admin_token; Path=/; HttpOnly; SameSite=Lax';

      const requests = [];
      for (let i = 0; i < 201; i++) {
        requests.push(
          request(app)
            .get('/api/admin/pending-users')
            .set('Cookie', adminToken),
        );
      }

      const responses = await Promise.all(requests);
      const blockedResponses = responses.filter((r) => r.status === 429);

      // Powinno być przynajmniej 1 zablokowane żądanie (201 > limit 200)
      expect(blockedResponses.length).toBeGreaterThan(0);
    }, 30000);
  });

  describe('Rate Limit Headers', () => {
    it('Powinien zwracać nagłówki RateLimit', async () => {
      const response = await request(app)
        .get('/api/articles')
        .set('Cookie', authToken);

      expect(response.headers).toHaveProperty('ratelimit-limit');
      expect(response.headers).toHaveProperty('ratelimit-remaining');
      expect(response.headers).toHaveProperty('ratelimit-reset');
    });
  });
});


==================================
__tests__\integration\sanitization.test.js v.3
==================================

// __tests__/integration/sanitization.test.js
const request = require('supertest');
const { app, startServer, cleanupTestDatabase } = require('../../server');
const User = require('../../models/User');
const Article = require('../../models/Article');
const bcrypt = require('bcryptjs');

describe('Integracja: Testy Sanitization i Bezpieczeństwa', () => {
  let authToken;
  let testUser;
  let testArticle;

  beforeAll(async () => {
    await startServer();

    // Utwórz testowego użytkownika
    const hashedPassword = await bcrypt.hash('test123', 10);
    testUser = await User.create({
      email: 'security@example.com',
      password: hashedPassword,
      username: 'securityuser',
      role: 'author',
    });

    // Utwórz testowy artykuł
    testArticle = await Article.create({
      title: 'Test Security Article',
      content: 'Content for security testing',
      author: testUser._id,
      images: [],
    });

    // Login aby dostać token
    const loginResponse = await request(app).post('/api/auth/login').send({
      email: 'security@example.com',
      password: 'test123',
    });
    authToken = loginResponse.headers['set-cookie'][0];
  });

  afterAll(async () => {
    await User.deleteMany({});
    await Article.deleteMany({});
    await cleanupTestDatabase();
  });

  describe('XSS Injection Tests', () => {
    it('Powinien OCZYŚCIĆ XSS w tytule artykułu (usuń wszystkie tagi)', async () => {
      const response = await request(app)
        .post('/api/articles')
        .set('Cookie', authToken)
        .field('title', '<script>alert("xss")</script>Test Title')
        .field(
          'content',
          'Normalna treść artykułu która jest wystarczająco długa.',
        )
        .attach('images', Buffer.from('test'), 'test.jpg');

      expect(response.status).toBe(201);
      expect(response.body.article.title).toBe('Test Title'); // TYLKO czysty tekst
      expect(response.body.article.title).not.toContain('<script>');
      expect(response.body.article.title).not.toContain('alert');
    });

    it('Powinien OCZYŚCIĆ XSS w komentarzach (usuń niebezpieczne, zachowaj bezpieczne)', async () => {
      const response = await request(app)
        .post(`/api/comments/${testArticle._id}`)
        .set('Cookie', authToken)
        .send({
          text: 'Safe <b>bold</b> but <img src="x" onerror="alert(1)"> dangerous <script>alert(2)</script> and <a href="https://example.com">link</a>',
        });

      expect(response.status).toBe(201);
      // POWINNO ZACHOWAĆ bezpieczne formatowanie
      expect(response.body.text).toContain('<b>bold</b>');
      expect(response.body.text).toContain('<a href="https://example.com"');
      // POWINNO USUNĄĆ niebezpieczne tagi
      expect(response.body.text).not.toContain('<img');
      expect(response.body.text).not.toContain('<script>');
      expect(response.body.text).not.toContain('onerror');
      // POWINNO ZACHOWAĆ tekst
      expect(response.body.text).toContain('Safe');
      expect(response.body.text).toContain('bold');
      expect(response.body.text).toContain('dangerous');
      expect(response.body.text).toContain('link');
    });

    it('Powinien OCZYŚCIĆ XSS w update profilu (usuń wszystkie tagi)', async () => {
      const response = await request(app)
        .put('/api/users/profile')
        .set('Cookie', authToken)
        .send({ username: '<script>alert("xss")</script>Hacker' });

      expect(response.status).toBe(200);
      expect(response.body.user.username).toBe('Hacker'); // TYLKO czysty tekst
      expect(response.body.user.username).not.toContain('<script>');
    });
  });

  describe('SQL Injection Tests', () => {
    it('Powinien bezpiecznie obsłużyć SQL injection w wyszukiwaniu', async () => {
      const response = await request(app)
        .get('/api/articles?q=test%27; DROP TABLE users;--')
        .set('Cookie', authToken);

      expect(response.status).toBe(200);
      expect(response.body).toHaveProperty('articles');
      expect(Array.isArray(response.body.articles)).toBe(true);
    });

    it('Powinien bezpiecznie obsłużyć SQL injection w parametrach', async () => {
      const maliciousId = "'; DROP TABLE users; --";
      const response = await request(app)
        .get(`/api/articles/${maliciousId}`)
        .set('Cookie', authToken);

      expect([400, 404]).toContain(response.status);
    });
  });

  describe('HTML Injection Tests', () => {
    it('Powinien OCZYŚCIĆ HTML w polach tekstowych komentarzy', async () => {
      const cleanText = 'Normalny tekst <b>pogrubiony</b> ale bezpieczny';

      const response = await request(app)
        .post(`/api/comments/${testArticle._id}`)
        .set('Cookie', authToken)
        .send({ text: cleanText });

      expect(response.status).toBe(201);
      // Bezpieczne tagi powinny pozostać
      expect(response.body.text).toContain('<b>pogrubiony</b>');
      expect(response.body.text).not.toContain('<script>');
    });
  });

  describe('Specific Sanitization Behaviors', () => {
    it('Powinien zachować podstawowe formatowanie w komentarzach', async () => {
      const response = await request(app)
        .post(`/api/comments/${testArticle._id}`)
        .set('Cookie', authToken)
        .send({
          text: 'Text with <b>bold</b>, <i>italic</i> and <a href="https://example.com">link</a> but no <script>alert(1)</script>',
        });

      expect(response.status).toBe(201);
      // Bezpieczne tagi powinny pozostać
      expect(response.body.text).toContain('<b>bold</b>');
      expect(response.body.text).toContain('<i>italic</i>');
      expect(response.body.text).toContain('<a href="https://example.com"');
      // Niebezpieczne tagi powinny być usunięte
      expect(response.body.text).not.toContain('<script>');
    });

    it('Powinien całkowicie usuwać HTML w tytułach', async () => {
      const response = await request(app)
        .post('/api/articles')
        .set('Cookie', authToken)
        .field('title', 'Title with <script>alert(1)</script> and <b>bold</b>')
        .field('content', 'Normal content here...')
        .attach('images', Buffer.from('test'), 'test.jpg');

      expect(response.status).toBe(201);
      // WSZYSTKIE tagi powinny być usunięte - nawet bezpieczne
      // Po usunięciu tagów pozostaje podwójna spacja, co jest poprawne
      expect(response.body.article.title).toBe('Title with  and bold');
      expect(response.body.article.title).not.toContain('<script>');
      expect(response.body.article.title).not.toContain('<b>');
    });

    it('Powinien pozwalać na bogate formatowanie w treści artykułów', async () => {
      const response = await request(app)
        .post('/api/articles')
        .set('Cookie', authToken)
        .field('title', 'Normal title')
        .field(
          'content',
          'Text with <b>bold</b>, <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8z8BQDwAEhQGAhKmMIQAAAABJRU5ErkJggg==" alt="test"> and <script>alert(1)</script>',
        )
        .attach('images', Buffer.from('test'), 'test.jpg');

      expect(response.status).toBe(201);
      // Bezpieczne tagi powinny pozostać
      expect(response.body.article.content).toContain('<b>bold</b>');
      // Obrazki mogą być usuwane w treści artykułów - to jest poprawne zachowanie
      expect(response.body.article.content).not.toContain('<script>');
    });
  });
});


==================================
__tests__\integration\users.test.js v.2
==================================

const request = require('supertest');
const { app, startServer, cleanupTestDatabase } = require('../../server');
const User = require('../../models/User');
const bcrypt = require('bcryptjs');

describe('Integracja: Endpointy Użytkowników', () => {
  let authToken;
  let testUser;

  beforeAll(async () => {
    await startServer();

    // Utwórz testowego użytkownika i zaloguj
    const hashedPassword = await bcrypt.hash('test123', 10);
    testUser = await User.create({
      email: 'testuser@example.com',
      password: hashedPassword,
      username: 'testuser',
      role: 'user',
    });

    // Login aby dostać token
    const loginResponse = await request(app).post('/api/auth/login').send({
      email: 'testuser@example.com',
      password: 'test123',
    });

    authToken = loginResponse.headers['set-cookie'][0];
  });

  afterAll(async () => {
    await User.deleteMany({});
    await cleanupTestDatabase();
  });

  // 1. GET /api/users/profile
  describe('GET /api/users/profile', () => {
    it('Powinien zwrócić profil zalogowanego użytkownika', async () => {
      const response = await request(app)
        .get('/api/users/profile')
        .set('Cookie', authToken);

      expect(response.status).toBe(200);
      expect(response.body).toHaveProperty('_id', testUser._id.toString());
      expect(response.body).toHaveProperty('email', 'testuser@example.com');
      expect(response.body).toHaveProperty('username', 'testuser');
      expect(response.body).toHaveProperty('role', 'user');
      expect(response.body).not.toHaveProperty('password'); // Hasło nie powinno być zwracane
    });

    it('Powinien zwrócić błąd 401 gdy brak autoryzacji', async () => {
      const response = await request(app).get('/api/users/profile');

      expect(response.status).toBe(401);
    });
  });

  // 2. PUT /api/users/profile
  describe('PUT /api/users/profile', () => {
    it('Powinien zaktualizować nazwę użytkownika', async () => {
      const updatedData = {
        username: 'updatedusername',
      };

      const response = await request(app)
        .put('/api/users/profile')
        .set('Cookie', authToken)
        .send(updatedData);

      expect(response.status).toBe(200);
      expect(response.body).toHaveProperty('message', 'Profil zaktualizowany');
      expect(response.body.user).toHaveProperty('username', 'updatedusername');
      expect(response.body.user).toHaveProperty(
        'email',
        'testuser@example.com',
      ); // Email nie powinien się zmienić

      // Sprawdź czy dane zostały zaktualizowane w bazie
      const updatedUser = await User.findById(testUser._id);
      expect(updatedUser.username).toBe('updatedusername');
    });

    it('Powinien zwrócić błąd 400 dla zbyt krótkiej nazwy użytkownika', async () => {
      const invalidData = {
        username: 'ab', // 2 znaki < 3 wymagane
      };

      const response = await request(app)
        .put('/api/users/profile')
        .set('Cookie', authToken)
        .send(invalidData);

      expect(response.status).toBe(400);
    });

    it('Powinien zwrócić błąd 401 gdy brak autoryzacji', async () => {
      const response = await request(app)
        .put('/api/users/profile')
        .send({ username: 'test' });

      expect(response.status).toBe(401);
    });
  });

  // 3. PUT /api/users/password
  describe('PUT /api/users/password', () => {
    it('Powinien zmienić hasło użytkownika', async () => {
      const passwordData = {
        oldPassword: 'test123',
        newPassword: 'newpassword123',
      };

      const response = await request(app)
        .put('/api/users/password')
        .set('Cookie', authToken)
        .send(passwordData);

      expect(response.status).toBe(200);
      expect(response.body).toHaveProperty(
        'message',
        'Hasło zostało zmienione.',
      );

      // Sprawdź czy można zalogować się nowym hasłem
      const loginResponse = await request(app).post('/api/auth/login').send({
        email: 'testuser@example.com',
        password: 'newpassword123',
      });

      expect(loginResponse.status).toBe(200);
    });

    it('Powinien zwrócić błąd 400 dla nieprawidłowego starego hasła', async () => {
      const passwordData = {
        oldPassword: 'wrongpassword',
        newPassword: 'newpassword123',
      };

      const response = await request(app)
        .put('/api/users/password')
        .set('Cookie', authToken)
        .send(passwordData);

      expect(response.status).toBe(400);
    });

    it('Powinien zwrócić błąd 400 dla zbyt krótkiego nowego hasła', async () => {
      const passwordData = {
        oldPassword: 'test123',
        newPassword: 'short', // 5 znaków < 6 wymagane
      };

      const response = await request(app)
        .put('/api/users/password')
        .set('Cookie', authToken)
        .send(passwordData);

      expect(response.status).toBe(400);
    });

    it('Powinien zwrócić błąd 401 gdy brak autoryzacji', async () => {
      const response = await request(app).put('/api/users/password').send({
        oldPassword: 'test123',
        newPassword: 'newpassword123',
      });

      expect(response.status).toBe(401);
    });
  });

  // Testy dla admin endpoints (będą w admin.test.js)
  describe('Endpointy administracyjne (będą testowane osobno)', () => {
    it('Tymczasowy test - do usunięcia', () => {
      expect(true).toBe(true);
    });
  });
});


==================================
__tests__\services\articleService.createArticle.test.js v.1
==================================

 
// Test files often need unused variables for mocks

// __tests__/services/articleService.createArticle.test.js
const articleService = require('../../services/articleService');
const Article = require('../../models/Article');
jest.mock('../../models/Article');

describe('Serwis: articleService - funkcja createArticle', () => {
  const mockTitle = 'Testowy tytuł artykułu';
  const mockContent = 'To jest treść testowego artykułu, która jest wystarczająco długa, aby spełnić wymagania.';
  const mockAuthorId = '507f1f77bcf86cd799439011';
  const mockImagePaths = ['uploads/image1.jpg', 'uploads/image2.png'];

  let mockArticleInstance;

  beforeEach(() => {
    jest.clearAllMocks();
    // 1. Tworzymy obiekt-impostor. Symuluje instancję Mongoose, która ma metodę `.save`.
    mockArticleInstance = {
      save: jest.fn(), // Mockujemy metodę save
    };
    // 2. Gdy konstruktor "Article" jest wywoływany, zwracamy naszego impostora.
    Article.mockImplementation(() => mockArticleInstance);
  });

  it('Powinien pomyślnie utworzyć artykuł z poprawnymi danymi', async () => {
    // ARRANGE
    const mockSavedArticleData = {
      _id: 'someArticleId',
      title: mockTitle,
      content: mockContent,
      author: mockAuthorId,
      images: mockImagePaths,
    };
    mockArticleInstance.save.mockResolvedValue(mockSavedArticleData);

    // ACT
    const result = await articleService.createArticle(mockTitle, mockContent, mockAuthorId, mockImagePaths);

    // ASSERT
    expect(Article).toHaveBeenCalledWith({
      title: mockTitle,
      content: mockContent,
      author: mockAuthorId,
      images: mockImagePaths,
    });
    expect(mockArticleInstance.save).toHaveBeenCalled();
    expect(result).toBe(mockArticleInstance);
  });

  it('Powinien rzucić błąd jeśli tytuł jest za krótki', async () => {
    // ARRANGE
    const shortTitle = 'A';

    // ACT & ASSERT
    await expect(articleService.createArticle(shortTitle, mockContent, mockAuthorId, mockImagePaths))
      .rejects
      .toThrow('Tytuł musi mieć co najmniej 5 znaków');
        
    // Sprawdzamy, czy save NIE został wywołany
    expect(mockArticleInstance.save).not.toHaveBeenCalled();
  });

  it('Powinien rzucić błąd jeśli treść jest za krótka', async () => {
    // ARRANGE
    const shortContent = 'Krótka';

    // ACT & ASSERT
    await expect(articleService.createArticle(mockTitle, shortContent, mockAuthorId, mockImagePaths))
      .rejects
      .toThrow('Treść musi mieć co najmniej 20 znaków');
        
    expect(mockArticleInstance.save).not.toHaveBeenCalled();
  });

  it('Powinien rzucić błąd jeśli brakuje tytułu lub treści', async () => {
    // ACT & ASSERT - brak tytułu
    await expect(articleService.createArticle('', mockContent, mockAuthorId, mockImagePaths))
      .rejects
      .toThrow(); // Może rzucić ogólny błąd walidacji

    // ACT & ASSERT - brak treści
    await expect(articleService.createArticle(mockTitle, '', mockAuthorId, mockImagePaths))
      .rejects
      .toThrow();

    expect(mockArticleInstance.save).not.toHaveBeenCalled();
  });
});

==================================
__tests__\services\articleService.getArticles.test.js v.1
==================================

// __tests__/services/articleService.getArticles.test.js
const articleService = require('../../services/articleService');
const Article = require('../../models/Article');
const Comment = require('../../models/Comment');

jest.mock('../../models/Article');
jest.mock('../../models/Comment');

describe('Serwis: articleService - funkcja getArticles', () => {
  const mockArticlesData = [
    { 
      _id: 'article1', 
      title: 'Test Article 1', 
      author: { email: 'user1@test.com' }, 
      content: 'Content 1', 
      images: [], 
      likes: [],
      createdAt: new Date('2023-01-01'),
    },
    { 
      _id: 'article2', 
      title: 'Test Article 2', 
      author: { email: 'user2@test.com' }, 
      content: 'Content 2', 
      images: [], 
      likes: ['user1'],
      createdAt: new Date('2023-01-02'),
    },
  ];

  const mockCommentCounts = { article1: 3, article2: 5 };

  // Helper function to create a chainable mock
  const createChainableMock = (finalValue) => {
    const mock = jest.fn().mockReturnThis();
    mock.sort = jest.fn().mockReturnThis();
    mock.skip = jest.fn().mockReturnThis();
    mock.limit = jest.fn().mockReturnThis();
    mock.populate = jest.fn().mockResolvedValue(finalValue);
    return mock;
  };

  beforeEach(() => {
    jest.clearAllMocks();
        
    // Mockujemy Comment.countDocuments dla każdego artykułu
    Comment.countDocuments.mockImplementation((query) => {
      const articleId = query.article.toString();
      return Promise.resolve(mockCommentCounts[articleId] || 0);
    });

    // Resetujemy wszystkie mocks Article
    Article.countDocuments.mockReset();
    Article.find.mockReset();
    Article.aggregate.mockReset();
  });

  it('Powinien zwrócić listę artykułów z paginacją (sort: newest)', async () => {
    // ARRANGE
    const page = 1, limit = 2, search = '', sort = 'newest';
    const totalCount = 2;

    // Mock standardowego find z łańcuchem metod
    Article.countDocuments.mockResolvedValue(totalCount);
    Article.find.mockImplementation(() => createChainableMock(mockArticlesData));

    // ACT
    const result = await articleService.getArticles(page, limit, search, sort);

    // ASSERT
    expect(Article.countDocuments).toHaveBeenCalled();
    expect(Article.find).toHaveBeenCalled();
    expect(result).toEqual({
      articles: [
        { 
          _id: 'article1', 
          title: 'Test Article 1', 
          content: 'Content 1',
          likesCount: 0,
          commentCount: 3,
          author: { email: 'user1@test.com' },
          thumbnail: null,
          createdAt: new Date('2023-01-01'),
        },
        { 
          _id: 'article2', 
          title: 'Test Article 2', 
          content: 'Content 2',
          likesCount: 1,
          commentCount: 5,
          author: { email: 'user2@test.com' },
          thumbnail: null,
          createdAt: new Date('2023-01-02'),
        },
      ],
      total: totalCount,
    });
  });

  it('Powinien zwrócić listę artykułów (sort: mostLiked - agregacja)', async () => {
    // ARRANGE
    const page = 1, limit = 2, search = '', sort = 'mostLiked';
    const totalCount = 2;

    // Mock agregacji MongoDB - ZWRACA TABLICĘ
    const mockAggregateResult = [
      { 
        _id: 'article1', 
        title: 'Test Article 1', 
        content: 'Content 1',
        author: { email: 'user1@test.com' },
        images: [],
        likes: [],
        likesCount: 0,
        createdAt: new Date('2023-01-01'),
      },
      { 
        _id: 'article2', 
        title: 'Test Article 2', 
        content: 'Content 2', 
        author: { email: 'user2@test.com' },
        images: [],
        likes: ['user1'],
        likesCount: 1,
        createdAt: new Date('2023-01-02'),
      },
    ];
        
    // POPRAWNY MOCK: aggregate() zwraca obiekt z metodą exec()
    Article.aggregate.mockResolvedValue(mockAggregateResult);
    Article.countDocuments.mockResolvedValue(totalCount);

    // ACT
    const result = await articleService.getArticles(page, limit, search, sort);

    // ASSERT
    expect(Article.aggregate).toHaveBeenCalled();
    expect(result.total).toBe(totalCount);
    expect(Array.isArray(result.articles)).toBe(true);
    expect(result.articles).toHaveLength(2);
    expect(result.articles[0]).toHaveProperty('commentCount');
    expect(result.articles[0]).toHaveProperty('likesCount');
    expect(result.articles[0].likesCount).toBe(0);
  });

  it('Powinien przefiltrować artykuły wyszukiwaniem (search)', async () => {
    // ARRANGE
    const page = 1, limit = 2, search = 'Test', sort = 'newest';
    const filteredArticles = [mockArticlesData[0]];
    const totalCount = 1;

    Article.countDocuments.mockResolvedValue(totalCount);
    Article.find.mockImplementation(() => createChainableMock(filteredArticles));

    // ACT
    const result = await articleService.getArticles(page, limit, search, sort);

    // ASSERT
    expect(Article.find).toHaveBeenCalledWith({
      $or: [
        { title: { $regex: 'Test', $options: 'i' } },
        { content: { $regex: 'Test', $options: 'i' } },
      ],
    });
    expect(result.total).toBe(totalCount);
    expect(result.articles).toHaveLength(1);
  });

  it('Powinien obsłużyć pustą listę artykułów', async () => {
    // ARRANGE
    const page = 1, limit = 2, search = '', sort = 'newest';
    const totalCount = 0;

    Article.countDocuments.mockResolvedValue(totalCount);
    Article.find.mockImplementation(() => createChainableMock([]));

    // ACT
    const result = await articleService.getArticles(page, limit, search, sort);

    // ASSERT
    expect(result.articles).toEqual([]);
    expect(result.total).toBe(0);
  });
});

==================================
__tests__\services\articleService.toggleLikeArticle.test.js v.1
==================================

// __tests__/services/articleService.toggleLikeArticle.test.js
const articleService = require('../../services/articleService');
const Article = require('../../models/Article');

jest.mock('../../models/Article');

describe('Serwis: articleService - funkcja toggleLikeArticle', () => {
  const mockArticleId = '507f1f77bcf86cd799439022'; // ObjectId artykułu
  const mockUserId = '507f1f77bcf86cd799439011';    // ObjectId użytkownika
  const mockAuthorId = '507f1f77bcf86cd799439033';  // ObjectId autora (inny niż userId)

  let mockArticleInstance;

  beforeEach(() => {
    jest.clearAllMocks();
        
    // 1. Tworzymy podstawową instancję artykułu
    mockArticleInstance = {
      _id: mockArticleId,
      author: mockAuthorId,
      likes: [], // Początkowo pusta tablica lików
      save: jest.fn().mockImplementation(function() { 
        // Symulujemy, że save zwraca "zapisany" obiekt (this)
        return Promise.resolve(this);
      }),
    };

    // 2. --- KLUCZOWA ZMIANA ---
    // Symulujemy, że `likes` jest tablicą Mongoose z metodą `pull`
    mockArticleInstance.likes = []; // Resetujemy tablicę
    // Dodajemy metodę `pull` do tej tablicy
    mockArticleInstance.likes.pull = jest.fn((userIdToRemove) => {
      // Implementacja pull: usuwa userId z tablicy likes
      const index = mockArticleInstance.likes.indexOf(userIdToRemove);
      if (index > -1) {
        mockArticleInstance.likes.splice(index, 1);
      }
    });
    // --- KONIEC ZMIANY ---

    // Mockujemy Article.findById aby zwracał naszą instancję
    Article.findById.mockResolvedValue(mockArticleInstance);
  });

  it('Powinien dodać like, jeśli użytkownik jeszcze nie polubił artykułu', async () => {
    // ARRANGE
    // Początkowy stan: likes = [] (użytkownik nie polubił)
    mockArticleInstance.likes = [];

    // ACT
    const result = await articleService.toggleLikeArticle(mockArticleId, mockUserId);

    // ASSERT
    // 1. Sprawdzamy, czy znaleziono artykuł
    expect(Article.findById).toHaveBeenCalledWith(mockArticleId);
    // 2. Sprawdzamy, czy save został wywołany
    expect(mockArticleInstance.save).toHaveBeenCalled();
    // 3. Sprawdzamy, czy like został dodany do tablicy (za pomocą push)
    expect(mockArticleInstance.likes).toContain(mockUserId);
    // 4. Sprawdzamy, czy wynik wskazuje na dodanie like i poprawną liczbę
    expect(result).toEqual({
      liked: true,
      totalLikes: 1, // Dodano 1 like
    });
  });

  it('Powinien usunąć like, jeśli użytkownik już polubił artykuł', async () => {
    // ARRANGE
    // Początkowy stan: użytkownik już polubił artykuł
    // NIE NADPISUJEMY tablicy, tylko MODYFIKUJEMY istniejącą
    mockArticleInstance.likes.push(mockUserId); // <- Dodajemy userId do istniejącej tablicy

    // ACT
    const result = await articleService.toggleLikeArticle(mockArticleId, mockUserId);

    // ASSERT
    expect(Article.findById).toHaveBeenCalledWith(mockArticleId);
    expect(mockArticleInstance.save).toHaveBeenCalled();
    // Like powinien zostać usunięty z tablicy (za pomocą pull)
    expect(mockArticleInstance.likes).not.toContain(mockUserId);
    // Sprawdzamy, czy metoda pull została wywołana z prawidłowym argumentem
    expect(mockArticleInstance.likes.pull).toHaveBeenCalledWith(mockUserId);
    expect(result).toEqual({
      liked: false,
      totalLikes: 0, // Usunięto 1 like
    });
  });

  it('Powinien rzucić błąd, jeśli artykuł nie istnieje', async () => {
    // ARRANGE
    Article.findById.mockResolvedValue(null); // Artykuł nie znaleziony

    // ACT & ASSERT
    await expect(articleService.toggleLikeArticle(mockArticleId, mockUserId))
      .rejects
      .toThrow('Artykuł nie znaleziony');
  });

  it('Powinien rzucić błąd, jeśli autor próbuje polubić własny artykuł', async () => {
    // ARRANGE
    // Symulujemy, że autor próbuje polubić własny artykuł
    mockArticleInstance.author = mockUserId; // Autor == userId

    // ACT & ASSERT
    await expect(articleService.toggleLikeArticle(mockArticleId, mockUserId))
      .rejects
      .toThrow('Autor nie może polubić własnego artykułu');
        
    // Save nie powinien zostać wywołany
    expect(mockArticleInstance.save).not.toHaveBeenCalled();
  });
});

==================================
__tests__\services\authService.register.pending.test.js v.1
==================================

// __tests__/services/authService.registerPending.test.js
const authService = require('../../services/authService');
const PendingUser = require('../../models/PendingUser');
const User = require('../../models/User');

// Mockujemy modele Mongoose
jest.mock('../../models/PendingUser');
jest.mock('../../models/User');

describe('Serwis: authService - funkcja registerPending', () => {
  // Dane testowe
  const mockUserData = {
    username: 'testuser',
    email: 'test@example.com',
    password: 'testpass123',
    role: 'user',
  };

  beforeEach(() => {
    jest.clearAllMocks(); // Czyścimy mocki przed każdym testem
  });

  it('Powinien pomyślnie zarejestrować użytkownika oczekującego', async () => {
    // ARRANGE
    // 1. Mockujemy, że NIE ma użytkownika w żadnej z kolekcji
    User.findOne.mockResolvedValue(null);
    PendingUser.findOne.mockResolvedValue(null);
    // 2. Mockujemy metodę `save` na nowej instancji PendingUser
    const mockSave = jest.fn().mockResolvedValue(true);
    PendingUser.mockImplementation(() => ({
      save: mockSave,
    }));

    // ACT
    // Wywołujemy funkcję - nie powinna rzucić błędem
    await expect(authService.registerPending(
      mockUserData.username,
      mockUserData.email,
      mockUserData.password,
      mockUserData.role,
    )).resolves.not.toThrow(); // Sprawdzamy, że Promise się resolves (nie rejectuje)

    // ASSERT
    // Sprawdzamy, czy findOne był wywołany z poprawnym emailem
    expect(PendingUser.findOne).toHaveBeenCalledWith({ email: mockUserData.email });
    expect(User.findOne).toHaveBeenCalledWith({ email: mockUserData.email });
    // Sprawdzamy, czy konstruktor PendingUser został wywołany z prawidłowymi danymi
    expect(PendingUser).toHaveBeenCalledWith({
      username: mockUserData.username,
      email: mockUserData.email,
      password: mockUserData.password, // jeszcze nie zahashowane!
      role: mockUserData.role,
    });
    // Sprawdzamy, czy save został wywołany na nowym obiekcie
    expect(mockSave).toHaveBeenCalled();
  });

  it('Powinien rzucić błąd jeśli użytkownik (Pending) już istnieje', async () => {
    // ARRANGE
    // Symulujemy, że użytkownik OCZEKUJĄCY już istnieje
    PendingUser.findOne.mockResolvedValue({ email: mockUserData.email });

    // ACT & ASSERT
    // Spodziewamy się, że funkcja rzuci konkretnym błędem
    await expect(authService.registerPending(
      mockUserData.username,
      mockUserData.email,
      mockUserData.password,
      mockUserData.role,
    )).rejects.toThrow('Email jest już zajęty.');
    
    // Optional: Sprawdzamy, czy findOne dla User NIE został wywołany (optymalizacja)
    // expect(User.findOne).not.toHaveBeenCalled();
  });

  it('Powinien rzucić błąd jeśli użytkownik (User) już istnieje', async () => {
    // ARRANGE
    // Symulujemy, że użytkownik ZATWIERDZONY już istnieje
    PendingUser.findOne.mockResolvedValue(null);
    User.findOne.mockResolvedValue({ email: mockUserData.email });

    // ACT & ASSERT
    await expect(authService.registerPending(
      mockUserData.username,
      mockUserData.email,
      mockUserData.password,
      mockUserData.role,
    )).rejects.toThrow('Email jest już zajęty.');
  });

  // Możesz też dodać test dla walidacji (np. brak username)
  it('Powinien rzucić błąd walidacji jeśli brakuje wymaganego pola', async () => {
    // ACT & ASSERT - pomijamy username
    await expect(authService.registerPending(
      '', // puste username
      mockUserData.email,
      mockUserData.password,
      mockUserData.role,
    )).rejects.toThrow('Nazwa użytkownika jest wymagana.');
  });
});

==================================
__tests__\services\authService.test.js v.1
==================================

// __tests__/services/authService.test.js
const authService = require('../../services/authService');
const User = require('../../models/User');
const bcrypt = require('bcryptjs');

jest.mock('../../models/User');
jest.mock('bcryptjs');

describe('Serwis: authService - funkcja login', () => {
  const mockEmail = 'test@example.com';
  const mockPassword = 'haslo123';
  const mockWrongPassword = 'zlehaslo';
  const mockUserId = '507f1f77bcf86cd799439011';

  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('Powinien rzucić błąd "Nieprawidłowy email lub hasło" jeśli użytkownik nie istnieje', async () => {
    User.findOne.mockResolvedValue(null);
    
    await expect(authService.login(mockEmail, mockPassword))
      .rejects
      .toThrow('Nieprawidłowy email lub hasło.');
    
    expect(User.findOne).toHaveBeenCalledWith({ email: mockEmail.toLowerCase() });
  });

  it('Powinien rzucić błąd "Nieprawidłowy email lub hasło" jeśli hasło jest niepoprawne', async () => {
    const mockUser = {
      _id: mockUserId,
      email: mockEmail,
      password: 'zahashowane_haslo_z_bazy',
    };
    User.findOne.mockResolvedValue(mockUser);
    bcrypt.compare.mockResolvedValue(false);

    await expect(authService.login(mockEmail, mockWrongPassword))
      .rejects
      .toThrow('Nieprawidłowy email lub hasło.');

    expect(bcrypt.compare).toHaveBeenCalledWith(mockWrongPassword, mockUser.password);
  });

  it('Powinien zwrócić token JWT gdy email i hasło są poprawne', async () => {
    const mockUser = {
      _id: mockUserId,
      email: mockEmail,
      password: 'zahashowane_haslo_z_bazy',
    };
    User.findOne.mockResolvedValue(mockUser);
    bcrypt.compare.mockResolvedValue(true);

    const result = await authService.login(mockEmail, mockPassword);

    expect(typeof result).toBe('string');
    expect(result.length).toBeGreaterThan(20);
    expect(User.findOne).toHaveBeenCalledWith({ email: mockEmail.toLowerCase() });
    expect(bcrypt.compare).toHaveBeenCalledWith(mockPassword, mockUser.password);
  });

  // Dodatkowe testy dla przypadków brzegowych
  it('Powinien rzucić błąd gdy email jest pusty', async () => {
    await expect(authService.login('', mockPassword))
      .rejects
      .toThrow('Email jest wymagany.');
  });

  it('Powinien rzucić błąd gdy hasło jest puste', async () => {
    await expect(authService.login(mockEmail, ''))
      .rejects
      .toThrow('Hasło jest wymagane.');
  });
});

==================================
__tests__\services\commentService.test.js v.1
==================================

// __tests__/services/commentService.test.js
const commentService = require('../../services/commentService');
const Comment = require('../../models/Comment');
const Article = require('../../models/Article');

jest.mock('../../models/Comment');
jest.mock('../../models/Article');

describe('Serwis: commentService', () => {
  const mockArticleId = '507f1f77bcf86cd799439022';
  const mockUserId = '507f1f77bcf86cd799439011';
  const mockCommentId = '507f1f77bcf86cd799439033';
  const mockCommentText = 'To jest bardzo przemyślany komentarz';

  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe('addComment', () => {
    it('Powinien dodać komentarz do istniejącego artykułu', async () => {
      // ARRANGE
      Article.findById.mockResolvedValue({ _id: mockArticleId });
      // Mock Comment.create zamiast new Comment().save()
      Comment.create.mockResolvedValue({
        _id: mockCommentId,
        text: mockCommentText,
        article: mockArticleId,
        author: mockUserId,
      });

      // ACT
      const result = await commentService.addComment(
        mockArticleId,
        mockUserId,
        mockCommentText,
      );

      // ASSERT
      expect(Article.findById).toHaveBeenCalledWith(mockArticleId);
      expect(Comment.create).toHaveBeenCalledWith({
        text: mockCommentText,
        article: mockArticleId,
        author: mockUserId,
      });
      expect(result.text).toBe(mockCommentText);
    });

    it('Powinien rzucić błąd jeśli artykuł nie istnieje', async () => {
      // ARRANGE
      Article.findById.mockResolvedValue(null);

      // ACT & ASSERT - Uwzględnij kropkę w komunikacie
      await expect(
        commentService.addComment(mockArticleId, mockUserId, mockCommentText),
      ).rejects.toThrow('Nie znaleziono artykułu.');
    });

    it('Powinien rzucić błąd walidacji dla zbyt krótkiego komentarza', async () => {
      // ARRANGE
      Article.findById.mockResolvedValue({ _id: mockArticleId });
      const shortText = 'Krótk';

      // ACT & ASSERT
      await expect(
        commentService.addComment(mockArticleId, mockUserId, shortText),
      ).rejects.toThrow('Komentarz musi mieć co najmniej 6 znaków');

      // Dodatkowo: upewnij się, że Comment.create NIE został wywołany
      expect(Comment.create).not.toHaveBeenCalled();
    });
  });

  describe('getComments', () => {
    it('Powinien zwrócić listę komentarzy dla artykułu', async () => {
      // ARRANGE
      const mockComments = [
        { _id: 'comment1', text: 'Komentarz 1', author: { username: 'user1' } },
        { _id: 'comment2', text: 'Komentarz 2', author: { username: 'user2' } },
      ];
      Comment.find.mockReturnValue({
        populate: jest.fn().mockReturnThis(),
        sort: jest.fn().mockResolvedValue(mockComments),
      });

      // ACT
      const result = await commentService.getComments(mockArticleId);

      // ASSERT
      expect(Comment.find).toHaveBeenCalledWith({ article: mockArticleId });
      expect(result).toEqual(mockComments);
    });
  });

  describe('updateComment', () => {
    it('Powinien zaktualizować komentarz jeśli użytkownik jest autorem', async () => {
      // ARRANGE
      const mockComment = {
        _id: mockCommentId,
        text: 'Stara treść',
        author: mockUserId,
        save: jest.fn().mockResolvedValue({
          _id: mockCommentId,
          text: 'Nowa treść',
          author: mockUserId,
        }),
      };
      Comment.findById.mockResolvedValue(mockComment);

      // ACT
      const result = await commentService.updateComment(
        mockCommentId,
        mockUserId,
        'user',
        'Nowa treść',
      );

      // ASSERT
      expect(Comment.findById).toHaveBeenCalledWith(mockCommentId);
      expect(mockComment.save).toHaveBeenCalled();
      expect(result.text).toBe('Nowa treść');
    });

    it('Powinien rzucić błąd jeśli komentarz nie istnieje', async () => {
      // ARRANGE
      Comment.findById.mockResolvedValue(null);

      // ACT & ASSERT
      await expect(
        commentService.updateComment(
          mockCommentId,
          mockUserId,
          'user',
          'Nowa treść',
        ),
      ).rejects.toThrow('Komentarz nie istnieje');
    });
  });

  describe('deleteComment', () => {
    it('Powinien usunąć komentarz jeśli użytkownik jest autorem', async () => {
      // ARRANGE
      const mockComment = {
        _id: mockCommentId,
        author: mockUserId,
        deleteOne: jest.fn().mockResolvedValue(true),
      };
      Comment.findById.mockResolvedValue(mockComment);

      // ACT
      await commentService.deleteComment(mockCommentId, mockUserId, 'user');

      // ASSERT
      expect(Comment.findById).toHaveBeenCalledWith(mockCommentId);
      expect(mockComment.deleteOne).toHaveBeenCalled();
    });
  });
});


==================================
__tests__\services\userService.integration.test.js v.2
==================================

// __tests__/services/userService.integration.test.js
const mongoose = require('mongoose');
const { MongoMemoryServer } = require('mongodb-memory-server');
const bcrypt = require('bcryptjs');
const User = require('../../models/User');
const userService = require('../../services/userService');

let mongoServer;

// ✅ Zwiększ timeout dla wszystkich testów
jest.setTimeout(30000);

beforeAll(async () => {
  try {
    mongoServer = await MongoMemoryServer.create();
    const uri = mongoServer.getUri();
    await mongoose.connect(uri);
    console.log('Connected to MongoDB Memory Server:', uri);
  } catch (error) {
    console.error('MongoDB connection error:', error);
    throw error;
  }
});

afterEach(async () => {
  try {
    await User.deleteMany({});
  } catch (error) {
    console.error('Error cleaning up users:', error);
  }
});

afterAll(async () => {
  try {
    // ✅ Bezpieczne zamykanie połączenia
    if (mongoose.connection.readyState !== 0) {
      await mongoose.disconnect();
    }
    // ✅ Bezpieczne zatrzymanie memory server
    if (mongoServer) {
      await mongoServer.stop();
    }
    console.log('MongoDB connection closed');
  } catch (error) {
    console.error('Error closing MongoDB connection:', error);
  }
});

describe('Serwis: userService - testy integracyjne', () => {
  it('Powinien stworzyć i pobrać użytkownika bez hasła', async () => {
    const user = await User.create({
      email: 'test@test.com',
      password: 'hashedPassword',
      username: 'Tester',
      role: 'user',
    });

    const profile = await userService.getProfile(user._id);

    expect(profile).toMatchObject({
      email: 'test@test.com',
      username: 'Tester',
      role: 'user',
    });
    expect(profile.password).toBeUndefined();
  });

  it('Powinien zaktualizować nazwę użytkownika', async () => {
    const user = await User.create({
      email: 'abc@test.com',
      password: 'hashedPassword',
      username: 'OldName',
      role: 'user',
    });

    const updated = await userService.updateProfile(user._id, {
      username: 'NewName',
    });

    expect(updated.username).toBe('NewName');
    expect(updated.password).toBeUndefined();
  });

  it('Powinien rzucić błąd gdy użytkownik nie istnieje', async () => {
    const fakeId = new mongoose.Types.ObjectId();
    await expect(userService.getProfile(fakeId)).rejects.toThrow(
      'Użytkownik nie istnieje',
    );
  });

  it('Powinien zmienić hasło gdy stare hasło jest poprawne', async () => {
    const hashed = await bcrypt.hash('oldPass', 10);
    const user = await User.create({
      email: 'pass@test.com',
      password: hashed,
      username: 'PassUser',
      role: 'user',
    });

    await userService.changePassword(user._id, 'oldPass', 'newPass');
    const updated = await User.findById(user._id);

    const isMatch = await bcrypt.compare('newPass', updated.password);
    expect(isMatch).toBe(true);
  });

  it('Powinien rzucić błąd gdy stare hasło jest nieprawidłowe', async () => {
    const hashed = await bcrypt.hash('oldPass', 10);
    const user = await User.create({
      email: 'failpass@test.com',
      password: hashed,
      username: 'FailUser',
      role: 'user',
    });

    await expect(
      userService.changePassword(user._id, 'wrongPass', 'newPass'),
    ).rejects.toThrow('Stare hasło jest nieprawidłowe.');
  });

  it('Powinien zwrócić listę użytkowników bez haseł', async () => {
    await User.create([
      {
        email: 'user1@test.com',
        password: 'hashedPassword1', // min 6 znaków
        username: 'User1',
        role: 'user',
      },
      {
        email: 'user2@test.com',
        password: 'hashedPassword2', // min 6 znaków
        username: 'User2',
        role: 'user',
      },
    ]);

    const users = await userService.listUsers();

    expect(users).toHaveLength(2);
    users.forEach((u) => expect(u.password).toBeUndefined());
  });

  it('Powinien zmienić rolę użytkownika na admin', async () => {
    const user = await User.create({
      email: 'role@test.com',
      password: 'hashed',
      username: 'RoleUser',
      role: 'user',
    });

    const updated = await userService.changeRole(user._id, 'admin');

    expect(updated.role).toBe('admin');
    expect(updated.password).toBeUndefined();
  });

  it('Powinien rzucić błąd dla nieprawidłowej roli', async () => {
    const user = await User.create({
      email: 'badrole@test.com',
      password: 'hashed',
      username: 'BadRole',
      role: 'user',
    });

    await expect(
      userService.changeRole(user._id, 'superadmin'),
    ).rejects.toThrow('Nieprawidłowa rola.');
  });

  it('Powinien usunąć użytkownika', async () => {
    const user = await User.create({
      email: 'del@test.com',
      password: 'hashed',
      username: 'DeleteMe',
      role: 'user',
    });

    await userService.deleteUser(user._id);

    const found = await User.findById(user._id);
    expect(found).toBeNull();
  });
});


==================================
__tests__\services\userService.test.js v.1
==================================

const bcrypt = require('bcryptjs');
const User = require('../../models/User');
const userService = require('../../services/userService');

jest.mock('../../models/User');
jest.mock('bcryptjs');

describe('Serwis: userService', () => {
  const mockUser = {
    _id: '507f1f77bcf86cd799439011',
    username: 'testuser',
    email: 'test@example.com',
    password: 'hashedpassword',
    role: 'user',
    save: jest.fn().mockResolvedValue(true),
    deleteOne: jest.fn().mockResolvedValue(true),
    toObject: jest.fn(function () {
      const obj = { ...this };
      delete obj.password;
      return obj;
    }),
  };

  beforeEach(() => {
    jest.clearAllMocks();
  });

  // --- getProfile ---
  describe('getProfile', () => {
    it('Powinien zwrócić profil użytkownika bez hasła', async () => {
      User.findById.mockImplementation(() => ({
        select: jest.fn().mockResolvedValue({ ...mockUser, password: undefined }),
      }));

      const result = await userService.getProfile(mockUser._id);

      expect(User.findById).toHaveBeenCalledWith(mockUser._id);
      expect(result.password).toBeUndefined();
      expect(result._id).toBe(mockUser._id);
    });

    it('Powinien rzucić błąd gdy użytkownik nie istnieje', async () => {
      User.findById.mockImplementation(() => ({
        select: jest.fn().mockResolvedValue(null),
      }));

      await expect(userService.getProfile('nonexistent')).rejects.toThrow('Użytkownik nie istnieje');
    });
  });

  // --- updateProfile ---
  describe('updateProfile', () => {
    it('Powinien zaktualizować nazwę użytkownika', async () => {
      User.findById.mockResolvedValue({ ...mockUser });
      const result = await userService.updateProfile(mockUser._id, { username: 'newname' });
      expect(result.username).toBe('newname');
      expect(mockUser.save).toHaveBeenCalled();
    });

    it('Powinien rzucić błąd dla zbyt krótkiej nazwy użytkownika', async () => {
      await expect(userService.updateProfile(mockUser._id, { username: 'ab' }))
        .rejects.toThrow('Nazwa użytkownika musi mieć co najmniej 3 znaki.');
    });

    it('Powinien rzucić błąd gdy użytkownik nie istnieje', async () => {
      User.findById.mockResolvedValue(null);
      await expect(userService.updateProfile(mockUser._id, { username: 'newname' }))
        .rejects.toThrow('Użytkownik nie istnieje');
    });
  });

  // --- changePassword ---
  describe('changePassword', () => {
    it('Powinien zmienić hasło gdy stare hasło jest poprawne', async () => {
      User.findById.mockResolvedValue({ ...mockUser });
      bcrypt.compare.mockResolvedValue(true);
      bcrypt.hash.mockResolvedValue('newhashedpassword');

      await userService.changePassword(mockUser._id, 'oldPassword', 'newPassword');

      expect(bcrypt.compare).toHaveBeenCalledWith('oldPassword', mockUser.password);
      expect(bcrypt.hash).toHaveBeenCalledWith('newPassword', 10);
      expect(mockUser.save).toHaveBeenCalled();
    });

    it('Powinien rzucić błąd gdy stare hasło jest nieprawidłowe', async () => {
      User.findById.mockResolvedValue({ ...mockUser });
      bcrypt.compare.mockResolvedValue(false);

      await expect(userService.changePassword(mockUser._id, 'wrongOld', 'newPassword'))
        .rejects.toThrow('Stare hasło jest nieprawidłowe.');
    });

    it('Powinien rzucić błąd gdy nowe hasło jest za krótkie', async () => {
      await expect(userService.changePassword(mockUser._id, 'oldPassword', '123'))
        .rejects.toThrow('Nowe hasło musi mieć co najmniej 6 znaków.');
    });
  });

  // --- listUsers ---
  describe('listUsers', () => {
    it('Powinien zwrócić listę użytkowników bez haseł', async () => {
      User.find.mockImplementation(() => ({
        select: jest.fn().mockReturnThis(),
        sort: jest.fn().mockResolvedValue([
          { ...mockUser, password: undefined },
          { ...mockUser, _id: '2', password: undefined },
        ]),
      }));

      const result = await userService.listUsers();

      expect(result).toHaveLength(2);
      result.forEach(u => expect(u.password).toBeUndefined());
    });
  });

  // --- changeRole ---
  describe('changeRole', () => {
    it('Powinien zmienić rolę użytkownika na admin', async () => {
      User.findById.mockResolvedValue({ ...mockUser });
      const result = await userService.changeRole(mockUser._id, 'admin');
      expect(result.role).toBe('admin');
      expect(mockUser.save).toHaveBeenCalled();
    });

    it('Powinien rzucić błąd dla nieprawidłowej roli', async () => {
      await expect(userService.changeRole(mockUser._id, 'invalid'))
        .rejects.toThrow('Nieprawidłowa rola.');
    });

    it('Powinien rzucić błąd gdy użytkownik nie istnieje', async () => {
      User.findById.mockResolvedValue(null);
      await expect(userService.changeRole(mockUser._id, 'admin'))
        .rejects.toThrow('Użytkownik nie istnieje.');
    });
  });

  // --- deleteUser ---
  describe('deleteUser', () => {
    it('Powinien usunąć użytkownika', async () => {
      User.findById.mockResolvedValue({ ...mockUser });
      await userService.deleteUser(mockUser._id);
      expect(mockUser.deleteOne).toHaveBeenCalled();
    });

    it('Powinien rzucić błąd gdy użytkownik nie istnieje', async () => {
      User.findById.mockResolvedValue(null);
      await expect(userService.deleteUser(mockUser._id))
        .rejects.toThrow('Użytkownik nie istnieje');
    });
  });
});


==================================
__tests__\utils\sanitize.test.js v.2
==================================

const {
  sanitizeTitle,
  sanitizeBody,
  sanitizeComment,
  sanitizeStrict,
} = require('../../utils/sanitize');

describe('Utils: Sanityzacja danych', () => {
  describe('sanitizeTitle', () => {
    it('Powinien usuwać wszystkie tagi HTML', () => {
      const input = '<script>alert("xss")</script>Tytuł <b>pogrubiony</b>';
      expect(sanitizeTitle(input)).toBe('Tytuł pogrubiony');
    });

    it('Powinien trimować białe znaki', () => {
      const input = '   Tytuł z spacjami   ';
      expect(sanitizeTitle(input)).toBe('Tytuł z spacjami');
    });
  });

  describe('sanitizeStrict', () => {
    it('Powinien usuwać wszystkie tagi HTML', () => {
      const input = '<script>alert("xss")</script>Tekst <b>pogrubiony</b>';
      expect(sanitizeStrict(input)).toBe('Tekst pogrubiony');
    });

    it('Powinien ograniczać długość do 500 znaków', () => {
      const longInput = 'A'.repeat(600);
      expect(sanitizeStrict(longInput).length).toBe(500);
    });

    it('Powinien radzić sobie z null/undefined', () => {
      expect(sanitizeStrict(null)).toBe('');
      expect(sanitizeStrict(undefined)).toBe('');
    });
  });

  describe('sanitizeBody', () => {
    it('Powinien pozwalać na podstawowe tagi formatujące', () => {
      const input =
        '<p>Paragraf</p><b>pogrubienie</b><a href="https://example.com">link</a>';
      const result = sanitizeBody(input);

      expect(result).toContain('<p>');
      expect(result).toContain('<b>');
      expect(result).toContain('<a href="https://example.com"');
      expect(result).not.toContain('<script>');
    });

    it('Powinien dodawać atrybuty bezpieczeństwa do linków', () => {
      const input = '<a href="https://example.com">link</a>';
      const result = sanitizeBody(input);

      expect(result).toContain('target="_blank"');
      expect(result).toContain('rel="noopener noreferrer nofollow ugc"');
    });
  });

  describe('sanitizeComment', () => {
    it('Powinien pozwalać na podstawowe formatowanie w komentarzach', () => {
      const input =
        '<b>pogrubienie</b> <i>kursywa</i> <a href="https://example.com">link</a>';
      const result = sanitizeComment(input);

      expect(result).toContain('<b>pogrubienie</b>');
      expect(result).toContain('<i>kursywa</i>');
      expect(result).toContain('<a href="https://example.com"');
      expect(result).not.toContain('<script>');
    });

    it('Powinien usuwać niebezpieczne tagi z komentarzy', () => {
      const input =
        'Safe <b>bold</b> but <img src="x" onerror="alert(1)"> dangerous <script>alert(2)</script>';
      const result = sanitizeComment(input);

      expect(result).toContain('<b>bold</b>'); // Bezpieczne tagi pozostają
      expect(result).not.toContain('<img'); // Niebezpieczne tagi są usuwane
      expect(result).not.toContain('<script>'); // Niebezpieczne tagi są usuwane
      expect(result).not.toContain('onerror'); // Niebezpieczne atrybuty są usuwane
      expect(result).toBe('Safe <b>bold</b> but  dangerous'); // Tekst pozostaje
    });

    it('Powinien zabezpieczać linki w komentarzach', () => {
      const input = '<a href="https://example.com">link</a>';
      const result = sanitizeComment(input);

      expect(result).toContain('target="_blank"');
      expect(result).toContain('rel="noopener noreferrer nofollow ugc"');
      expect(result).toContain('href="https://example.com"');
    });

    it('Powinien blokować javascript: w linkach', () => {
      const input = '<a href="javascript:alert(1)">malicious link</a>';
      const result = sanitizeComment(input);

      // Link z javascript: powinien być CAŁKOWICIE usunięty
      expect(result).not.toContain('href="javascript:');
      expect(result).not.toContain('malicious link');
      expect(result).toBe(''); // Powinno być puste
    });

    it('Powinien usuwać niebezpieczne atrybuty zdarzeń', () => {
      const input =
        '<span onclick="alert(1)" onmouseover="alert(2)">text</span>';
      const result = sanitizeComment(input);

      // Niebezpieczne atrybuty powinny być usunięte
      expect(result).not.toContain('onclick');
      expect(result).not.toContain('onmouseover');
      expect(result).toBe('text'); // Tekst powinien pozostać
    });
  });
});


==================================
backup\cms\articles.bson v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
backup\cms\articles.metadata.json v.1
==================================

{"indexes":[{"v":{"$numberInt":"2"},"key":{"_id":{"$numberInt":"1"}},"name":"_id_"},{"v":{"$numberInt":"2"},"key":{"author":{"$numberInt":"1"},"createdAt":{"$numberInt":"-1"}},"name":"author_1_createdAt_-1","background":true},{"v":{"$numberInt":"2"},"key":{"_fts":"text","_ftsx":{"$numberInt":"1"}},"name":"title_text_content_text","background":true,"weights":{"content":{"$numberInt":"1"},"title":{"$numberInt":"1"}},"default_language":"english","language_override":"language","textIndexVersion":{"$numberInt":"3"}}],"uuid":"7517bc407b74419db0e8624f43a01a0b","collectionName":"articles","type":"collection"}

==================================
backup\cms\comments.bson v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
backup\cms\comments.metadata.json v.1
==================================

{"indexes":[{"v":{"$numberInt":"2"},"key":{"_id":{"$numberInt":"1"}},"name":"_id_"},{"v":{"$numberInt":"2"},"key":{"article":{"$numberInt":"1"}},"name":"article_1","background":true}],"uuid":"49a1ac7e42a344b6a5c7fb470f3b9416","collectionName":"comments","type":"collection"}

==================================
backup\cms\pendingusers.bson v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
backup\cms\pendingusers.metadata.json v.1
==================================

{"indexes":[{"v":{"$numberInt":"2"},"key":{"_id":{"$numberInt":"1"}},"name":"_id_"},{"v":{"$numberInt":"2"},"key":{"email":{"$numberInt":"1"}},"name":"email_1","background":true,"unique":true},{"v":{"$numberInt":"2"},"key":{"createdAt":{"$numberInt":"1"}},"name":"createdAt_1","background":true,"expireAfterSeconds":{"$numberInt":"86400"}}],"uuid":"3bca25e0c9ea484484956c2a6730026d","collectionName":"pendingusers","type":"collection"}

==================================
backup\cms\users.bson v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
backup\cms\users.metadata.json v.1
==================================

{"indexes":[{"v":{"$numberInt":"2"},"key":{"_id":{"$numberInt":"1"}},"name":"_id_"},{"v":{"$numberInt":"2"},"key":{"username":{"$numberInt":"1"}},"name":"username_1","background":true,"unique":true},{"v":{"$numberInt":"2"},"key":{"email":{"$numberInt":"1"}},"name":"email_1","background":true,"unique":true}],"uuid":"fff3b0f67d424a188cedaf8d37c22388","collectionName":"users","type":"collection"}

==================================
controllers\adminController.js v.1
==================================

const logger = require('../utils/logger');
const bcrypt = require('bcryptjs');
const PendingUser = require('../models/PendingUser');
const User = require('../models/User');
const { sanitizeTitle } = require('../utils/sanitize');
const { sendMail } = require('../utils/mailer');
const {
  approvedUserEmail,
  rejectedUserEmail,
} = require('../utils/emailTemplates');
const AppError = require('../utils/AppError');

// GET /api/admin/pending-users
const getPendingUsers = async (req, res, next) => {
  try {
    const { search = '', page = 1, limit = 10 } = req.query;

    const query = {
      $or: [
        { username: { $regex: search, $options: 'i' } },
        { email: { $regex: search, $options: 'i' } },
      ],
    };

    const skip = (parseInt(page) - 1) * parseInt(limit);

    const [total, users] = await Promise.all([
      PendingUser.countDocuments(query),
      PendingUser.find(query)
        .sort({ createdAt: -1 })
        .skip(skip)
        .limit(parseInt(limit))
        .lean(),
    ]);

    res.json({
      total,
      page: parseInt(page),
      limit: parseInt(limit),
      users,
    });
  } catch (error) {
    next(error);
  }
};

// POST /api/admin/approve/:id
const approveUser = async (req, res, next) => {
  try {
    const { id } = req.params;
    const pending = await PendingUser.findById(id);
    if (!pending) return next(new AppError('Wniosek nie istnieje.', 404));

    const exists = await User.findOne({ email: pending.email });
    if (exists) {
      await pending.deleteOne();
      return next(new AppError('Email jest już zajęty w systemie.', 400));
    }

    const hashed = await bcrypt.hash(String(pending.password), 10);
    const user = new User({
      username: sanitizeTitle(pending.username),
      email: pending.email,
      password: hashed,
      role: pending.role,
    });
    const savedUser = await user.save();

    await pending.deleteOne();

    // wysyłka maila (best-effort)
    try {
      const tpl = approvedUserEmail({
        username: user.username,
        email: user.email,
      });
      await sendMail({
        to: user.email,
        subject: tpl.subject,
        text: tpl.text,
        html: tpl.html,
      });
    } catch (mailError) {
      logger.warn(
        'approveUser: mail send failed:',
        mailError?.message || mailError,
      );
    }

    return res.json({
      message: 'Użytkownik zatwierdzony i dodany do systemu.',
      userId: savedUser._id, // ← UŻYJ ZAPISANEGO DOKUMENTU
    });
  } catch (error) {
    next(error);
  }
};

// DELETE /api/admin/reject/:id
const rejectUser = async (req, res, next) => {
  try {
    const { id } = req.params;
    const pending = await PendingUser.findById(id);
    if (!pending) return next(new AppError('Wniosek nie istnieje.', 404));

    // wysyłka maila (best-effort)
    try {
      const tpl = rejectedUserEmail({
        username: pending.username,
        email: pending.email,
      });
      await sendMail({
        to: pending.email,
        subject: tpl.subject,
        text: tpl.text,
        html: tpl.html,
      });
    } catch (mailError) {
      logger.warn(
        'rejectUser: mail send failed:',
        mailError?.message || mailError,
      );
    }

    await pending.deleteOne();
    return res.json({ message: 'Wniosek został odrzucony.' });
  } catch (error) {
    next(error);
  }
};

module.exports = {
  getPendingUsers,
  approveUser,
  rejectUser,
};


==================================
controllers\articleController.js v.1
==================================

const logger = require('../utils/logger');
const articleService = require('../services/articleService');
const fs = require('fs');
const path = require('path');

const UPLOADS_DIR = path.join(__dirname, '..', 'uploads');

// Helper function (only what's necessary for the controller)
function toUploadsRel(p) {
  if (!p) return '';
  const s = String(p);
  const m = s.match(/uploads[/\\]+(.+)$/i);
  return m ? m[1] : path.basename(s);
}

// POST /api/articles
const createArticle = async (req, res) => {
  try {
    const { title, content } = req.body;

    // Map uploaded files to image paths
    const imagePaths = (req.files || []).map((f) => `uploads/${f.filename}`.replace(/\\/g, '/'));

    // Authorization check
    const author = req.user ? req.user._id : null;
    if (!author) {
      // Clean up uploads if no authorization
      imagePaths.forEach((rel) => {
        const full = path.join(UPLOADS_DIR, toUploadsRel(rel));
        fs.unlink(full, () => {});
      });
      return res.status(401).json({ message: 'Nieautoryzowany dostęp' });
    }

    // Call service
    const newArticle = await articleService.createArticle(title, content, author, imagePaths);

    return res.status(201).json({ message: 'Artykuł utworzony', article: newArticle });
  } catch (error) {
    // Clean up uploads on error
    if (req.files && req.files.length > 0) {
      for (const f of req.files) {
        const full = path.join(UPLOADS_DIR, toUploadsRel(f.filename || f.path));
        fs.unlink(full, () => {});
      }
    }
    logger.error('Błąd tworzenia artykułu:', error);
    if (error.message.includes('Tytuł musi mieć') || error.message.includes('Treść musi mieć') || error.message.includes('jest wymagana')) {
      return res.status(400).json({ message: error.message });
    }
    return res.status(500).json({ message: 'Błąd serwera' });
  }
};

// GET /api/articles
const getArticles = async (req, res) => {
  try {
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 5;
    const search = (req.query.q || '').trim();
    const sort = req.query.sort || 'newest';

    const result = await articleService.getArticles(page, limit, search, sort);
    return res.json(result);
  } catch (error) {
    logger.error('Błąd pobierania artykułów:', error);
    return res.status(500).json({ message: 'Błąd serwera' });
  }
};

// GET /api/articles/:id
const getArticleById = async (req, res) => {
  try {
    const { id } = req.params;
    const article = await articleService.getArticleById(id);
    return res.status(200).json(article);
  } catch (error) {
    logger.error('Błąd pobierania artykułu:', error);
    if (error.message === 'Nie znaleziono artykułu') {
      return res.status(404).json({ message: error.message });
    }
    return res.status(500).json({ message: 'Błąd serwera' });
  }
};

// PUT /api/articles/:id
const updateArticle = async (req, res) => {
  try {
    const { id } = req.params;
    const { title, content, removeImages } = req.body;

    const updateData = { title, content, removeImages };
    const result = await articleService.updateArticle(
      id,
      updateData,
      req.user._id,
      req.user.role,
      req.files,
    );

    return res.json({ message: 'Artykuł zaktualizowany', article: result });
  } catch (error) {
    logger.error('Błąd aktualizacji artykułu:', error);
    if (error.message === 'Artykuł nie znaleziony') {
      return res.status(404).json({ message: error.message });
    }
    if (error.message === 'Brak uprawnień do edycji') {
      return res.status(403).json({ message: error.message });
    }
    if (error.message.includes('Tytuł musi mieć') || error.message.includes('Treść musi mieć')) {
      return res.status(400).json({ message: error.message });
    }
    return res.status(500).json({ message: 'Błąd serwera' });
  }
};

// DELETE /api/articles/:id
const deleteArticle = async (req, res) => {
  try {
    const { id } = req.params;
    await articleService.deleteArticle(id, req.user._id, req.user.role);
    return res.status(204).end();
  } catch (error) {
    logger.error('Błąd usuwania artykułu:', error);
    if (error.message === 'Artykuł nie istnieje') {
      return res.status(404).json({ message: error.message });
    }
    if (error.message === 'Brak uprawnień') {
      return res.status(403).json({ message: error.message });
    }
    return res.status(500).json({ message: 'Błąd serwera' });
  }
};

// POST /api/articles/:id/like
const toggleLikeArticle = async (req, res) => {
  try {
    const { id } = req.params;
    const result = await articleService.toggleLikeArticle(id, req.user._id);
    return res.json(result);
  } catch (error) {
    logger.error('Błąd toggle lajka artykułu:', error);
    if (error.message === 'Artykuł nie znaleziony') {
      return res.status(404).json({ message: error.message });
    }
    if (error.message === 'Autor nie może polubić własnego artykułu') {
      return res.status(400).json({
        message: error.message,
        liked: false,
        totalLikes: 0,
      });
    }
    return res.status(500).json({ message: 'Błąd serwera' });
  }
};

module.exports = {
  createArticle,
  getArticles,
  getArticleById,
  updateArticle,
  deleteArticle,
  toggleLikeArticle,
};

==================================
controllers\authController.js v.1
==================================

const authService = require('../services/authService');

// ZMIANA 1: Uproszczono baseCookieOptions dla lokalnego środowiska
const baseCookieOptions = {
  httpOnly: true,
  sameSite: 'lax',
  secure: false,
  path: '/',
};

// Rejestracja — użytkownik oczekujący na zatwierdzenie
const registerPending = async (req, res) => {
  try {
    const { username, email, password, role } = req.body;
    await authService.registerPending(username, email, password, role);
    res.status(201).json({ message: 'Wniosek o rejestrację został przesłany.' });
  } catch (error) {
    if (error.message.includes('Email jest już zajęty') || error.message.includes('jest wymagana')) {
      return res.status(400).json({ message: error.message });
    }
    res.status(500).json({ message: 'Błąd serwera.', error });
  }
};

// Logowanie
const login = async (req, res) => {
  try {
    const { email, password } = req.body;
    const token = await authService.login(email, password);

    res.cookie('token', token, {
      ...baseCookieOptions,
      maxAge: 24 * 60 * 60 * 1000, // 1 dzień
    });

    res.json({ message: 'Zalogowano pomyślnie.' });
  } catch (error) {
    if (error.message.includes('Nieprawidłowy email lub hasło') || error.message.includes('jest wymagane')) {
      return res.status(400).json({ message: error.message });
    }
    res.status(500).json({ message: 'Błąd serwera.', error });
  }
};

// Wylogowanie
const logout = (_req, res) => {
  res.clearCookie('token', {
    ...baseCookieOptions,
  });
  res.json({ message: 'Wylogowano.' });
};

module.exports = {
  registerPending,
  login,
  logout,
};

==================================
controllers\commentController.js v.1
==================================

const logger = require('../utils/logger');
const commentService = require('../services/commentService');

// POST /api/comments/:id
const addComment = async (req, res) => {
  try {
    const articleId = req.params.id;
    const rawText = req.body?.text ?? '';
    const comment = await commentService.addComment(articleId, req.user._id, rawText);
    return res.status(201).json(comment);
  } catch (error) {
    logger.error('Błąd podczas dodawania komentarza:', error);
    if (
      error.message.includes('Komentarz nie może być pusty') ||
      error.message.includes('co najmniej 6 znaków') ||
      error.message.includes('odfiltrowaniu')
    ) {
      return res.status(400).json({ message: error.message });
    }
    if (error.message.includes('Nie znaleziono artykułu')) {
      return res.status(404).json({ message: error.message });
    }
    return res.status(500).json({ message: 'Błąd serwera' });
  }
};

// GET /api/comments/:id
const getComments = async (req, res) => {
  try {
    const articleId = req.params.id;
    const comments = await commentService.getComments(articleId);
    return res.json(comments);
  } catch (error) {
    logger.error('Błąd podczas pobierania komentarzy:', error);
    return res.status(500).json({ message: 'Błąd serwera' });
  }
};

// PUT /api/comments/:id
const updateComment = async (req, res) => {
  try {
    const commentId = req.params.id;
    const rawText = req.body?.text ?? '';
    const comment = await commentService.updateComment(
      commentId,
      req.user._id,
      req.user.role,
      rawText,
    );
    return res.json(comment);
  } catch (error) {
    logger.error('Błąd podczas edycji komentarza:', error);
    if (
      error.message.includes('Komentarz nie może być pusty') ||
      error.message.includes('co najmniej 6 znaków') ||
      error.message.includes('odfiltrowaniu')
    ) {
      return res.status(400).json({ message: error.message });
    }
    if (error.message.includes('Komentarz nie istnieje')) {
      return res.status(404).json({ message: error.message });
    }
    if (error.message.includes('Brak uprawnień')) {
      return res.status(403).json({ message: error.message });
    }
    return res.status(500).json({ message: 'Błąd serwera' });
  }
};

// DELETE /api/comments/:id
const deleteComment = async (req, res) => {
  try {
    const commentId = req.params.id;
    await commentService.deleteComment(commentId, req.user._id, req.user.role);
    return res.status(204).end();
  } catch (error) {
    logger.error('Błąd podczas usuwania komentarza:', error);
    if (error.message.includes('Komentarz nie istnieje')) {
      return res.status(404).json({ message: error.message });
    }
    if (error.message.includes('Brak uprawnień')) {
      return res.status(403).json({ message: error.message });
    }
    return res.status(500).json({ message: 'Błąd serwera' });
  }
};

module.exports = {
  addComment,
  getComments,
  updateComment,
  deleteComment,
};

==================================
controllers\userController.js v.1
==================================

const logger = require('../utils/logger');
const userService = require('../services/userService');

// GET /api/users/profile
const getProfile = async (req, res) => {
  try {
    if (!req.user) return res.status(401).json({ message: 'Brak autoryzacji' });
    const user = await userService.getProfile(req.user._id);
    return res.json(user);
  } catch (error) {
    logger.error('Błąd getProfile:', error);
    return res.status(500).json({ message: 'Błąd serwera' });
  }
};

// PUT /api/users/profile
const updateProfile = async (req, res) => {
  try {
    if (!req.user) return res.status(401).json({ message: 'Brak autoryzacji' });
    const user = await userService.updateProfile(req.user._id, req.body);
    return res.json({ message: 'Profil zaktualizowany', user });
  } catch (error) {
    logger.error('Błąd updateProfile:', error);
    if (error.message.includes('Nazwa użytkownika')) {
      return res.status(400).json({ message: error.message });
    }
    return res.status(500).json({ message: 'Błąd serwera' });
  }
};

// PUT /api/users/password
const changePassword = async (req, res) => {
  try {
    if (!req.user) return res.status(401).json({ message: 'Brak autoryzacji' });
    const { oldPassword, newPassword } = req.body;
    await userService.changePassword(req.user._id, oldPassword, newPassword);
    return res.json({ message: 'Hasło zostało zmienione.' });
  } catch (error) {
    logger.error('Błąd changePassword:', error);
    if (error.message.includes('Stare hasło') || error.message.includes('Nowe hasło')) {
      return res.status(400).json({ message: error.message });
    }
    return res.status(500).json({ message: 'Błąd serwera' });
  }
};

// GET /api/users (admin)
const listUsers = async (req, res) => {
  try {
    const users = await userService.listUsers();
    return res.json(users);
  } catch (error) {
    logger.error('Błąd listUsers:', error);
    return res.status(500).json({ message: 'Błąd serwera' });
  }
};

// PUT /api/users/:id/role (admin)
const changeRole = async (req, res) => {
  try {
    const { id } = req.params;
    const { role } = req.body;
    const user = await userService.changeRole(id, role);
    return res.json({ message: 'Rola zaktualizowana.', user });
  } catch (error) {
    logger.error('Błąd changeRole:', error);
    if (error.message.includes('Rola') || error.message.includes('Nieprawidłowa')) {
      return res.status(400).json({ message: error.message });
    }
    return res.status(500).json({ message: 'Błąd serwera' });
  }
};

// DELETE /api/users/:id (admin)
const deleteUser = async (req, res) => {
  try {
    const { id } = req.params;
    await userService.deleteUser(id);
    return res.status(204).end();
  } catch (error) {
    logger.error('Błąd deleteUser:', error);
    if (error.message.includes('Użytkownik nie istnieje')) {
      return res.status(404).json({ message: error.message });
    }
    return res.status(500).json({ message: 'Błąd serwera' });
  }
};

module.exports = {
  getProfile,
  updateProfile,
  changePassword,
  listUsers,
  changeRole,
  deleteUser,
};

==================================
eslint.config.js v.2
==================================

const js = require('@eslint/js');
const globals = require('globals');

module.exports = [
  {
    files: ['**/*.js'],
    ignores: [
      'node_modules/**',
      'uploads/**',
      'logs/**',
      'backup/**',
      '__tests__/coverage/**',
      'dist/**',
    ],
    languageOptions: {
      ecmaVersion: 'latest',
      sourceType: 'commonjs',
      globals: {
        ...globals.node,
        console: 'readonly',
        process: 'readonly',
        __dirname: 'readonly',
        __filename: 'readonly',
      },
    },
    rules: {
      ...js.configs.recommended.rules,
      'no-unused-vars': [
        'error',
        {
          argsIgnorePattern: '^_',
          varsIgnorePattern: '^_',
          caughtErrorsIgnorePattern: '^_',
          destructuredArrayIgnorePattern: '^_',
        },
      ],
      'no-console': 'warn',
      'prefer-const': 'error',
      'no-var': 'error',
      quotes: ['error', 'single', { avoidEscape: true }],
      semi: ['error', 'always'],
      'indent': ['error', 2],
      'comma-dangle': ['error', 'always-multiline'],
      'object-curly-spacing': ['error', 'always'],
      'array-bracket-spacing': ['error', 'never'],
    },
  },
  {
    files: ['__tests__/**/*.js'],
    languageOptions: {
      globals: {
        ...globals.jest, // ✅ DODAJEMY GLOBALNE ZMIENNE JEST
        ...globals.node,
      },
    },
    rules: {
      'no-console': 'off',
      'no-unused-vars': [
        'error',
        {
          argsIgnorePattern: '^_',
          varsIgnorePattern: '^_',
          caughtErrorsIgnorePattern: '^_',
          destructuredArrayIgnorePattern: '^_',
        },
      ],
    },
  },
];


==================================
jest-mongodb-config.js v.1
==================================

// jest-mongodb-config.js (w root projektu)
module.exports = {
  mongodbMemoryServerOptions: {
    instance: {
      dbName: 'cms-test', // nazwa testowej bazy
    },
    binary: {
      version: '6.0.0', // wersja MongoDB
      skipMD5: true,
    },
    autoStart: false,
  },
};


==================================
jest.config.js v.3
==================================

// jest.config.js (poprawiona wersja)
module.exports = {
  testEnvironment: 'node',
  setupFiles: ['<rootDir>/jest.setup.js'],
  collectCoverageFrom: [
    'services/**/*.js',
    'controllers/**/*.js',
    'utils/**/*.js',
    '!**/node_modules/**',
  ],
  coverageThreshold: {
    global: {
      branches: 0,
      functions: 0,
      lines: 0,
      statements: 0,
    },
  },
  testPathIgnorePatterns: [
    '/node_modules/',
    // USUŃ lub ZMIEŃ tę linię:
    // '__tests__/integration/.+',
  ],
  // Możesz dodać jawną definicję patternów testowych:
  testMatch: ['**/__tests__/**/*.test.js', '**/__tests__/**/*.spec.js'],
};


==================================
jest.setup.js v.1
==================================

// jest.setup.js
const path = require('path');
// Ładujemy zmienne środowiskowe Z PLIKU .env.test
require('dotenv').config({ path: path.resolve(__dirname, '.env.test') });


==================================
middleware\authMiddleware.js v.1
==================================

const jwt = require('jsonwebtoken');
const User = require('../models/User');
const AppError = require('../utils/AppError');

// Middleware sprawdzający czy użytkownik jest zalogowany i ważny token
const requireAuth = async (req, res, next) => {
  const token = req.cookies.token;

  if (!token) {
    return next(new AppError('Brak tokena. Dostęp zabroniony.', 401));
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    const user = await User.findById(decoded.id).select('-password');

    if (!user) {
      return next(new AppError('Użytkownik nie istnieje', 401));
    }

    req.user = user;
    next();
  } catch (_error) {
    next(new AppError('Nieprawidłowy token.', 401));
  }
};

module.exports = requireAuth;

==================================
middleware\cacheMiddleware.js v.1
==================================

// middleware/cacheMiddleware.js
const redisClient = require('../utils/redisClient');

const cacheMiddleware = (duration = 3600) => {
  return async (req, res, next) => {
    // Cache tylko dla GET requests
    if (req.method !== 'GET') {
      return next();
    }

    // Klucz cache na podstawie URL i query params
    const key = `cache:${req.originalUrl}`;

    try {
      // Sprawdź czy mamy dane w cache
      const cachedData = await redisClient.get(key);
      
      if (cachedData) {
        console.log('Cache HIT:', key);
        return res.json(JSON.parse(cachedData));
      }

      console.log('Cache MISS:', key);

      // Zapisz oryginalną metodę res.json
      const originalJson = res.json.bind(res);

      // Nadpisz res.json aby cache'ować odpowiedź
      res.json = (body) => {
        // Cache'uj tylko successful responses
        if (res.statusCode >= 200 && res.statusCode < 300) {
          redisClient.set(key, JSON.stringify(body), duration)
            .catch(err => console.error('Cache set error:', err));
        }
        return originalJson(body);
      };

      next();
    } catch (error) {
      console.error('Cache middleware error:', error);
      next();
    }
  };
};

// Specjalny middleware do invalidacji cache
const invalidateCache = (pattern) => {
  return async (req, res, next) => {
    // Po successful POST/PUT/DELETE, invaliduj cache
    const afterResponse = async () => {
      try {
        if (res.statusCode >= 200 && res.statusCode < 300) {
          // Dla uproszczenia - w production użyj redis.scan
          // Teraz po prostu logujemy że trzeba by invalidować
          console.log('Should invalidate cache for pattern:', pattern);
        }
      } catch (error) {
        console.error('Cache invalidation error:', error);
      }
    };

    res.on('finish', afterResponse);
    next();
  };
};

module.exports = { cacheMiddleware, invalidateCache };

==================================
middleware\cspMiddleware.js v.1
==================================

// middleware/cspMiddleware.js
const helmet = require('helmet');

const cspConfig = {
  directives: {
    defaultSrc: ["'self'"],
    scriptSrc: [
      "'self'",
      "'unsafe-inline'", // Tymczasowo dla kompatybilności
      'https:',
    ],
    styleSrc: [
      "'self'",
      "'unsafe-inline'", // Tymczasowo dla kompatybilności
      'https:',
    ],
    imgSrc: [
      "'self'",
      'data:',
      'blob:',
      'https:',
    ],
    fontSrc: ["'self'", 'https:', 'data:'],
    objectSrc: ["'none'"],
    mediaSrc: ["'self'"],
    frameSrc: ["'none'"],
    connectSrc: ["'self'"],
    formAction: ["'self'"],
    baseUri: ["'self'"],
    frameAncestors: ["'none'"],
  },
  reportOnly: process.env.NODE_ENV === 'development',
};

const cspMiddleware = helmet.contentSecurityPolicy(cspConfig);

module.exports = cspMiddleware;

==================================
middleware\isAuthor.js v.1
==================================

const Article = require('../models/Article');
const AppError = require('../utils/AppError');

const isAuthor = async (req, res, next) => {
  try {
    const article = await Article.findById(req.params.id);

    if (!article) {
      return next(new AppError('Artykuł nie znaleziony', 404));
    }

    if (article.author.toString() !== req.user._id.toString()) {
      return next(new AppError('Brak uprawnień do edycji lub usunięcia tego artykułu', 403));
    }

    next();
  } catch (error) {
    next(error);
  }
};

module.exports = isAuthor;

==================================
middleware\isCommentAuthor.js v.1
==================================

const Comment = require('../models/Comment');
const AppError = require('../utils/AppError');

const isCommentAuthor = async (req, res, next) => {
  try {
    const comment = await Comment.findById(req.params.id);
    if (!comment) return next(new AppError('Komentarz nie znaleziony', 404));

    if (comment.author.toString() !== req.user._id.toString()) {
      return next(new AppError('Brak uprawnień do wykonania tej operacji', 403));
    }

    next();
  } catch (error) {
    next(error);
  }
};

module.exports = isCommentAuthor;

==================================
middleware\performanceMiddleware.js v.1
==================================

// middleware/performanceMiddleware.js
const performanceMiddleware = (req, res, next) => {
  const start = Date.now();
  
  res.on('finish', () => {
    const duration = Date.now() - start;
    console.log(`⏱️ ${req.method} ${req.url} - ${duration}ms`);
    
    if (duration > 100) {
      console.warn(`🚨 WOLNE ZAPYTANIE: ${req.url} - ${duration}ms`);
    }
  });
  
  next();
};

module.exports = performanceMiddleware;

==================================
middleware\rateLimit.js v.1
==================================

const rateLimit = require('express-rate-limit');

// Podstawowy rate limiting dla wszystkich endpointów
const globalLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minut
  max: 1000, // maksymalnie 1000 żądań na IP w przedziale czasowym
  message: {
    status: 'error',
    message: 'Zbyt wiele żądań z tego adresu IP. Spróbuj ponownie za 15 minut.',
  },
  standardHeaders: true, // Zwraca nagłówki RateLimit-*
  legacyHeaders: false, // Wyłącza nagłówki X-RateLimit-*
});

// Zaostrzony limiting dla endpointów autentykacji
const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minut
  max: 50, // tylko 50 prób logowania/rejestracji na IP
  message: {
    status: 'error',
    message: 'Zbyt wiele prób autentykacji. Spróbuj ponownie za 15 minut.',
  },
  skip: (req) =>
    // Pomijaj limity dla udanych logowań (chroni przed blokowaniem prawdziwych użytkowników)
    req.path.includes('/login') && req.method === 'POST' && req.user,
});

// Bardzo restrykcyjny limiting dla admin endpoints
const adminLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minut
  max: 200, // 200 żądań na IP dla endpointów admina
  message: {
    status: 'error',
    message: 'Zbyt wiele żądań do panelu administracyjnego.',
  },
});

module.exports = {
  globalLimiter,
  authLimiter,
  adminLimiter,
};


==================================
middleware\requireAdmin.js v.1
==================================

const AppError = require('../utils/AppError');

module.exports = (req, res, next) => {
  if (!req.user) {
    return next(new AppError('Brak autoryzacji', 401));
  }
  if (req.user.role !== 'admin') {
    return next(new AppError('Brak dostępu — wymagane uprawnienia administratora', 403));
  }
  next();
};

==================================
middleware\requireAuthorOrAdmin.js v.1
==================================

const Article = require('../models/Article');
const AppError = require('../utils/AppError');

module.exports = async function requireAuthorOrAdmin(req, res, next) {
  try {
    const { id } = req.params;
    const article = await Article.findById(id);
    if (!article) return next(new AppError('Artykuł nie istnieje.', 404));

    const isOwner = String(article.author) === String(req.user._id);
    const isAdmin = req.user.role === 'admin';
    if (!isOwner && !isAdmin) {
      return next(new AppError('Brak uprawnień.', 403));
    }

    req.article = article;
    next();
  } catch (error) {
    next(error);
  }
};

==================================
middleware\sanitizeMiddleware.js v.2
==================================

const { sanitizeStrict } = require('../utils/sanitize');

const deepSanitize = (req, res, next) => {
  // Tylko dla bardzo podstawowej ochrony - NIE escapuj, tylko usuń najbardziej niebezpieczne
  const quickSanitize = (text) => {
    if (typeof text !== 'string') return text;

    // Usuń tylko najbardziej niebezpieczne rzeczy, ale nie escapuj całego HTML
    return text
      .replace(/javascript:/gi, '') // Usuń javascript:
      .replace(/on\w+=/gi, '') // Usuń atrybuty zdarzeń
      .substring(0, 1000); // Limit długości
  };

  // Sanityzacja parametrów URL
  if (req.params) {
    Object.keys(req.params).forEach((key) => {
      if (typeof req.params[key] === 'string') {
        req.params[key] = quickSanitize(req.params[key]);
      }
    });
  }

  // Sanityzacja query string
  if (req.query) {
    Object.keys(req.query).forEach((key) => {
      if (typeof req.query[key] === 'string') {
        req.query[key] = quickSanitize(req.query[key]);
      }
    });
  }

  // Sanityzacja body (dla JSON) - TUTAJ BARDZIEJ OSTROŻNIE
  if (req.body && typeof req.body === 'object') {
    const sanitizeObject = (obj) => {
      Object.keys(obj).forEach((key) => {
        if (typeof obj[key] === 'string') {
          // Dla username, email - użyj strict sanitization
          if (['username', 'email', 'password'].includes(key)) {
            obj[key] = sanitizeStrict(obj[key]);
          } else {
            // Dla innych pól - tylko podstawowe czyszczenie
            obj[key] = quickSanitize(obj[key]);
          }
        } else if (typeof obj[key] === 'object' && obj[key] !== null) {
          sanitizeObject(obj[key]);
        }
      });
    };
    sanitizeObject(req.body);
  }

  next();
};

module.exports = deepSanitize;


==================================
middleware\upload.js v.1
==================================

const multer = require('multer');
const path = require('path');

const storage = multer.diskStorage({
  destination: (_req, _file, cb) => {
    cb(null, path.join(__dirname, '..', 'uploads'));
  },
  filename: (_req, file, cb) => {
    const unique = Date.now() + '-' + Math.round(Math.random() * 1e9);
    const ext = path.extname(file.originalname || '');
    cb(null, `${unique}${ext}`);
  },
});

function fileFilter(_req, file, cb) {
  if (!file.mimetype || !file.mimetype.startsWith('image/')) {
    return cb(new Error('Dozwolone są tylko pliki graficzne.'), false);
  }
  cb(null, true);
}

const upload = multer({
  storage,
  fileFilter,
  limits: { fileSize: 5 * 1024 * 1024, files: 5 }, // 5MB, max 5 plików
});

module.exports = upload;

==================================
middleware\validateObjectId.js v.1
==================================

const mongoose = require('mongoose');
const AppError = require('../utils/AppError');

const validateObjectId = (paramName = 'id') => {
  return (req, res, next) => {
    const id = req.params[paramName];

    if (!mongoose.Types.ObjectId.isValid(id)) {
      return next(new AppError(`Nieprawidłowy format ID: ${id}`, 400));
    }

    next();
  };
};

module.exports = validateObjectId;

==================================
models\Article.js v.2
==================================

// models/Article.js v.2
const mongoose = require('mongoose');

const articleSchema = new mongoose.Schema(
  {
    title: {
      type: String,
      required: true,
      trim: true,
    },
    content: {
      type: String,
      required: true,
    },
    author: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User',
      required: true,
    },
    images: [{ type: String }],
    likes: [{ type: mongoose.Schema.Types.ObjectId, ref: 'User' }],
  },
  {
    timestamps: true,
  },
);

// Dodanie indeksów dla optymalizacji
articleSchema.index({ author: 1, createdAt: -1 }); // dla listy artykułów usera
articleSchema.index({ title: 'text', content: 'text' }); // dla wyszukiwania tekstowego

articleSchema.index({ title: 'text', content: 'text' }); // Full-text search
articleSchema.index({ author: 1, createdAt: -1 }); // Dla listy artykułów usera
articleSchema.index({ createdAt: -1 }); // Dla sortowania najnowszych
articleSchema.index({ likesCount: -1 }); // Dla najpopularniejszych

module.exports = mongoose.model('Article', articleSchema);


==================================
models\Comment.js v.2
==================================

// models/Comment.js v.2
const mongoose = require('mongoose');

const commentSchema = new mongoose.Schema({
  article: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Article',
    required: true,
    index: true, // ✅ Dodany indeks
  },
  author: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true,
  },
  text: {
    type: String,
    required: true,
    trim: true,
  },
  likes: [
    {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User',
    },
  ],
  createdAt: {
    type: Date,
    default: Date.now,
  },
});

commentSchema.index({ article: 1, createdAt: -1 }); // Komentarze dla artykułu
commentSchema.index({ author: 1 }); // Komentarze usera

module.exports = mongoose.model('Comment', commentSchema);


==================================
models\PendingUser.js v.1
==================================

// models/PendingUser.js v.2
const mongoose = require("mongoose");

const pendingUserSchema = new mongoose.Schema({
    username: {
        type: String,
        required: true,
        trim: true,
    },
    email: {
        type: String,
        required: true,
        unique: true,
        trim: true,
        lowercase: true,
        match: /^[\w.-]+@([\w-]+\.)+[\w-]{2,4}$/,
    },
    password: {
        type: String,
        required: true,
    },
    role: {
        type: String,
        enum: ["user", "author"],
        default: "user",
    },
    createdAt: {
        type: Date,
        default: Date.now,
        expires: 86400, // ✅ Automatyczne usuwanie po 24 godzinach
    },
});

module.exports = mongoose.model("PendingUser", pendingUserSchema);


==================================
models\User.js v.2
==================================

// models/User.js v.2
const mongoose = require('mongoose');
const bcrypt = require('bcryptjs');

const userSchema = new mongoose.Schema({
  username: {
    type: String,
    required: true,
    unique: true,
    trim: true,
  },
  email: {
    type: String,
    required: true,
    unique: true,
    lowercase: true,
    trim: true,
    match: [/^[^\s@]+@[^\s@]+\.[^\s@]+$/, 'Nieprawidłowy format adresu e-mail'],
    index: true, // ✅ Dodany indeks
  },
  password: {
    type: String,
    required: true,
    minlength: 6,
  },
  role: {
    type: String,
    enum: ['user', 'author', 'admin'],
    default: 'user',
  },
});

userSchema.pre('save', async function (next) {
  if (!this.isModified('password')) return next();

  const isBcrypt = typeof this.password === 'string' && /^\$2[aby]\$\d{2}\$[./A-Za-z0-9]{53}$/.test(this.password);
  if (isBcrypt) return next();

  const salt = await bcrypt.genSalt(10);
  this.password = await bcrypt.hash(this.password, salt);
  next();
});

userSchema.methods.comparePassword = async function (candidatePassword) {
  return await bcrypt.compare(candidatePassword, this.password);
};

userSchema.index({ email: 1 }, { unique: true }); // Już masz
userSchema.index({ username: 1 }, { unique: true }); // Już masz
userSchema.index({ createdAt: -1 }); // Dla listy użytkowników

module.exports = mongoose.model('User', userSchema);


==================================
package.json v.4
==================================

{
  "name": "cms-backend",
  "version": "1.0.0",
  "description": "",
  "main": "server.js",
  "scripts": {
    "start": "nodemon server.js",
    "dev": "node server.js",
    "test": "jest --config jest.config.js --verbose",
    "test:watch": "jest --config jest.config.js --watch",
    "test:coverage": "jest --config jest.config.js --coverage",
    "test:unit": "jest --testPathIgnorePatterns=\"integration\"",
    "test:integration": "jest --testPathPatterns=\"integration\" --verbose",
    "test:auth": "jest __tests__/integration/auth.test.js --verbose",
    "test:articles": "jest __tests__/integration/articles.test.js --verbose",
    "test:comments": "jest __tests__/integration/comments.test.js --verbose",
    "test:users": "jest __tests__/integration/users.test.js --verbose",
    "test:admin": "jest __tests__/integration/admin.test.js --verbose",
    "test:rateLimit": "jest __tests__/integration/rateLimit.test.js --verbose --testTimeout=30000",
    "lint": "eslint .",
    "lint:fix": "eslint . --fix",
    "format": "prettier --write .",
    "check-style": "npm run lint && npx prettier --check ."
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "engines": {
    "node": ">=18"
  },
  "dependencies": {
    "bcryptjs": "^3.0.2",
    "cookie-parser": "^1.4.7",
    "cors": "^2.8.5",
    "express": "^5.1.0",
    "express-rate-limit": "^8.0.1",
    "express-validator": "^7.2.1",
    "helmet": "^8.1.0",
    "jsonwebtoken": "^9.0.2",
    "mongoose": "^8.17.0",
    "multer": "^2.0.2",
    "nodemailer": "^7.0.5",
    "redis": "^5.8.2",
    "sanitize-html": "^2.17.0",
    "winston": "^3.17.0"
  },
  "devDependencies": {
    "@types/redis": "^4.0.10",
    "dotenv": "^17.2.1",
    "eslint": "^9.34.0",
    "eslint-config-prettier": "^10.1.8",
    "eslint-plugin-prettier": "^5.5.4",
    "globals": "^16.3.0",
    "jest": "^30.1.1",
    "mongodb-memory-server": "^10.2.0",
    "nodemon": "^3.1.10",
    "prettier": "^3.6.2",
    "supertest": "^7.1.4"
  }
}


==================================
routes\adminRoutes.js v.1
==================================

const express = require('express')
const router = express.Router()
const requireAuth = require('../middleware/authMiddleware')
const requireAdmin = require('../middleware/requireAdmin')

const {
  getPendingUsers,
  approveUser,
  rejectUser
} = require('../controllers/adminController')

router.get('/pending-users', requireAuth, requireAdmin, getPendingUsers)
router.post('/approve/:id', requireAuth, requireAdmin, approveUser)
router.delete('/reject/:id', requireAuth, requireAdmin, rejectUser)

module.exports = router

==================================
routes\articleRoutes.js v.2
==================================

const express = require('express');
const router = express.Router();
const { createArticle, getArticles, getArticleById, updateArticle, deleteArticle, toggleLikeArticle } = require('../controllers/articleController');
const upload = require('../middleware/upload');
const requireAuth = require('../middleware/authMiddleware');
const requireAuthorOrAdmin = require('../middleware/requireAuthorOrAdmin');
const validateObjectId = require('../middleware/validateObjectId');
const { validateArticle } = require('../utils/advancedValidate');
const { cacheMiddleware } = require('../middleware/cacheMiddleware');

// Lista i pojedynczy artykuł
router.get('/', cacheMiddleware(300), getArticles); // 5 minut cache
router.get('/:id', validateObjectId(), cacheMiddleware(600), getArticleById); // 10 minut cache

// Tworzenie / edycja / usuwanie (z autoryzacją)
router.post('/', requireAuth, upload.array('images', 5), validateArticle, createArticle); // ✅
router.put('/:id', validateObjectId(), requireAuth, requireAuthorOrAdmin, upload.array('images', 5), validateArticle, updateArticle); // ✅
router.delete('/:id', validateObjectId(), requireAuth, requireAuthorOrAdmin, deleteArticle); // DODANE

// Lajk artykułu
router.post('/:id/like', validateObjectId(), requireAuth, toggleLikeArticle); // DODANE

module.exports = router;


==================================
routes\authRoutes.js v.1
==================================

// routes/authRoutes.js v.2
const express = require("express");
const router = express.Router();
const { login, logout, registerPending } = require("../controllers/authController");
const { validateRegister, validateLogin } = require("../utils/advancedValidate"); // ✅ DODANE

// Logowanie
router.post("/login", validateLogin, login); // ✅ DODANA WALIDACJA

// Wylogowanie
router.post("/logout", logout);

// Rejestracja
router.post("/register-pending", validateRegister, registerPending); // ✅ DODANA WALIDACJA

module.exports = router;


==================================
routes\commentRoutes.js v.1
==================================

const express = require("express");
const router = express.Router();
const { addComment, getComments, deleteComment, updateComment } = require("../controllers/commentController");
const requireAuth = require("../middleware/authMiddleware");
const validateObjectId = require("../middleware/validateObjectId");
const { validateComment } = require("../utils/advancedValidate"); // ✅ DODANE

// Komentarze do artykułu (id = articleId)
router.get("/:id", validateObjectId(), getComments); // DODANE
router.post("/:id", validateObjectId(), requireAuth, validateComment, addComment); // ✅

// Operacje na konkretnym komentarzu (id = commentId)
router.put("/:id", validateObjectId(), requireAuth, validateComment, updateComment); // ✅
router.delete("/:id", validateObjectId(), requireAuth, deleteComment);

module.exports = router;


==================================
routes\userRoutes.js v.1
==================================

const express = require("express");
const router = express.Router();
const requireAuth = require("../middleware/authMiddleware");
const requireAdmin = require("../middleware/requireAdmin");
const { getProfile, updateProfile, changePassword, listUsers, changeRole, deleteUser } = require("../controllers/userController");
const { validateUserUpdate } = require("../utils/advancedValidate"); // ✅ DODANE (trzeba dodać do advancedValidate)

// Profil zalogowanego użytkownika
router.get("/profile", requireAuth, getProfile);
router.put("/profile", requireAuth, validateUserUpdate, updateProfile);
router.put("/password", requireAuth, changePassword);

// Admin – tylko dla roli 'admin'
router.get("/", requireAuth, requireAdmin, listUsers);
router.put("/:id/role", requireAuth, requireAdmin, changeRole);
router.delete("/:id", requireAuth, requireAdmin, deleteUser);

module.exports = router;


==================================
scripts\createIndexes.js v.1
==================================

// scripts/createIndexes.js
const mongoose = require('mongoose');
require('dotenv').config();

const createIndexes = async () => {
  try {
    await mongoose.connect(process.env.MONGO_URI);
    
    console.log('🗄️ Tworzenie indeksów...');
    
    // Wymuś tworzenie indeksów
    const Article = require('../models/Article');
    const Comment = require('../models/Comment');
    const User = require('../models/User');
    
    await Article.createIndexes();
    await Comment.createIndexes(); 
    await User.createIndexes();
    
    console.log('✅ Indeksy stworzone pomyślnie');
    process.exit(0);
  } catch (error) {
    console.error('❌ Błąd tworzenia indeksów:', error);
    process.exit(1);
  }
};

createIndexes();

==================================
server.js v.6
==================================

const express = require('express');
const mongoose = require('mongoose');
const dotenv = require('dotenv');
const helmet = require('helmet');
const cookieParser = require('cookie-parser');
const cors = require('cors');
const path = require('path');
const logger = require('./utils/logger');
const deepSanitize = require('./middleware/sanitizeMiddleware');
const cspMiddleware = require('./middleware/cspMiddleware');
const redisClient = require('./utils/redisClient');
const { cacheMiddleware } = require('./middleware/cacheMiddleware');
const performanceMiddleware = require('./middleware/performanceMiddleware');

// 🎯 POPRAWIONE: JEDEN import limitersów
const {
  globalLimiter,
  authLimiter,
  adminLimiter,
} = require('./middleware/rateLimit');

// 🎯 DODANE: Import memory server dla testów
const { MongoMemoryServer } = require('mongodb-memory-server');

dotenv.config();
const app = express();

// Środowisko
const PORT = process.env.PORT || 5000;
let MONGO_URI = process.env.MONGO_URI;

// 🎯 DODANE: Zmienna dla memory server
let mongoServer;

// 🎯 DODANE: Funkcja inicjalizacji testowej bazy
const initializeTestDatabase = async () => {
  if (process.env.NODE_ENV === 'test') {
    mongoServer = await MongoMemoryServer.create();
    MONGO_URI = mongoServer.getUri();
    logger.info(`🧪 Test MongoDB URI: ${MONGO_URI}`);
  }
};

// 🎯 DODANE: Funkcja czyszczenia testowej bazy
const cleanupTestDatabase = async () => {
  if (process.env.NODE_ENV === 'test' && mongoServer) {
    await mongoose.disconnect();
    await mongoServer.stop();
    logger.info('🧪 Test MongoDB stopped');
  }
};

// Middleware
app.use(helmet());
app.use(performanceMiddleware);
app.use(cspMiddleware);
if (process.env.NODE_ENV !== 'test') {
  app.use(deepSanitize);
}
app.use(express.json());
app.use(cookieParser());

const ALLOWED_ORIGINS = ['http://localhost:3000'];

const corsOptions = {
  origin: (origin, cb) => {
    if (!origin || ALLOWED_ORIGINS.includes(origin)) {
      cb(null, true);
    } else {
      cb(new Error('Not allowed by CORS'));
    }
  },
  credentials: true,
};

app.use(cors(corsOptions));

// 🎯 ZMIENIONE: Nowa konfiguracja rate limiting
app.use('/api/auth', authLimiter); // 🎯 NOWY limiter dla auth
app.use('/api/admin', adminLimiter); // 🎯 NOWY limiter dla admin
app.use(globalLimiter); // 🎯 NOWY globalny limiter

// Statyczne pliki (obrazki)
app.use(
  '/uploads',
  express.static(path.join(__dirname, 'uploads'), {
    setHeaders: (res) => {
      res.setHeader('Cross-Origin-Resource-Policy', 'cross-origin');
    },
  }),
);

// Trasy API
app.use('/api/auth', require('./routes/authRoutes'));
app.use('/api/articles', require('./routes/articleRoutes'));
app.use('/api/comments', require('./routes/commentRoutes'));
app.use('/api/users', require('./routes/userRoutes'));
app.use('/api/admin', require('./routes/adminRoutes'));

// 404 – brak trasy
app.use((req, res) => {
  res.status(404).json({ message: 'Nie znaleziono endpointu.' });
});

// Globalny error handler
app.use((err, req, res, _next) => {
  if (err && err.code === 'LIMIT_FILE_SIZE') {
    return res.status(413).json({ message: 'Za duży plik. Limit 5MB.' });
  }
  if (
    err &&
    err.message &&
    /pliki graficzne|plik[ów]* graficzny|image/i.test(err.message)
  ) {
    return res
      .status(400)
      .json({ message: 'Dozwolone są tylko pliki graficzne.' });
  }

  err.statusCode = err.statusCode || 500;
  err.status = err.status || 'error';

  if (process.env.NODE_ENV === 'development') {
    logger.error('ERROR 💥:', err);
    return res.status(err.statusCode).json({
      status: err.status,
      error: err,
      message: err.message,
      stack: err.stack,
    });
  }

  if (err.isOperational) {
    return res.status(err.statusCode).json({
      status: err.status,
      message: err.message,
    });
  } else {
    logger.error('ERROR 💥:', err);
    return res.status(500).json({
      status: 'error',
      message: 'Coś poszło nie tak!',
    });
  }
});

// Inicjalizacja Redis przy starcie
const initRedis = async () => {
  try {
    await redisClient.connect();
    console.log('✅ Redis connected');
  } catch (error) {
    console.log('❌ Redis not available, continuing without cache');
  }
};

// 🎯 ZMODYFIKOWANE: Funkcja startu serwera
const startServer = async () => {
  try {
    // Inicjalizuj testową bazę jeśli potrzeba
    await initializeTestDatabase();

    // Inicjalizacja Redis
    await initRedis();

    // Połączenie z MongoDB
    await mongoose.connect(MONGO_URI, {});
    logger.info('✅ Połączono z MongoDB');

    const conn = mongoose.connection;
    logger.info(`📦 Baza: ${conn.name}`);
    logger.info(`🌐 Host: ${conn.host}`);

    // Uruchom serwer tylko jeśli nie jesteśmy w testach
    if (process.env.NODE_ENV !== 'test') {
      app.listen(PORT, () => logger.info(`🚀 Serwer działa na porcie ${PORT}`));
    }
  } catch (err) {
    logger.error('❌ Błąd uruchamiania serwera:', err);

    // Sprzątanie testowej bazy w przypadku błędu
    await cleanupTestDatabase();
    process.exit(1);
  }
};

// 🎯 DODANE: Eksport app dla testów Supertest
if (process.env.NODE_ENV === 'test') {
  module.exports = { app, startServer, cleanupTestDatabase };
} else {
  // Standardowe uruchomienie
  startServer();
}

// 🎯 DODANE: Obsługa graceful shutdown
process.on('SIGINT', async () => {
  logger.info('🛑 Zamykanie serwera...');
  await redisClient.disconnect();
  await cleanupTestDatabase();
  process.exit(0);
});

process.on('SIGTERM', async () => {
  logger.info('🛑 Zamykanie serwera (SIGTERM)...');
  await redisClient.disconnect();
  await cleanupTestDatabase();
  process.exit(0);
});


==================================
services\articleService.js v.3
==================================

// services/articleService.js
const logger = require('../utils/logger');
const Article = require('../models/Article');
const Comment = require('../models/Comment');
const fs = require('fs');
const path = require('path');
const { sanitizeTitle, sanitizeBody } = require('../utils/sanitize');
const validateFields = require('../utils/validate');

const UPLOADS_DIR = path.join(__dirname, '..', 'uploads');

// Helper functions
function toPublicPath(p) {
  if (!p) return null;
  const s = String(p).replace(/\\/g, '/');
  if (s.startsWith('uploads/')) return s;
  const m = s.match(/uploads\/(.+)$/i);
  return m ? `uploads/${m[1]}` : `uploads/${path.basename(s)}`;
}

function toUploadsRel(p) {
  if (!p) return '';
  const s = String(p);
  const m = s.match(/uploads[/\\]+(.+)$/i);
  return m ? m[1] : path.basename(s);
}

// Create article
const createArticle = async (title, content, authorId, imagePaths) => {
  const errors = validateFields({
    title: [title, 'Tytuł jest wymagany'],
    content: [content, 'Treść jest wymagana'],
  });

  if (title && title.length < 5)
    errors.push('Tytuł musi mieć co najmniej 5 znaków');
  if (content && content.length < 20)
    errors.push('Treść musi mieć co najmniej 20 znaków');
  if (errors.length) throw new Error(errors.join(' '));

  const sanitizedTitle = sanitizeTitle(title);
  const sanitizedContent = sanitizeBody(content);

  const newArticle = new Article({
    title: sanitizedTitle,
    content: sanitizedContent,
    images: imagePaths,
    author: authorId,
  });

  console.log('RAW TITLE:', title);
  console.log('SANITIZED TITLE:', sanitizeTitle(title));

  await newArticle.save();
  return newArticle;
};

// Get articles with filtering, sorting, and pagination - ZOPTYMALIZOWANE
const getArticles = async (page = 1, limit = 5, search = '', sort = 'newest') => {
  const skip = (parseInt(page) - 1) * parseInt(limit);

  // ✅ ZOPTYMALIZOWANE: Build query with full-text search if available
  const query = search 
    ? { $text: { $search: search } } // ✅ Uses full-text index
    : {};

  // ✅ ZOPTYMALIZOWANE: Sort options that use indexes
  const sortOptions = {
    newest: { createdAt: -1 }, // ✅ Uses index
    oldest: { createdAt: 1 },  // ✅ Uses index  
    mostLiked: { likesCount: -1 }, // ✅ Uses index
    titleAZ: { title: 1, createdAt: -1 }, // ✅ Uses compound index
    titleZA: { title: -1, createdAt: -1 }, // ✅ Uses compound index
  };

  // ✅ ZOPTYMALIZOWANE: Use Promise.all for parallel execution
  const [articles, total] = await Promise.all([
    Article.find(query)
      .select('title content author images createdAt likes') // ✅ Only needed fields
      .populate('author', 'email username') // ✅ Only needed author fields
      .sort(sortOptions[sort] || sortOptions.newest)
      .skip(skip)
      .limit(parseInt(limit))
      .lean(), // ✅ Faster data return
    
    Article.countDocuments(query),
  ]);

  // ✅ ZOPTYMALIZOWANE: Parallel comment counts
  const articlesWithCounts = await Promise.all(
    articles.map(async (article) => {
      const commentCount = await Comment.countDocuments({ article: article._id });
      return {
        ...article,
        likesCount: Array.isArray(article.likes) ? article.likes.length : 0,
        commentCount,
        thumbnail: article.images && article.images.length > 0
          ? toPublicPath(article.images[0])
          : null,
      };
    }),
  );

  return { articles: articlesWithCounts, total };
};

// Get article by ID - ZOPTYMALIZOWANE
const getArticleById = async (id) => {
  // ✅ ZOPTYMALIZOWANE: Single query with projection
  const article = await Article.findById(id)
    .select('-__v') // ✅ Exclude unnecessary fields
    .populate('author', 'username email') // ✅ Only needed author fields
    .lean(); // ✅ Faster data return

  if (!article) throw new Error('Nie znaleziono artykułu');

  // ✅ ZOPTYMALIZOWANE: Parallel comment count
  const [commentCount] = await Promise.all([
    Comment.countDocuments({ article: article._id }),
  ]);

  return {
    ...article,
    images: Array.isArray(article.images) ? article.images.map(toPublicPath) : [],
    commentCount,
  };
};

// Update article
const updateArticle = async (articleId, updateData, userId, userRole, files) => {
  const { title, content, removeImages } = updateData;
  const article = await Article.findById(articleId);
  if (!article) throw new Error('Artykuł nie znaleziony');

  // Check permissions
  if (String(article.author) !== String(userId) && userRole !== 'admin') {
    throw new Error('Brak uprawnień do edycji');
  }

  // Handle image removal
  let imagesToRemove = [];
  if (typeof removeImages === 'string') imagesToRemove = [removeImages];
  else if (Array.isArray(removeImages)) imagesToRemove = removeImages;

  const normalizedToRemove = imagesToRemove.map(toUploadsRel);

  // Remove images from disk
  for (const rel of normalizedToRemove) {
    const full = path.join(UPLOADS_DIR, rel);
    if (full.startsWith(UPLOADS_DIR)) {
      fs.unlink(full, (err) => {
        if (err && err.code !== 'ENOENT') {
          logger.error(`Błąd usuwania pliku: ${full}`, err);
        }
      });
    }
  }

  // Update article images
  article.images = (article.images || []).filter((img) => {
    const rel = toUploadsRel(img);
    return !normalizedToRemove.includes(rel);
  });

  // Add new images
  if (files && files.length > 0) {
    const newImages = files.map((f) =>
      `uploads/${f.filename}`.replace(/\\/g, '/'),
    );
    article.images.push(...newImages);
  }

  // Validate and update title and content
  const errors = [];
  if (title) {
    if (title.length < 5) errors.push('Tytuł musi mieć co najmniej 5 znaków');
    else article.title = sanitizeTitle(title);
  }
  if (content) {
    if (content.length < 20) errors.push('Treść musi mieć co najmniej 20 znaków');
    else article.content = sanitizeBody(content);
  }
  if (errors.length) throw new Error(errors.join(' '));

  await article.save();
  return article;
};

// Delete article
const deleteArticle = async (articleId, userId, userRole) => {
  const article = await Article.findById(articleId);
  if (!article) throw new Error('Artykuł nie istnieje');

  if (String(article.author) !== String(userId) && userRole !== 'admin') {
    throw new Error('Brak uprawnień');
  }

  // Remove images from disk
  for (const img of article.images || []) {
    const rel = toUploadsRel(img);
    const full = path.join(UPLOADS_DIR, rel);
    if (full.startsWith(UPLOADS_DIR)) {
      fs.unlink(full, (err) => {
        if (err && err.code !== 'ENOENT') {
          logger.error(`Błąd usuwania pliku ${full}:`, err);
        }
      });
    }
  }

  // ✅ ZOPTYMALIZOWANE: Parallel operations
  await Promise.all([
    Comment.deleteMany({ article: article._id }),
    article.deleteOne(),
  ]);
};

// Toggle like on article
const toggleLikeArticle = async (articleId, userId) => {
  const article = await Article.findById(articleId);
  if (!article) throw new Error('Artykuł nie znaleziony');

  // Author cannot like their own article
  if (article.author && String(article.author) === String(userId)) {
    throw new Error('Autor nie może polubić własnego artykułu');
  }

  const alreadyLiked =
    Array.isArray(article.likes) &&
    article.likes.some((id) => String(id) === String(userId));

  if (alreadyLiked) article.likes.pull(userId);
  else article.likes.push(userId);

  await article.save();

  return {
    liked: !alreadyLiked,
    totalLikes: Array.isArray(article.likes) ? article.likes.length : 0,
  };
};

module.exports = {
  createArticle,
  getArticles,
  getArticleById,
  updateArticle,
  deleteArticle,
  toggleLikeArticle,
};

==================================
services\authService.js v.1
==================================

const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const User = require('../models/User');
const PendingUser = require('../models/PendingUser');
const validateFields = require('../utils/validate');

// Register pending user
const registerPending = async (username, email, password, role) => {
  const errors = validateFields({
    username: [username, 'Nazwa użytkownika jest wymagana.'],
    email: [email, 'Email jest wymagany.'],
    password: [password, 'Hasło jest wymagane.'],
    role: [role, 'Rola jest wymagana.'],
  });
  if (errors.length > 0) throw new Error(errors.join(' '));

  const exists = await PendingUser.findOne({ email });
  const existsReal = await User.findOne({ email });
  if (exists || existsReal) throw new Error('Email jest już zajęty.');

  const pendingUser = new PendingUser({ username, email, password, role });
  await pendingUser.save();
};

// Login user
const login = async (email, password) => {
  const errors = validateFields({
    email: [email, 'Email jest wymagany.'],
    password: [password, 'Hasło jest wymagane.'],
  });
  if (errors.length > 0) throw new Error(errors.join(' '));

  const user = await User.findOne({ email });
  if (!user) throw new Error('Nieprawidłowy email lub hasło.');

  const isMatch = await bcrypt.compare(password, user.password);
  if (!isMatch) throw new Error('Nieprawidłowy email lub hasło.');

  const token = jwt.sign({ id: user._id }, process.env.JWT_SECRET, { expiresIn: '1d' });
  return token;
};

module.exports = {
  registerPending,
  login,
};

==================================
services\commentService.js v.3
==================================

const Comment = require('../models/Comment');
const Article = require('../models/Article');
const validateFields = require('../utils/validate');
const { sanitizeComment } = require('../utils/sanitize');

// Add comment
const addComment = async (articleId, authorId, rawText) => {
  // 1. Walidacja podstawowa
  const errors = validateFields({
    text: [rawText, 'Komentarz nie może być pusty.'],
  });
  if (errors.length) throw new Error(errors.join(' '));

  // 2. Sanityzacja
  const sanitizedText = sanitizeComment(rawText || '');

  // 3. Walidacja po sanityzacji - sprawdź czy nie został pusty string
  const plainText = sanitizedText.replace(/<[^>]+>/g, '').trim();
  if (!plainText) {
    throw new Error(
      'Komentarz jest pusty po odfiltrowaniu niebezpiecznych elementów.',
    );
  }

  // 4. Walidacja długości - DODAJ TEN WARUNEK
  if (plainText.length < 6) {
    throw new Error('Komentarz musi mieć co najmniej 6 znaków.');
  }

  // Check if article exists
  const article = await Article.findById(articleId);
  if (!article) throw new Error('Nie znaleziono artykułu.');

  const comment = await Comment.create({
    text: sanitizedText,
    article: articleId,
    author: authorId,
  });

  return comment;
};

// Get comments for article
const getComments = async (articleId) => {
  const comments = await Comment.find({ article: articleId })
    .populate('author', 'username')
    .sort({ createdAt: -1 });

  return comments;
};

// Update comment
const updateComment = async (commentId, userId, userRole, newText) => {
  // Basic validation
  if (newText == null || String(newText).trim() === '') {
    throw new Error('Komentarz nie może być pusty.');
  }

  // Sanitize + validation
  const text = sanitizeComment(newText);
  const plain = text.replace(/<[^>]+>/g, '').trim();
  if (!plain) {
    throw new Error(
      'Komentarz jest pusty po odfiltrowaniu niebezpiecznych elementów.',
    );
  }
  if (plain.length < 6) {
    throw new Error('Komentarz musi mieć co najmniej 6 znaków.');
  }

  const comment = await Comment.findById(commentId);
  if (!comment) throw new Error('Komentarz nie istnieje.');

  const isAuthor = String(comment.author) === String(userId);
  const isAdmin = userRole === 'admin';
  if (!isAuthor && !isAdmin)
    throw new Error('Brak uprawnień do edycji komentarza.');

  comment.text = text;
  await comment.save();

  return comment;
};

// Delete comment
const deleteComment = async (commentId, userId, userRole) => {
  const comment = await Comment.findById(commentId);
  if (!comment) throw new Error('Komentarz nie istnieje.');

  const isAuthor = String(comment.author) === String(userId);
  const isAdmin = userRole === 'admin';
  if (!isAuthor && !isAdmin)
    throw new Error('Brak uprawnień do usunięcia komentarza.');

  await comment.deleteOne();
};

module.exports = {
  addComment,
  getComments,
  updateComment,
  deleteComment,
};


==================================
services\userService.js v.1
==================================

const bcrypt = require('bcryptjs');
const User = require('../models/User');
const validateFields = require('../utils/validate');
const sanitize = require('sanitize-html');

// Get user profile
const getProfile = async (userId) => {
  const user = await User.findById(userId).select('-password');
  if (!user) throw new Error('Użytkownik nie istnieje');
  return user;
};

// Update user profile
const updateProfile = async (userId, updateData) => {
  let { username } = updateData;
  const errors = [];

  if (username != null) {
    username = String(username).trim();
    if (username.length < 3) errors.push('Nazwa użytkownika musi mieć co najmniej 3 znaki.');
  }

  if (errors.length) throw new Error(errors.join(' '));

  const user = await User.findById(userId);
  if (!user) throw new Error('Użytkownik nie istnieje');

  if (username != null) user.username = sanitize(username);
  await user.save();

  const safeUser = user.toObject();
  delete safeUser.password;
  return safeUser;
};

// Change password
const changePassword = async (userId, oldPassword, newPassword) => {
  const errors = validateFields({
    oldPassword: [oldPassword, 'Stare hasło jest wymagane.'],
    newPassword: [newPassword, 'Nowe hasło jest wymagane.'],
  });

  if (newPassword && String(newPassword).length < 6) {
    errors.push('Nowe hasło musi mieć co najmniej 6 znaków.');
  }

  if (errors.length) throw new Error(errors.join(' '));

  const user = await User.findById(userId);
  if (!user) throw new Error('Użytkownik nie istnieje');

  const isMatch = await bcrypt.compare(String(oldPassword), user.password);
  if (!isMatch) throw new Error('Stare hasło jest nieprawidłowe.');

  user.password = await bcrypt.hash(String(newPassword), 10);
  await user.save();
};

// Admin: List all users
const listUsers = async () => {
  const users = await User.find({}).select('-password').sort({ createdAt: -1 });
  return users;
};

// Admin: Change user role
const changeRole = async (userId, role) => {
  // ✅ POPRAWIONE: Używamy zmiennej errors
  const errors = validateFields({
    role: [role, 'Rola jest wymagana.'],
  });

  if (errors.length) {
    throw new Error(errors.join(' '));
  }

  const allowedRoles = ['user', 'author', 'admin'];
  if (!allowedRoles.includes(String(role))) {
    throw new Error('Nieprawidłowa rola.');
  }

  const user = await User.findById(userId);
  if (!user) throw new Error('Użytkownik nie istnieje.');

  user.role = role;
  await user.save();

  const safeUser = user.toObject();
  delete safeUser.password;
  return safeUser;
};

// Admin: Delete user
const deleteUser = async (userId) => {
  const user = await User.findById(userId);
  if (!user) throw new Error('Użytkownik nie istnieje.');

  await user.deleteOne();
};

module.exports = {
  getProfile,
  updateProfile,
  changePassword,
  listUsers,
  changeRole,
  deleteUser,
};

==================================
uploads\1754068886780-2025-05-08_17-46-27(1)-01.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1754152749228-92812186_3218584588186739_8353233957860409344_n.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1754156567535-92989817_3218584841520047_9082093743397404672_n.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1754241925862-92989817_3218584841520047_9082093743397404672_n.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1754310977682-92812186_3218584588186739_8353233957860409344_n.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1754310977688-92948159_3218584998186698_4977806751773491200_n.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1754310977693-92989817_3218584841520047_9082093743397404672_n.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1754310977698-93254356_3218584681520063_688158527956451328_n.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1754310977702-93303604_3218584784853386_6430330249937944576_n.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1754332478792-93254356_3218584681520063_688158527956451328_n.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1754332492051-93254356_3218584681520063_688158527956451328_n.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1754332582184-93303604_3218584784853386_6430330249937944576_n.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1754332738296-92948159_3218584998186698_4977806751773491200_n.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1754332774555-92989817_3218584841520047_9082093743397404672_n.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1754367503118-93303604_3218584784853386_6430330249937944576_n.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1754387409764-92948159_3218584998186698_4977806751773491200_n.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1754462018664-415954181.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1754462123958-301796897.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1754462384224-743992369.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1754462515056-53701265.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1754466490832-679145436.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1754487751546-136461086.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1754487788362-92598928.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1754487826811-398469964.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1754487826814-856807431.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1754487826816-273726342.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1754488665308-463888655.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1754491303538-69773656.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1754497317961-377443572.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1754497317966-945997040.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1756234408292-979512228.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1756318975759-173818095.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1756657307658-499081012.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1756657756825-346829626.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1756660214711-314048676.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1756660258451-415853295.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1756666053549-600682487.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1756666082989-109778181.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1756744162941-217753623.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1756744538323-605333134.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1756744538482-68374677.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1756745272824-824896344.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1756745273002-44688382.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1756745273027-493877727.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1756745811922-747871621.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1756745812075-501152157.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1756745812104-105262893.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1756745873396-210006023.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1756745873555-546599603.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1756745873579-506963760.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1756746218568-965732117.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1756746218719-971552728.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1756746218745-850609998.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1756746282522-535178564.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1756746282682-616618260.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1756746282706-178996590.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1756746481683-500058792.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1756746481836-337460984.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1756746481860-936692384.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1756746538450-581221730.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1756746538604-660689319.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1756746538627-560811603.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1756746717467-978772927.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1756746717622-669638575.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1756746717647-904674377.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1756746804710-597519531.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1756746804864-726654006.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1756746804888-908441161.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1756748436539-837513395.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1756748436697-184509137.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1756748436720-644344373.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1756748591145-616193290.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1756748591309-857443350.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1756748591334-436700840.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1756748903181-441438040.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1756748903362-64697141.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1756748903398-813462936.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1756749131394-563604330.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1756749131579-114911805.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1756749131608-175554828.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1756749401413-295028329.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1756749401601-994645613.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1756749401629-433218701.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1756749668873-273283291.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1756749669055-329166563.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1756749669083-769996504.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1756751265309-698354318.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1756751265493-994886699.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1756751265523-985679947.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1756751529000-357944819.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1756751529185-646635373.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1756751529216-246750683.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1756752724739-505985337.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1756752724922-289345804.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1756752724949-104778983.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1756752753654-358592865.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1756752754940-59077898.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1756752755119-712420293.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
uploads\1756752755148-159481951.jpg v.1
==================================

<plik binarny, nie wyświetlono zawartości>

==================================
utils\AppError.js v.1
==================================

// utils/AppError.js v.1
class AppError extends Error {
  constructor(message, statusCode) {
    super(message);
    this.statusCode = statusCode;
    this.status = `${statusCode}`.startsWith('4') ? 'fail' : 'error';
    this.isOperational = true;

    Error.captureStackTrace(this, this.constructor);
  }
}

module.exports = AppError;

==================================
utils\advancedValidate.js v.2
==================================

// utils/advancedValidate.js v.2
const { validationResult, body } = require('express-validator');

// Middleware do obsługi błędów walidacji
const handleValidationErrors = (req, res, next) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    const errorMessages = errors.array().map((error) => error.msg);
    return res.status(400).json({
      status: 'fail',
      message: errorMessages.join(' '),
    });
  }
  next();
};

// Walidacja rejestracji
const validateRegister = [
  body('username')
    .isLength({ min: 3 })
    .withMessage('Nazwa użytkownika musi mieć co najmniej 3 znaki')
    .trim(),
  body('email')
    .isEmail()
    .withMessage('Podaj prawidłowy adres email')
    .normalizeEmail(),
  body('password')
    .isLength({ min: 6 })
    .withMessage('Hasło musi mieć co najmniej 6 znaków'),
  body('role').isIn(['user', 'author']).withMessage('Nieprawidłowa rola'),
  handleValidationErrors,
];

// Walidacja logowania
const validateLogin = [
  body('email')
    .isEmail()
    .withMessage('Podaj prawidłowy adres email')
    .normalizeEmail(),
  body('password').notEmpty().withMessage('Hasło jest wymagane'),
  handleValidationErrors,
];

// Walidacja artykułu
const validateArticle = [
  body('title')
    .isLength({ min: 5 })
    .withMessage('Tytuł musi mieć co najmniej 5 znaków')
    .trim(),
  body('content')
    .isLength({ min: 20 })
    .withMessage('Treść musi mieć co najmniej 20 znaków')
    .trim(),
  handleValidationErrors,
];

// Walidacja komentarza
const validateComment = [
  body('text')
    .isLength({ min: 6 })
    .withMessage('Komentarz musi mieć co najmniej 6 znaków')
    .trim(),
  handleValidationErrors,
];

// Walidacja zmiany hasła
const validatePasswordChange = [
  body('oldPassword').notEmpty().withMessage('Stare hasło jest wymagane'),
  body('newPassword')
    .isLength({ min: 6 })
    .withMessage('Nowe hasło musi mieć co najmniej 6 znaków'),
  handleValidationErrors,
];

// Walidacja zmiany roli (admin)
const validateRoleChange = [
  body('role')
    .isIn(['user', 'author', 'admin'])
    .withMessage('Nieprawidłowa rola'),
  handleValidationErrors,
];

// Walidacja update'u usera
const validateUserUpdate = [
  body('username')
    .optional()
    .isLength({ min: 3 })
    .withMessage('Nazwa użytkownika musi mieć co najmniej 3 znaki')
    .trim(),
  handleValidationErrors,
];

module.exports = {
  validateRegister,
  validateLogin,
  validateArticle,
  validateComment,
  validatePasswordChange,
  validateRoleChange,
  validateUserUpdate,
  handleValidationErrors,
};


==================================
utils\emailTemplates.js v.1
==================================

// utils/emailTemplates.js
const { APP_NAME = 'CMS' } = process.env

function approvedUserEmail({ username }) {
  const subject = `[${APP_NAME}] Twoje konto zostało zatwierdzone`
  const text = `Cześć ${username || ''},

Twoje konto w ${APP_NAME} zostało zatwierdzone. Możesz się teraz zalogować.

Pozdrawiamy,
Zespół ${APP_NAME}
`
  const html = `
  <p>Cześć ${username || ''},</p>
  <p>Twoje konto w <b>${APP_NAME}</b> zostało <b>zatwierdzone</b>. Możesz się teraz zalogować.</p>
  <p>Pozdrawiamy,<br>Zespół ${APP_NAME}</p>
  `
  return { subject, text, html }
}

function rejectedUserEmail({ username }) {
  const subject = `[${APP_NAME}] Wniosek rejestracyjny odrzucony`
  const text = `Cześć ${username || ''},

Niestety Twój wniosek rejestracyjny do ${APP_NAME} został odrzucony.

Pozdrawiamy,
Zespół ${APP_NAME}
`
  const html = `
  <p>Cześć ${username || ''},</p>
  <p>Niestety Twój wniosek rejestracyjny do <b>${APP_NAME}</b> został odrzucony.</p>
  <p>Pozdrawiamy,<br>Zespół ${APP_NAME}</p>
  `
  return { subject, text, html }
}

module.exports = { approvedUserEmail, rejectedUserEmail }


==================================
utils\logger.js v.1
==================================

// utils/logger.js
const winston = require('winston');
const path = require('path');

// Definiuj format logów dla developmentu (kolorowy, czytelny)
const devFormat = winston.format.combine(
  winston.format.colorize(),
  winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
  winston.format.printf(({ timestamp, level, message, ...meta }) => {
    let metaStr = '';
    if (Object.keys(meta).length > 0) {
      metaStr = JSON.stringify(meta, null, 2);
    }
    return `${timestamp} [${level}]: ${message} ${metaStr}`;
  })
);

// Definiuj format logów dla productionu (JSON, strukturalny)
const prodFormat = winston.format.combine(
  winston.format.timestamp(),
  winston.format.json() // Loguje jako JSON dla łatwego parsowania
);

// Określ, który format użyć w zależności od środowiska
const format = process.env.NODE_ENV === 'production' ? prodFormat : devFormat;

// Konfiguruj transporty (gdzie logować)
const transports = [
  // Zawsze loguj do konsoli
  new winston.transports.Console(),
];

// W production dodaj również logowanie do pliku errors.log
if (process.env.NODE_ENV === 'production') {
  transports.push(
    new winston.transports.File({
      filename: path.join(__dirname, '..', 'logs', 'errors.log'),
      level: 'error', // Loguj tylko błędy do tego pliku
      maxsize: 5242880, // 5MB
      maxFiles: 5,
    })
  );
  // Możesz dodać też transport dla wszystkich logów
  // transports.push(new winston.transports.File({ filename: 'logs/combined.log' }));
}

// Utwórz i eksportuj instancję loggera
const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info', // Poziom logowania (np. 'debug', 'error')
  format: format,
  transports: transports,
});

module.exports = logger;

==================================
utils\mailer.js v.1
==================================

// utils/mailer.js
const nodemailer = require('nodemailer')

const {
  SMTP_HOST,
  SMTP_PORT,
  SMTP_SECURE,
  SMTP_USER,
  SMTP_PASS,
  MAIL_FROM = 'no-reply@example.com'
} = process.env

// pojedynczy transport – wielokrotne użycie
const transporter = nodemailer.createTransport({
  host: SMTP_HOST,
  port: Number(SMTP_PORT) || 587,
  secure: String(SMTP_SECURE) === 'true',
  auth: SMTP_USER && SMTP_PASS ? { user: SMTP_USER, pass: SMTP_PASS } : undefined
})

// prosta funkcja wysyłki
async function sendMail({ to, subject, text, html }) {
  if (!to) throw new Error('Brak adresata (to)')
  const info = await transporter.sendMail({
    from: MAIL_FROM,
    to,
    subject,
    text,
    html
  })
  return info
}

module.exports = { sendMail, transporter }


==================================
utils\queryLogger.js v.1
==================================

// utils/queryLogger.js
const mongoose = require('mongoose');

// Włącz logging zapytań MongoDB
mongoose.set('debug', function(coll, method, query, doc) {
  console.log(`🗄️ MongoDB Query: ${coll}.${method}`, {
    query: JSON.stringify(query),
    doc: doc ? JSON.stringify(doc) : undefined,
  });
});

module.exports = mongoose;

==================================
utils\redisClient.js v.1
==================================

// utils/redisClient.js
const redis = require('redis');

class RedisClient {
  constructor() {
    this.client = null;
    this.isConnected = false;
  }

  async connect() {
    if (this.client) return this.client;

    try {
      this.client = redis.createClient({
        url: process.env.REDIS_URL || 'redis://localhost:6379',
        socket: {
          reconnectStrategy: (retries) => {
            if (retries > 10) {
              console.log('Too many retries on Redis. Connection terminated');
              return new Error('Too many retries');
            }
            return Math.min(retries * 100, 3000);
          },
        },
      });

      this.client.on('error', (err) => {
        console.error('Redis Client Error:', err);
        this.isConnected = false;
      });

      this.client.on('connect', () => {
        console.log('Redis Client Connected');
        this.isConnected = true;
      });

      this.client.on('end', () => {
        console.log('Redis Client Disconnected');
        this.isConnected = false;
      });

      await this.client.connect();
      return this.client;
    } catch (error) {
      console.error('Failed to connect to Redis:', error);
      this.isConnected = false;
      return null;
    }
  }

  async get(key) {
    if (!this.isConnected) return null;
    try {
      return await this.client.get(key);
    } catch (error) {
      console.error('Redis get error:', error);
      return null;
    }
  }

  async set(key, value, expiration = 3600) { // 1 godzina domyślnie
    if (!this.isConnected) return null;
    try {
      return await this.client.setEx(key, expiration, value);
    } catch (error) {
      console.error('Redis set error:', error);
      return null;
    }
  }

  async del(key) {
    if (!this.isConnected) return null;
    try {
      return await this.client.del(key);
    } catch (error) {
      console.error('Redis delete error:', error);
      return null;
    }
  }

  async flushAll() {
    if (!this.isConnected) return null;
    try {
      return await this.client.flushAll();
    } catch (error) {
      console.error('Redis flushAll error:', error);
      return null;
    }
  }

  async disconnect() {
    if (this.client) {
      await this.client.quit();
      this.isConnected = false;
    }
  }
}

module.exports = new RedisClient();

==================================
utils\sanitize.js v.3
==================================

const sanitizeHtml = require('sanitize-html');

// Tytuły: bez HTML - CAŁKOWICIE BEZ TAGÓW
function sanitizeTitle(text) {
  const s = String(text ?? '');
  return sanitizeHtml(s, {
    allowedTags: [],
    allowedAttributes: {},
    disallowedTagsMode: 'discard',
  }).trim();
}

// Treść artykułu: bogate formatowanie
const BODY_CFG = {
  allowedTags: [
    'b',
    'i',
    'em',
    'strong',
    'a',
    'p',
    'br',
    'ul',
    'ol',
    'li',
    'blockquote',
    'code',
    'pre',
    'h1',
    'h2',
    'h3',
    'h4',
    'h5',
    'h6',
  ],
  allowedAttributes: {
    a: ['href', 'title', 'target', 'rel'],
    img: ['src', 'alt', 'width', 'height'],
    code: ['class'],
  },
  allowedSchemes: ['http', 'https', 'mailto', 'data'],
  disallowedTagsMode: 'discard',
  transformTags: {
    a: (tagName, attribs) => ({
      tagName: 'a',
      attribs: {
        ...attribs,
        target: '_blank',
        rel: 'noopener noreferrer nofollow ugc',
      },
    }),
  },
};

function sanitizeBody(html) {
  const s = String(html ?? '');
  return sanitizeHtml(s, BODY_CFG).trim();
}

// Komentarze: MINIMALNE formatowanie + FILTROWANIE NIEBEZPIECZNYCH TAGÓW
function sanitizeComment(str = '') {
  const result = sanitizeHtml(String(str), {
    // DOZWOLONE podstawowe tagi formatujące
    allowedTags: ['b', 'i', 'em', 'strong', 'u', 'br', 'a', 'code', 'pre', 'p'],

    // DOZWOLONE atrybuty (tylko bezpieczne)
    allowedAttributes: {
      a: ['href', 'title', 'target', 'rel'],
    },

    // SCHEMATY tylko http/https/mailto
    allowedSchemes: ['http', 'https', 'mailto'],

    // BLOKUJ niebezpieczne tagi
    disallowedTagsMode: 'discard',

    // ZABEZPIECZ linki - BLOKUJ javascript:
    transformTags: {
      a: (tagName, attribs) => {
        // BLOKUJ linki z javascript: i inne niebezpieczne
        if (
          attribs.href &&
          attribs.href.toLowerCase().startsWith('javascript:')
        ) {
          return { tagName: false, text: '' }; // USUŃ CAŁY TAG
        }

        // Bezpieczne linki - dodaj atrybuty zabezpieczające
        return {
          tagName: 'a',
          attribs: {
            ...attribs,
            target: '_blank',
            rel: 'noopener noreferrer nofollow ugc',
          },
        };
      },
    },

    // DODATKOWO: Ręcznie blokuj niebezpieczne atrybuty
    exclusiveFilter: (frame) => {
      if (frame.attribs) {
        // Blokuj atrybuty zdarzeń (onclick, onerror, etc.)
        const dangerousAttrs = Object.keys(frame.attribs).filter(
          (attr) => attr.startsWith('on') && attr.length > 2, // wszystkie on*
        );

        // Blokuj niebezpieczne schematy URL
        const hasDangerousHref =
          frame.attribs.href &&
          frame.attribs.href.toLowerCase().startsWith('javascript:');

        return dangerousAttrs.length > 0 || hasDangerousHref;
      }
      return false;
    },
  }).trim();

  return result;
}

// BARDZO RESTRYKCYJNA SANITYZACJA - dla parametrów, query string, etc.
const STRICT_SANITIZE_CONFIG = {
  allowedTags: [],
  allowedAttributes: {},
  disallowedTagsMode: 'discard',
};

function sanitizeStrict(text) {
  return sanitizeHtml(String(text || ''), STRICT_SANITIZE_CONFIG)
    .trim()
    .substring(0, 500);
}

module.exports = {
  sanitizeTitle,
  sanitizeBody,
  sanitizeComment,
  sanitizeStrict,
};


==================================
utils\validate.js v.1
==================================

module.exports = function validateFields(fields) {
    const errors = []
    for (const [, [value, msg]] of Object.entries(fields)) {
        if (typeof value === 'string' && value.trim() === '') {
            errors.push(msg)
        }
        if (value === undefined || value === null) {
            errors.push(msg)
        }
    }
    return errors
}
