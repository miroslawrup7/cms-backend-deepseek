Backend v.25

==================================
STRUKTURA PROJEKTU
==================================

+ 
  - .editorconfig
  - .env
  - .env.test
  # [EXCLUDED] .git
  - .gitattributes
  - .gitignore
  - .prettierrc
  + .vscode
    - .vscode\settings.json
  - Plan Backend.txt
  # [EXCLUDED] README.md
  + __tests__
    + __tests__\controllers
      - __tests__\controllers\adminController.test.js
    + __tests__\integration
      - __tests__\integration\admin.test.js
      - __tests__\integration\articles.test.js
      - __tests__\integration\auth.test.js
      - __tests__\integration\cache.test.js
      - __tests__\integration\comments.test.js
      - __tests__\integration\csp.test.js
      - __tests__\integration\performance.test.js
      - __tests__\integration\rateLimit.test.js
      - __tests__\integration\sanitization.test.js
      - __tests__\integration\users.test.js
    + __tests__\services
      - __tests__\services\articleService.createArticle.test.js
      - __tests__\services\articleService.getArticles.test.js
      - __tests__\services\articleService.toggleLikeArticle.test.js
      - __tests__\services\authService.register.pending.test.js
      - __tests__\services\authService.test.js
      - __tests__\services\commentService.test.js
      - __tests__\services\userService.integration.test.js
      - __tests__\services\userService.test.js
    + __tests__\utils
      - __tests__\utils\sanitize.test.js
  + backup
    + backup\cms
      - backup\cms\articles.bson
      - backup\cms\articles.metadata.json
      - backup\cms\comments.bson
      - backup\cms\comments.metadata.json
      - backup\cms\pendingusers.bson
      - backup\cms\pendingusers.metadata.json
      - backup\cms\users.bson
      - backup\cms\users.metadata.json
  + controllers
    - controllers\adminController.js
    - controllers\articleController.js
    - controllers\authController.js
    - controllers\commentController.js
    - controllers\userController.js
  - docker-compose.yml
  - eslint.config.js
  - jest-mongodb-config.js
  - jest.config.js
  - jest.setup.js
  + middleware
    - middleware\authMiddleware.js
    - middleware\cacheMiddleware.js
    - middleware\cspMiddleware.js
    - middleware\isAuthor.js
    - middleware\isCommentAuthor.js
    - middleware\performanceMiddleware.js
    - middleware\rateLimit.js
    - middleware\requireAdmin.js
    - middleware\requireAuthorOrAdmin.js
    - middleware\sanitizeMiddleware.js
    - middleware\upload.js
    - middleware\validateObjectId.js
  + models
    - models\Article.js
    - models\Comment.js
    - models\PendingUser.js
    - models\User.js
  # [EXCLUDED] node_modules
  # [EXCLUDED] package-lock.json
  - package.json
  + routes
    - routes\adminRoutes.js
    - routes\articleRoutes.js
    - routes\authRoutes.js
    - routes\commentRoutes.js
    - routes\userRoutes.js
  # [EXCLUDED] scalacz_backendu
  + scripts
    - scripts\createIndexes.js
  - server.js
  + services
    - services\articleService.js
    - services\authService.js
    - services\commentService.js
    - services\userService.js
  + uploads
    - uploads\1754068886780-2025-05-08_17-46-27(1)-01.jpg
    - uploads\1754152749228-92812186_3218584588186739_8353233957860409344_n.jpg
    - uploads\1754156567535-92989817_3218584841520047_9082093743397404672_n.jpg
    - uploads\1754241925862-92989817_3218584841520047_9082093743397404672_n.jpg
    - uploads\1754310977682-92812186_3218584588186739_8353233957860409344_n.jpg
    - uploads\1754310977688-92948159_3218584998186698_4977806751773491200_n.jpg
    - uploads\1754310977693-92989817_3218584841520047_9082093743397404672_n.jpg
    - uploads\1754310977698-93254356_3218584681520063_688158527956451328_n.jpg
    - uploads\1754310977702-93303604_3218584784853386_6430330249937944576_n.jpg
    - uploads\1754332478792-93254356_3218584681520063_688158527956451328_n.jpg
    - uploads\1754332492051-93254356_3218584681520063_688158527956451328_n.jpg
    - uploads\1754332582184-93303604_3218584784853386_6430330249937944576_n.jpg
    - uploads\1754332738296-92948159_3218584998186698_4977806751773491200_n.jpg
    - uploads\1754332774555-92989817_3218584841520047_9082093743397404672_n.jpg
    - uploads\1754367503118-93303604_3218584784853386_6430330249937944576_n.jpg
    - uploads\1754387409764-92948159_3218584998186698_4977806751773491200_n.jpg
    - uploads\1754462018664-415954181.jpg
    - uploads\1754462123958-301796897.jpg
    - uploads\1754462384224-743992369.jpg
    - uploads\1754462515056-53701265.jpg
    - uploads\1754466490832-679145436.jpg
    - uploads\1754487751546-136461086.jpg
    - uploads\1754487788362-92598928.jpg
    - uploads\1754487826811-398469964.jpg
    - uploads\1754487826814-856807431.jpg
    - uploads\1754487826816-273726342.jpg
    - uploads\1754488665308-463888655.jpg
    - uploads\1754491303538-69773656.jpg
    - uploads\1754497317961-377443572.jpg
    - uploads\1754497317966-945997040.jpg
    - uploads\1756234408292-979512228.jpg
    - uploads\1756318975759-173818095.jpg
    - uploads\1756657307658-499081012.jpg
    - uploads\1756657756825-346829626.jpg
    - uploads\1756660214711-314048676.jpg
    - uploads\1756660258451-415853295.jpg
    - uploads\1756666053549-600682487.jpg
    - uploads\1756666082989-109778181.jpg
    - uploads\1756744162941-217753623.jpg
    - uploads\1756744538323-605333134.jpg
    - uploads\1756744538482-68374677.jpg
    - uploads\1756745272824-824896344.jpg
    - uploads\1756745273002-44688382.jpg
    - uploads\1756745273027-493877727.jpg
    - uploads\1756745811922-747871621.jpg
    - uploads\1756745812075-501152157.jpg
    - uploads\1756745812104-105262893.jpg
    - uploads\1756745873396-210006023.jpg
    - uploads\1756745873555-546599603.jpg
    - uploads\1756745873579-506963760.jpg
    - uploads\1756746218568-965732117.jpg
    - uploads\1756746218719-971552728.jpg
    - uploads\1756746218745-850609998.jpg
    - uploads\1756746282522-535178564.jpg
    - uploads\1756746282682-616618260.jpg
    - uploads\1756746282706-178996590.jpg
    - uploads\1756746481683-500058792.jpg
    - uploads\1756746481836-337460984.jpg
    - uploads\1756746481860-936692384.jpg
    - uploads\1756746538450-581221730.jpg
    - uploads\1756746538604-660689319.jpg
    - uploads\1756746538627-560811603.jpg
    - uploads\1756746717467-978772927.jpg
    - uploads\1756746717622-669638575.jpg
    - uploads\1756746717647-904674377.jpg
    - uploads\1756746804710-597519531.jpg
    - uploads\1756746804864-726654006.jpg
    - uploads\1756746804888-908441161.jpg
    - uploads\1756748436539-837513395.jpg
    - uploads\1756748436697-184509137.jpg
    - uploads\1756748436720-644344373.jpg
    - uploads\1756748591145-616193290.jpg
    - uploads\1756748591309-857443350.jpg
    - uploads\1756748591334-436700840.jpg
    - uploads\1756748903181-441438040.jpg
    - uploads\1756748903362-64697141.jpg
    - uploads\1756748903398-813462936.jpg
    - uploads\1756749131394-563604330.jpg
    - uploads\1756749131579-114911805.jpg
    - uploads\1756749131608-175554828.jpg
    - uploads\1756749401413-295028329.jpg
    - uploads\1756749401601-994645613.jpg
    - uploads\1756749401629-433218701.jpg
    - uploads\1756749668873-273283291.jpg
    - uploads\1756749669055-329166563.jpg
    - uploads\1756749669083-769996504.jpg
    - uploads\1756751265309-698354318.jpg
    - uploads\1756751265493-994886699.jpg
    - uploads\1756751265523-985679947.jpg
    - uploads\1756751529000-357944819.jpg
    - uploads\1756751529185-646635373.jpg
    - uploads\1756751529216-246750683.jpg
    - uploads\1756752724739-505985337.jpg
    - uploads\1756752724922-289345804.jpg
    - uploads\1756752724949-104778983.jpg
    - uploads\1756752753654-358592865.jpg
    - uploads\1756752754940-59077898.jpg
    - uploads\1756752755119-712420293.jpg
    - uploads\1756752755148-159481951.jpg
  + utils
    - utils\AppError.js
    - utils\advancedValidate.js
    - utils\emailTemplates.js
    - utils\logger.js
    - utils\mailer.js
    - utils\queryLogger.js
    - utils\redisClient.js
    - utils\sanitize.js
    - utils\validate.js

==================================
.editorconfig v.1
==================================

root = true

[*]
indent_style = space
indent_size = 2
end_of_line = lf
charset = utf-8
trim_trailing_whitespace = true
insert_final_newline = true

[*.js]
quote_type = single

[*.json]
quote_type = double

==================================
.env v.1
==================================

# Serwer aplikacji
PORT=5000
MONGO_URI=mongodb+srv://miroslawrup7:4snR6SR5f8RPM@cms-cluster.ippwmyf.mongodb.net/cms?retryWrites=true&w=majority
# MONGO_URI=mongodb://localhost:27017/cms
JWT_SECRET=twoj_tajny_klucz_ktory_nie_jest_prosty^%45
FRONTEND_URL=http://localhost:3000

# SMTP / Email
SMTP_HOST=smtp.gmail.com
SMTP_PORT=587
SMTP_SECURE=false
SMTP_USER=mirruptek7@gmail.com
SMTP_PASS=jcrjnhkarjnjvnql
MAIL_FROM="CMS <no-reply@twojadomena.pl>"

# Inne
APP_NAME=CMS

==================================
.env.test v.2
==================================

# .env.test
JWT_SECRET="super-tajny-testowy-klucz-ktory-nie-jest-tajny"
MONGO_URI="mongodb+srv://miroslawrup7:4snR6SR5f8RPM@cms-cluster.ippwmyf.mongodb.net/cms-test?retryWrites=true&w=majority"

# .env.test
REDIS_URL=redis://localhost:6379
REDIS_CACHE_TTL=60 # KrÃ³tszy TTL dla testÃ³w

==================================
.gitattributes v.1
==================================

* text=auto

==================================
.gitignore v.3
==================================

# Node modules
**/node_modules/

# Env files
**/.env

# System files
.DS_Store
Thumbs.db

# Logs
**/logs/
**/*.log




==================================
.prettierrc v.1
==================================

{
  "semi": true,
  "trailingComma": "all",
  "singleQuote": true,
  "printWidth": 80,
  "tabWidth": 2,
  "useTabs": false,
  "endOfLine": "lf"
}

==================================
.vscode\settings.json v.1
==================================

{
  "[javascript]": {
    "editor.defaultFormatter": "esbenp.prettier-vscode",
    "editor.formatOnSave": true
  },
  "editor.codeActionsOnSave": {
    "source.fixAll.eslint": "explicit"
  },
  "eslint.validate": ["javascript"],
  "prettier.requireConfig": true
}


==================================
Plan Backend.txt v.1
==================================

ðŸŸ¢ ETAP 1: TESTY JEDNOSTKOWE I INTEGRACYJNE USÅUG - âœ… 100%

1.1. Testy jednostkowe Services
    âœ… articleService (create, get, toggleLike)
    âœ… authService (login, registerPending)
    âœ… commentService
    âœ… userService (jednostkowe)
    âœ… adminController
1.2. Testy integracyjne Services
    âœ… userService.integration.test.js z MongoDB Memory Server
    âœ… Konfiguracja testowej bazy w pamiÄ™ci
    âœ… Bezpieczne zarzÄ…dzanie poÅ‚Ä…czeniami
1.3. Konfiguracja i tooling
    âœ… ESLint + Prettier skonfigurowane
    âœ… Automatyczne formatowanie
    âœ… MongoDB Memory Server 

ðŸŸ¡ ETAP 2: TESTY INTEGRACYJNE ENDPOINTÃ“W HTTP - ðŸ”„ 0%

2.1. Endpointy autentykacji
    âœ… POST /api/auth/login - logowanie
    âœ… POST /api/auth/register-pending - rejestracja oczekujÄ…ca
    âœ… POST /api/auth/logout - wylogowanie
2.2. Endpointy artykuÅ‚Ã³w
    âœ… GET /api/articles - lista z paginacjÄ…
    âœ… POST /api/articles - tworzenie artykuÅ‚u
    âœ… GET /api/articles/:id - pojedynczy artykuÅ‚
    âœ… PUT /api/articles/:id - edycja artykuÅ‚u
    âœ… DELETE /api/articles/:id - usuwanie artykuÅ‚u
    âœ… POST /api/articles/:id/like - like/dislike
2.3. Endpointy komentarzy
    âœ… GET /api/comments/:id - komentarze artykuÅ‚u
    âœ… POST /api/comments/:id - dodawanie komentarza
    âœ… PUT /api/comments/:id - edycja komentarza
    âœ… DELETE /api/comments/:id - usuwanie komentarza
2.4. Endpointy uÅ¼ytkownikÃ³w
    âœ… GET /api/users/profile - profil uÅ¼ytkownika
    âœ… PUT /api/users/profile - edycja profilu
    âœ… PUT /api/users/password - zmiana hasÅ‚a
2.5. Endpointy administracyjne
    âœ… GET /api/admin/pending-users - lista uÅ¼ytkownikÃ³w oczekujÄ…cych
    âœ… POST /api/admin/approve/:id - zatwierdzanie uÅ¼ytkownika
    âœ… DELETE /api/admin/reject/:id - odrzucanie uÅ¼ytkownika

ðŸ”µ ETAP 3: OPTYMALIZACJA I ZABEZPIECZENIA - ðŸ”„ 0%

3.1. BezpieczeÅ„stwo
    âœ… Rate limiting dla wszystkich endpointÃ³w
    âœ… Weryfikacja sanitization
    âœ… Content Security Policy headers

3.2. WydajnoÅ›Ä‡
    âœ… Cache'owanie odpowiedzi (Redis)
    âšª Optymalizacja zapytaÅ„ MongoDB
    âšª Paginacja dla wszystkich list

3.3. Logowanie i monitoring
    âšª Strukturalne logowanie (JSON)
    âšª Dodanie request IDs
    âšª Metryki wydajnoÅ›ci

ðŸŸ£ ETAP 4: ROZSZERZENIE FUNKCJONALNOÅšCI - ðŸ”„ 0%

4.1. API Documentation
    âšª Swagger/OpenAPI documentation
    âšª API versioning przygotowanie

4.2. Zaawansowane features
    âšª Full-text search (Elasticsearch)
    âšª Notifications system
    âšª File upload optimization
    âšª Background jobs (bull.js)

4.3. DevOps przygotowanie
    âšª Dockerfile i docker-compose
    âšª Environment-based configuration
    âšª Health checks i readiness probe


==================================
__tests__\controllers\adminController.test.js v.1
==================================

// __tests__/controllers/adminController.test.js
const adminController = require('../../controllers/adminController');
const PendingUser = require('../../models/PendingUser');
const User = require('../../models/User');
const { sendMail } = require('../../utils/mailer');
/* eslint-disable no-unused-vars */
const AppError = require('../../utils/AppError');
/* eslint-enable no-unused-vars */
const bcrypt = require('bcryptjs');

// Mockujemy zaleÅ¼noÅ›ci
jest.mock('../../models/PendingUser');
jest.mock('../../models/User');
jest.mock('../../utils/mailer');
jest.mock('bcryptjs');
jest.mock('../../utils/AppError', () => {
  return jest.fn().mockImplementation((message, statusCode) => {
    const error = new Error(message);
    error.statusCode = statusCode;
    return error;
  });
});

describe('Kontroler: adminController', () => {
  let req, res, next;

  beforeEach(() => {
    jest.clearAllMocks();

    // Mock request, response i next
    req = {
      query: {},
      params: {},
      body: {},
    };
    res = {
      json: jest.fn(),
      status: jest.fn().mockReturnThis(),
    };
    next = jest.fn();
  });

  describe('getPendingUsers', () => {
    it('Powinien zwrÃ³ciÄ‡ listÄ™ uÅ¼ytkownikÃ³w oczekujÄ…cych z paginacjÄ…', async () => {
      // ARRANGE
      req.query = { page: '1', limit: '10', search: 'test' };
      const mockUsers = [
        { _id: '1', username: 'testuser1', email: 'test1@example.com' },
        { _id: '2', username: 'testuser2', email: 'test2@example.com' },
      ];

      PendingUser.countDocuments.mockResolvedValue(2);
      PendingUser.find.mockReturnValue({
        sort: jest.fn().mockReturnThis(),
        skip: jest.fn().mockReturnThis(),
        limit: jest.fn().mockReturnThis(),
        lean: jest.fn().mockResolvedValue(mockUsers),
      });

      // ACT
      await adminController.getPendingUsers(req, res, next);

      // ASSERT
      expect(PendingUser.countDocuments).toHaveBeenCalledWith({
        $or: [
          { username: { $regex: 'test', $options: 'i' } },
          { email: { $regex: 'test', $options: 'i' } },
        ],
      });
      expect(res.json).toHaveBeenCalledWith({
        total: 2,
        page: 1,
        limit: 10,
        users: mockUsers,
      });
    });

    it('Powinien obsÅ‚uÅ¼yÄ‡ bÅ‚Ä…d podczas pobierania uÅ¼ytkownikÃ³w', async () => {
      // ARRANGE
      const error = new Error('Database error');
      PendingUser.countDocuments.mockRejectedValue(error);

      // ACT
      await adminController.getPendingUsers(req, res, next);

      // ASSERT
      expect(next).toHaveBeenCalledWith(error);
    });
  });

  describe('approveUser', () => {
    it('Powinien zatwierdziÄ‡ uÅ¼ytkownika i wysÅ‚aÄ‡ email', async () => {
      // ARRANGE
      req.params = { id: 'pending123' };
      const mockPendingUser = {
        _id: 'pending123',
        username: 'testuser',
        email: 'test@example.com',
        password: 'rawpassword',
        role: 'user',
        deleteOne: jest.fn().mockResolvedValue(true),
      };

      const mockSavedUser = {
        _id: 'newUserId123', // âœ… TUTAJ JEST _id
        username: 'testuser',
        email: 'test@example.com',
        role: 'user',
      };

      PendingUser.findById.mockResolvedValue(mockPendingUser);
      User.findOne.mockResolvedValue(null);

      // Mock bcrypt.hash
      bcrypt.hash.mockResolvedValue('hashedpassword');

      // Mock User constructor and save - ZWRACA OBIEKT Z _id
      const mockSave = jest.fn().mockResolvedValue(mockSavedUser);
      User.mockImplementation(() => ({
        save: mockSave,
      }));

      sendMail.mockResolvedValue(true);

      // ACT
      await adminController.approveUser(req, res, next);

      // ASSERT
      expect(PendingUser.findById).toHaveBeenCalledWith('pending123');
      expect(User.findOne).toHaveBeenCalledWith({ email: 'test@example.com' });
      expect(bcrypt.hash).toHaveBeenCalledWith('rawpassword', 10);
      expect(User).toHaveBeenCalledWith({
        username: 'testuser',
        email: 'test@example.com',
        password: 'hashedpassword',
        role: 'user',
      });
      expect(mockSave).toHaveBeenCalled();
      expect(sendMail).toHaveBeenCalled();
      expect(res.json).toHaveBeenCalledWith({
        message: 'UÅ¼ytkownik zatwierdzony i dodany do systemu.',
        userId: 'newUserId123', // âœ… TERAZ BÄ˜DZIE PASOWAÄ†
      });
    });

    it('Powinien rzuciÄ‡ bÅ‚Ä…d gdy wniosek nie istnieje', async () => {
      // ARRANGE
      req.params = { id: 'nonexistent' };
      PendingUser.findById.mockResolvedValue(null);

      // ACT
      await adminController.approveUser(req, res, next);

      // ASSERT
      expect(next).toHaveBeenCalledWith(expect.any(Error));
      expect(next.mock.calls[0][0].statusCode).toBe(404);
    });

    it('Powinien rzuciÄ‡ bÅ‚Ä…d gdy email juÅ¼ istnieje w systemie', async () => {
      // ARRANGE
      req.params = { id: 'pending123' };
      const mockPendingUser = {
        _id: 'pending123',
        email: 'existing@example.com',
        deleteOne: jest.fn().mockResolvedValue(true),
      };

      PendingUser.findById.mockResolvedValue(mockPendingUser);
      User.findOne.mockResolvedValue({ email: 'existing@example.com' });

      // ACT
      await adminController.approveUser(req, res, next);

      // ASSERT
      expect(next).toHaveBeenCalledWith(expect.any(Error));
      expect(next.mock.calls[0][0].statusCode).toBe(400);
    });
  });

  describe('rejectUser', () => {
    it('Powinien odrzuciÄ‡ uÅ¼ytkownika i wysÅ‚aÄ‡ email', async () => {
      // ARRANGE
      req.params = { id: 'pending123' };
      const mockPendingUser = {
        _id: 'pending123',
        username: 'testuser',
        email: 'test@example.com',
        deleteOne: jest.fn().mockResolvedValue(true),
      };

      PendingUser.findById.mockResolvedValue(mockPendingUser);
      sendMail.mockResolvedValue(true);

      // ACT
      await adminController.rejectUser(req, res, next);

      // ASSERT
      expect(PendingUser.findById).toHaveBeenCalledWith('pending123');
      expect(sendMail).toHaveBeenCalled();
      expect(mockPendingUser.deleteOne).toHaveBeenCalled();
      expect(res.json).toHaveBeenCalledWith({
        message: 'Wniosek zostaÅ‚ odrzucony.',
      });
    });

    it('Powinien obsÅ‚uÅ¼yÄ‡ bÅ‚Ä…d wysyÅ‚ki emaila przy odrzuceniu', async () => {
      // ARRANGE
      req.params = { id: 'pending123' };
      const mockPendingUser = {
        _id: 'pending123',
        username: 'testuser',
        email: 'test@example.com',
        deleteOne: jest.fn().mockResolvedValue(true),
      };

      PendingUser.findById.mockResolvedValue(mockPendingUser);
      const mailError = new Error('SMTP error');
      sendMail.mockRejectedValue(mailError);

      // ACT
      await adminController.rejectUser(req, res, next);

      // ASSERT
      expect(sendMail).toHaveBeenCalled();
      expect(mockPendingUser.deleteOne).toHaveBeenCalled();
      expect(res.json).toHaveBeenCalledWith({
        message: 'Wniosek zostaÅ‚ odrzucony.',
      });
    });

    it('Powinien rzuciÄ‡ bÅ‚Ä…d gdy wniosek nie istnieje', async () => {
      // ARRANGE
      req.params = { id: 'nonexistent' };
      PendingUser.findById.mockResolvedValue(null);

      // ACT
      await adminController.rejectUser(req, res, next);

      // ASSERT
      expect(next).toHaveBeenCalledWith(expect.any(Error));
      expect(next.mock.calls[0][0].statusCode).toBe(404);
    });
  });
});


==================================
__tests__\integration\admin.test.js v.2
==================================

const request = require('supertest');
const mongoose = require('mongoose');
const { app, startServer, cleanupTestDatabase } = require('../../server');
const PendingUser = require('../../models/PendingUser');
const User = require('../../models/User');
const bcrypt = require('bcryptjs');

describe('Integracja: Endpointy Administracyjne', () => {
  let adminAuthToken;
  let userAuthToken;
  let _adminUser;
  let _regularUser;
  let pendingUser1;
  let pendingUser2;

  beforeAll(async () => {
    await startServer();

    // UtwÃ³rz administratora
    const hashedAdminPassword = await bcrypt.hash('admin123', 10);
    _adminUser = await User.create({
      email: 'admin@example.com',
      password: hashedAdminPassword,
      username: 'adminuser',
      role: 'admin',
    });

    // UtwÃ³rz zwykÅ‚ego uÅ¼ytkownika
    const hashedUserPassword = await bcrypt.hash('user123', 10);
    _regularUser = await User.create({
      email: 'regular@example.com',
      password: hashedUserPassword,
      username: 'regularuser',
      role: 'user',
    });

    // UtwÃ³rz uÅ¼ytkownikÃ³w oczekujÄ…cych
    pendingUser1 = await PendingUser.create({
      username: 'pendinguser1',
      email: 'pending1@example.com',
      password: 'pendingpass1',
      role: 'user',
    });

    pendingUser2 = await PendingUser.create({
      username: 'pendinguser2',
      email: 'pending2@example.com',
      password: 'pendingpass2',
      role: 'author',
    });

    // Login jako admin aby dostaÄ‡ token
    const adminLoginResponse = await request(app).post('/api/auth/login').send({
      email: 'admin@example.com',
      password: 'admin123',
    });
    adminAuthToken = adminLoginResponse.headers['set-cookie'][0];

    // Login jako zwykÅ‚y uÅ¼ytkownik
    const userLoginResponse = await request(app).post('/api/auth/login').send({
      email: 'regular@example.com',
      password: 'user123',
    });
    userAuthToken = userLoginResponse.headers['set-cookie'][0];
  });

  afterAll(async () => {
    await PendingUser.deleteMany({});
    await User.deleteMany({});
    await cleanupTestDatabase();
  });

  // 1. GET /api/admin/pending-users
  describe('GET /api/admin/pending-users', () => {
    it('Powinien zwrÃ³ciÄ‡ listÄ™ uÅ¼ytkownikÃ³w oczekujÄ…cych dla administratora', async () => {
      const response = await request(app)
        .get('/api/admin/pending-users')
        .set('Cookie', adminAuthToken);

      expect(response.status).toBe(200);
      expect(response.body).toHaveProperty('users');
      expect(Array.isArray(response.body.users)).toBe(true);
      expect(response.body.users.length).toBe(2);
      expect(response.body).toHaveProperty('total', 2);
    });

    it('Powinien zwrÃ³ciÄ‡ bÅ‚Ä…d 403 dla zwykÅ‚ego uÅ¼ytkownika', async () => {
      const response = await request(app)
        .get('/api/admin/pending-users')
        .set('Cookie', userAuthToken);

      expect(response.status).toBe(403);
    });

    it('Powinien zwrÃ³ciÄ‡ bÅ‚Ä…d 401 gdy brak autoryzacji', async () => {
      const response = await request(app).get('/api/admin/pending-users');

      expect(response.status).toBe(401);
    });
  });

  // 2. POST /api/admin/approve/:id
  describe('POST /api/admin/approve/:id', () => {
    it('Powinien zatwierdziÄ‡ uÅ¼ytkownika oczekujÄ…cego', async () => {
      const response = await request(app)
        .post(`/api/admin/approve/${pendingUser1._id}`)
        .set('Cookie', adminAuthToken);

      expect(response.status).toBe(200);
      expect(response.body).toHaveProperty(
        'message',
        'UÅ¼ytkownik zatwierdzony i dodany do systemu.',
      );
      expect(response.body).toHaveProperty('userId');

      // SprawdÅº czy uÅ¼ytkownik zostaÅ‚ przeniesiony do kolekcji User
      const approvedUser = await User.findOne({
        email: 'pending1@example.com',
      });
      expect(approvedUser).not.toBeNull();
      expect(approvedUser.username).toBe('pendinguser1');

      // SprawdÅº czy uÅ¼ytkownik zostaÅ‚ usuniÄ™ty z kolekcji PendingUser
      const pendingUser = await PendingUser.findById(pendingUser1._id);
      expect(pendingUser).toBeNull();
    });

    it('Powinien zwrÃ³ciÄ‡ bÅ‚Ä…d 404 dla nieistniejÄ…cego uÅ¼ytkownika oczekujÄ…cego', async () => {
      const fakeId = new mongoose.Types.ObjectId();

      const response = await request(app)
        .post(`/api/admin/approve/${fakeId}`)
        .set('Cookie', adminAuthToken);

      expect(response.status).toBe(404);
    });

    it('Powinien zwrÃ³ciÄ‡ bÅ‚Ä…d 403 dla zwykÅ‚ego uÅ¼ytkownika', async () => {
      const response = await request(app)
        .post(`/api/admin/approve/${pendingUser2._id}`)
        .set('Cookie', userAuthToken);

      expect(response.status).toBe(403);
    });
  });

  // 3. DELETE /api/admin/reject/:id
  describe('DELETE /api/admin/reject/:id', () => {
    it('Powinien odrzuciÄ‡ uÅ¼ytkownika oczekujÄ…cego', async () => {
      const response = await request(app)
        .delete(`/api/admin/reject/${pendingUser2._id}`)
        .set('Cookie', adminAuthToken);

      expect(response.status).toBe(200);
      expect(response.body).toHaveProperty(
        'message',
        'Wniosek zostaÅ‚ odrzucony.',
      );

      // SprawdÅº czy uÅ¼ytkownik zostaÅ‚ usuniÄ™ty z kolekcji PendingUser
      const rejectedUser = await PendingUser.findById(pendingUser2._id);
      expect(rejectedUser).toBeNull();

      // SprawdÅº czy uÅ¼ytkownik NIE zostaÅ‚ dodany do kolekcji User
      const userInSystem = await User.findOne({
        email: 'pending2@example.com',
      });
      expect(userInSystem).toBeNull();
    });

    it('Powinien zwrÃ³ciÄ‡ bÅ‚Ä…d 404 dla nieistniejÄ…cego uÅ¼ytkownika oczekujÄ…cego', async () => {
      const fakeId = new mongoose.Types.ObjectId();

      const response = await request(app)
        .delete(`/api/admin/reject/${fakeId}`)
        .set('Cookie', adminAuthToken);

      expect(response.status).toBe(404);
    });

    it('Powinien zwrÃ³ciÄ‡ bÅ‚Ä…d 403 dla zwykÅ‚ego uÅ¼ytkownika', async () => {
      // UtwÃ³rz kolejnego uÅ¼ytkownika oczekujÄ…cego do testu
      const testPendingUser = await PendingUser.create({
        username: 'testreject',
        email: 'testreject@example.com',
        password: 'testpass',
        role: 'user',
      });

      const response = await request(app)
        .delete(`/api/admin/reject/${testPendingUser._id}`)
        .set('Cookie', userAuthToken);

      expect(response.status).toBe(403);

      // PosprzÄ…taj
      await PendingUser.findByIdAndDelete(testPendingUser._id);
    });
  });
});


==================================
__tests__\integration\articles.test.js v.2
==================================

// __tests__/integration/articles.test.js
const request = require('supertest');
const mongoose = require('mongoose');
const { app, startServer, cleanupTestDatabase } = require('../../server');
const Article = require('../../models/Article');
const User = require('../../models/User');
const bcrypt = require('bcryptjs');

describe('Integracja: Endpointy ArtykuÅ‚Ã³w', () => {
  let authToken;
  let testUser;

  beforeAll(async () => {
    await startServer();

    // UtwÃ³rz testowego uÅ¼ytkownika i zaloguj
    const hashedPassword = await bcrypt.hash('test123', 10);
    testUser = await User.create({
      email: 'author@example.com',
      password: hashedPassword,
      username: 'author',
      role: 'author',
    });

    // Login aby dostaÄ‡ token
    const loginResponse = await request(app).post('/api/auth/login').send({
      email: 'author@example.com',
      password: 'test123',
    });

    authToken = loginResponse.headers['set-cookie'][0];
  });

  afterEach(async () => {
    await Article.deleteMany({});
  });

  afterAll(async () => {
    await User.deleteMany({});
    await cleanupTestDatabase();
  });

  // âœ… TEST 1: GET /api/articles - lista z paginacjÄ…
  describe('GET /api/articles', () => {
    it('Powinien zwrÃ³ciÄ‡ listÄ™ artykuÅ‚Ã³w z paginacjÄ…', async () => {
      // UtwÃ³rz testowe artykuÅ‚y
      await Article.create([
        {
          title: 'Test Article 1',
          content: 'Content of article 1',
          author: testUser._id,
          images: [],
        },
        {
          title: 'Test Article 2',
          content: 'Content of article 2',
          author: testUser._id,
          images: [],
        },
      ]);

      const response = await request(app)
        .get('/api/articles?page=1&limit=2')
        .set('Cookie', authToken);

      expect(response.status).toBe(200);
      expect(response.body).toHaveProperty('articles');
      expect(response.body).toHaveProperty('total');
      expect(response.body.articles).toHaveLength(2);
    });
  });

  // âœ… TEST 2: POST /api/articles - tworzenie artykuÅ‚u
  describe('POST /api/articles', () => {
    it('Powinien utworzyÄ‡ nowy artykuÅ‚', async () => {
      const response = await request(app)
        .post('/api/articles')
        .set('Cookie', authToken)
        .field('title', 'New Test Article')
        .field('content', 'This is the content of the new article')
        .attach('images', Buffer.from('test'), 'test.jpg');

      expect(response.status).toBe(201);
      expect(response.body).toHaveProperty('message', 'ArtykuÅ‚ utworzony');
      expect(response.body).toHaveProperty('article');
    });
  });

  // âœ… TEST 3: GET /api/articles/:id - pojedynczy artykuÅ‚
  describe('GET /api/articles/:id', () => {
    it('Powinien zwrÃ³ciÄ‡ pojedynczy artykuÅ‚', async () => {
      const article = await Article.create({
        title: 'Single Article',
        content: 'Content for single article',
        author: testUser._id,
        images: [],
      });

      const response = await request(app)
        .get(`/api/articles/${article._id}`)
        .set('Cookie', authToken);

      expect(response.status).toBe(200);
      expect(response.body).toHaveProperty('title', 'Single Article');
    });
  });

  // âœ… TEST 4: PUT /api/articles/:id - edycja artykuÅ‚u
  describe('PUT /api/articles/:id', () => {
    it('Powinien zaktualizowaÄ‡ artykuÅ‚', async () => {
      const article = await Article.create({
        title: 'Old Title',
        content: 'Old content',
        author: testUser._id,
        images: [],
      });

      const response = await request(app)
        .put(`/api/articles/${article._id}`)
        .set('Cookie', authToken)
        .send({
          title: 'Updated Title',
          content: 'This is updated content that is longer than 20 characters', // Minimum 20 znakÃ³w
        });

      expect(response.status).toBe(200);
      expect(response.body).toHaveProperty('message', 'ArtykuÅ‚ zaktualizowany');
    });
  });

  // âœ… TEST 5: DELETE /api/articles/:id - usuwanie artykuÅ‚u
  describe('DELETE /api/articles/:id', () => {
    it('Powinien usunÄ…Ä‡ artykuÅ‚', async () => {
      const article = await Article.create({
        title: 'Article to delete',
        content: 'Content to delete',
        author: testUser._id,
        images: [],
      });

      const response = await request(app)
        .delete(`/api/articles/${article._id}`)
        .set('Cookie', authToken);

      expect(response.status).toBe(204);
    });
  });

  // âœ… TEST 6: POST /api/articles/:id/like - like/dislike
  describe('POST /api/articles/:id/like', () => {
    it('Powinien dodaÄ‡ like do artykuÅ‚u', async () => {
      const article = await Article.create({
        title: 'Article to like',
        content: 'Content to like',
        author: new mongoose.Types.ObjectId(), // Inny autor
        images: [],
      });

      const response = await request(app)
        .post(`/api/articles/${article._id}/like`)
        .set('Cookie', authToken);

      expect(response.status).toBe(200);
      expect(response.body).toHaveProperty('liked', true);
    });
  });
});


==================================
__tests__\integration\auth.test.js v.1
==================================

// __tests__/integration/auth.test.js
const request = require('supertest');
const { app, startServer, cleanupTestDatabase } = require('../../server');
const User = require('../../models/User');
const PendingUser = require('../../models/PendingUser');
const bcrypt = require('bcryptjs');

describe('Integracja: Endpointy Autentykacji', () => {
  beforeAll(async () => {
    await startServer();
  });

  afterEach(async () => {
    // CzyÅ›Ä‡ wszystkie kolekcje po kaÅ¼dym teÅ›cie
    await User.deleteMany({});
    await PendingUser.deleteMany({});
  });

  afterAll(async () => {
    await cleanupTestDatabase();
  });

  describe('POST /api/auth/login', () => {
    it('Powinien zalogowaÄ‡ uÅ¼ytkownika i zwrÃ³ciÄ‡ cookie z tokenem', async () => {
      // 1. UtwÃ³rz aktywnego uÅ¼ytkownika
      const hashedPassword = await bcrypt.hash('test123', 10);
      await User.create({
        email: 'test@example.com',
        password: hashedPassword,
        username: 'testuser',
        role: 'user',
      });

      // 2. WyÅ›lij request login
      const response = await request(app).post('/api/auth/login').send({
        email: 'test@example.com',
        password: 'test123',
      });

      // 3. SprawdÅº response
      expect(response.status).toBe(200);
      expect(response.body).toEqual({ message: 'Zalogowano pomyÅ›lnie.' });

      // 4. SprawdÅº czy token jest w cookies
      const cookies = response.headers['set-cookie'];
      expect(cookies).toBeDefined();
      expect(cookies.some((cookie) => cookie.includes('token'))).toBe(true);
    });

    it('Powinien zwrÃ³ciÄ‡ bÅ‚Ä…d 400 dla nieprawidÅ‚owych danych', async () => {
      const response = await request(app).post('/api/auth/login').send({
        email: 'wrong@example.com',
        password: 'wrongpassword',
      });

      expect(response.status).toBe(400);
      expect(response.body).toEqual({
        message: 'NieprawidÅ‚owy email lub hasÅ‚o.',
      });
    });

    it('Powinien zwrÃ³ciÄ‡ bÅ‚Ä…d 400 dla brakujÄ…cego emaila', async () => {
      const response = await request(app).post('/api/auth/login').send({
        password: 'test123',
      });

      expect(response.status).toBe(400);
      expect(response.body).toHaveProperty('message');
    });
  });

  describe('POST /api/auth/register-pending', () => {
    it('Powinien zarejestrowaÄ‡ uÅ¼ytkownika oczekujÄ…cego', async () => {
      const response = await request(app)
        .post('/api/auth/register-pending')
        .send({
          username: 'newuser',
          email: 'new@example.com',
          password: 'password123',
          role: 'user',
        });

      expect(response.status).toBe(201);
      expect(response.body).toEqual({
        message: 'Wniosek o rejestracjÄ™ zostaÅ‚ przesÅ‚any.',
      });

      // SprawdÅº czy uÅ¼ytkownik jest w kolekcji pending
      const pendingUser = await PendingUser.findOne({
        email: 'new@example.com',
      });
      expect(pendingUser).not.toBeNull();
      expect(pendingUser.username).toBe('newuser');
    });

    it('Powinien zwrÃ³ciÄ‡ bÅ‚Ä…d 400 dla zajÄ™tego emaila', async () => {
      // Najpierw utwÃ³rz uÅ¼ytkownika
      await PendingUser.create({
        username: 'existing',
        email: 'existing@example.com',
        password: 'password123',
        role: 'user',
      });

      const response = await request(app)
        .post('/api/auth/register-pending')
        .send({
          username: 'newuser',
          email: 'existing@example.com', // Ten sam email
          password: 'password123',
          role: 'user',
        });

      expect(response.status).toBe(400);
      expect(response.body).toEqual({ message: 'Email jest juÅ¼ zajÄ™ty.' });
    });
  });

  describe('POST /api/auth/logout', () => {
    it('Powinien wylogowaÄ‡ uÅ¼ytkownika i wyczyÅ›ciÄ‡ cookie', async () => {
      const response = await request(app).post('/api/auth/logout').send();

      expect(response.status).toBe(200);
      expect(response.body).toEqual({ message: 'Wylogowano.' });

      // SprawdÅº czy cookie jest czyszczone
      const cookies = response.headers['set-cookie'];
      expect(cookies).toBeDefined();
      expect(cookies.some((cookie) => cookie.includes('token=;'))).toBe(true);
    });
  });
});


==================================
__tests__\integration\cache.test.js v.1
==================================

// __tests__/integration/cache.test.js
const request = require('supertest');
const { app, startServer, cleanupTestDatabase } = require('../../server');
const redisClient = require('../../utils/redisClient');

describe('Integracja: Cache Redis', () => {
  beforeAll(async () => {
    await startServer();
  });

  afterAll(async () => {
    await redisClient.disconnect();
    await cleanupTestDatabase();
  });

  it('Powinien cache\'owaÄ‡ odpowiedzi GET /api/articles', async () => {
    // Pierwsze request - cache MISS
    const response1 = await request(app).get('/api/articles');
    expect(response1.status).toBe(200);

    // Drugie request - cache HIT
    const response2 = await request(app).get('/api/articles');
    expect(response2.status).toBe(200);

    // SprawdÅº nagÅ‚Ã³wki lub czas odpowiedzi
    // (w rzeczywistoÅ›ci cache jest transparentny dla klienta)
  });

  it('Nie powinien cache\'owaÄ‡ POST requests', async () => {
    const response = await request(app)
      .post('/api/articles')
      .set('Cookie', authToken) // potrzebny token
      .send({ title: 'Test', content: 'Content' });
    
    expect(response.status).toBe(201);
    // POST nie powinien byÄ‡ cache'owany
  });
});

==================================
__tests__\integration\comments.test.js v.2
==================================

const request = require('supertest');
const mongoose = require('mongoose');
const { app, startServer, cleanupTestDatabase } = require('../../server');
const Article = require('../../models/Article');
const Comment = require('../../models/Comment');
const User = require('../../models/User');
const bcrypt = require('bcryptjs');

describe('Integracja: Endpointy Komentarzy', () => {
  let authToken;
  let testUser;
  let testArticle;
  let testComment;

  beforeAll(async () => {
    await startServer();

    // UtwÃ³rz testowego uÅ¼ytkownika i zaloguj
    const hashedPassword = await bcrypt.hash('test123', 10);
    testUser = await User.create({
      email: 'commenter@example.com',
      password: hashedPassword,
      username: 'commenter',
      role: 'user',
    });

    // Login aby dostaÄ‡ token
    const loginResponse = await request(app).post('/api/auth/login').send({
      email: 'commenter@example.com',
      password: 'test123',
    });

    authToken = loginResponse.headers['set-cookie'][0];
  });

  beforeEach(async () => {
    // UtwÃ³rz testowy artykuÅ‚ przed kaÅ¼dym testem
    testArticle = await Article.create({
      title: 'Test Article for Comments',
      content:
        'Content for comments test. This should be long enough for validation.',
      author: testUser._id,
      images: [],
    });

    // UtwÃ³rz testowy komentarz
    testComment = await Comment.create({
      text: 'Initial test comment for testing purposes',
      article: testArticle._id,
      author: testUser._id,
    });
  });

  afterEach(async () => {
    await Comment.deleteMany({});
    await Article.deleteMany({});
  });

  afterAll(async () => {
    await User.deleteMany({});
    await cleanupTestDatabase();
  });

  // 1. GET /api/comments/:id (articleId)
  describe('GET /api/comments/:id', () => {
    it('Powinien zwrÃ³ciÄ‡ listÄ™ komentarzy dla artykuÅ‚u', async () => {
      const response = await request(app)
        .get(`/api/comments/${testArticle._id}`)
        .set('Cookie', authToken);

      expect(response.status).toBe(200);
      expect(Array.isArray(response.body)).toBe(true);
      expect(response.body.length).toBe(1);
      expect(response.body[0]).toHaveProperty(
        'text',
        'Initial test comment for testing purposes',
      );
    });

    it('Powinien zwrÃ³ciÄ‡ pustÄ… listÄ™ gdy brak komentarzy', async () => {
      await Comment.deleteMany({});

      const response = await request(app)
        .get(`/api/comments/${testArticle._id}`)
        .set('Cookie', authToken);

      expect(response.status).toBe(200);
      expect(Array.isArray(response.body)).toBe(true);
      expect(response.body.length).toBe(0);
    });

    it('Powinien zwrÃ³ciÄ‡ pustÄ… listÄ™ dla nieistniejÄ…cego artykuÅ‚u', async () => {
      const fakeArticleId = new mongoose.Types.ObjectId();

      const response = await request(app)
        .get(`/api/comments/${fakeArticleId}`)
        .set('Cookie', authToken);

      expect(response.status).toBe(200);
      expect(Array.isArray(response.body)).toBe(true);
      expect(response.body.length).toBe(0); // Pusta tablica zamiast bÅ‚Ä™du 404
    });
  });

  // 2. POST /api/comments/:id (articleId)
  describe('POST /api/comments/:id', () => {
    it('Powinien dodaÄ‡ komentarz do artykuÅ‚u', async () => {
      const newComment = {
        text: 'This is a new test comment with sufficient length',
      };

      const response = await request(app)
        .post(`/api/comments/${testArticle._id}`)
        .set('Cookie', authToken)
        .send(newComment);

      expect(response.status).toBe(201);
      expect(response.body).toHaveProperty('text', newComment.text);
      expect(response.body).toHaveProperty(
        'article',
        testArticle._id.toString(),
      );
      expect(response.body).toHaveProperty('author');

      // SprawdÅº czy komentarz jest w bazie
      const comments = await Comment.find({ article: testArticle._id });
      expect(comments).toHaveLength(2);
    });

    it('Powinien zwrÃ³ciÄ‡ bÅ‚Ä…d 400 dla zbyt krÃ³tkiego komentarza', async () => {
      const shortComment = {
        text: 'Short', // 5 znakÃ³w < 6 wymaganych
      };

      const response = await request(app)
        .post(`/api/comments/${testArticle._id}`)
        .set('Cookie', authToken)
        .send(shortComment);

      expect(response.status).toBe(400);
      expect(response.body).toHaveProperty('message');
    });

    it('Powinien zwrÃ³ciÄ‡ bÅ‚Ä…d 404 dla nieistniejÄ…cego artykuÅ‚u', async () => {
      const fakeArticleId = new mongoose.Types.ObjectId();
      const newComment = {
        text: 'Comment for non-existent article',
      };

      const response = await request(app)
        .post(`/api/comments/${fakeArticleId}`)
        .set('Cookie', authToken)
        .send(newComment);

      expect(response.status).toBe(404);
    });
  });

  // 3. PUT /api/comments/:id (commentId)
  describe('PUT /api/comments/:id', () => {
    it('Powinien zaktualizowaÄ‡ komentarz', async () => {
      const updatedText = 'This is an updated comment with sufficient length';

      const response = await request(app)
        .put(`/api/comments/${testComment._id}`)
        .set('Cookie', authToken)
        .send({ text: updatedText });

      expect(response.status).toBe(200);
      expect(response.body).toHaveProperty('text', updatedText);

      // SprawdÅº czy komentarz zostaÅ‚ zaktualizowany w bazie
      const updatedComment = await Comment.findById(testComment._id);
      expect(updatedComment.text).toBe(updatedText);
    });

    it('Powinien zwrÃ³ciÄ‡ bÅ‚Ä…d 403 przy prÃ³bie edycji cudzego komentarza', async () => {
      // UtwÃ³rz innego uÅ¼ytkownika
      const otherUser = await User.create({
        email: 'other@example.com',
        password: await bcrypt.hash('test123', 10),
        username: 'otheruser',
        role: 'user',
      });

      // UtwÃ³rz komentarz jako inny uÅ¼ytkownik
      const otherComment = await Comment.create({
        text: 'Other user comment',
        article: testArticle._id,
        author: otherUser._id,
      });

      const response = await request(app)
        .put(`/api/comments/${otherComment._id}`)
        .set('Cookie', authToken)
        .send({ text: 'Trying to edit someone else comment' });

      expect(response.status).toBe(403);
    });

    it('Powinien zwrÃ³ciÄ‡ bÅ‚Ä…d 404 dla nieistniejÄ…cego komentarza', async () => {
      const fakeCommentId = new mongoose.Types.ObjectId();

      const response = await request(app)
        .put(`/api/comments/${fakeCommentId}`)
        .set('Cookie', authToken)
        .send({ text: 'Trying to update non-existent comment' });

      expect(response.status).toBe(404);
    });
  });

  // 4. DELETE /api/comments/:id (commentId)
  describe('DELETE /api/comments/:id', () => {
    it('Powinien usunÄ…Ä‡ komentarz', async () => {
      const response = await request(app)
        .delete(`/api/comments/${testComment._id}`)
        .set('Cookie', authToken);

      expect(response.status).toBe(204);

      // SprawdÅº czy komentarz zostaÅ‚ usuniÄ™ty z bazy
      const deletedComment = await Comment.findById(testComment._id);
      expect(deletedComment).toBeNull();
    });

    it('Powinien zwrÃ³ciÄ‡ bÅ‚Ä…d 403 przy prÃ³bie usuniÄ™cia cudzego komentarza', async () => {
      // UtwÃ³rz innego uÅ¼ytkownika
      const otherUser = await User.create({
        email: 'other2@example.com',
        password: await bcrypt.hash('test123', 10),
        username: 'otheruser2',
        role: 'user',
      });

      // UtwÃ³rz komentarz jako inny uÅ¼ytkownik
      const otherComment = await Comment.create({
        text: 'Other user comment to delete',
        article: testArticle._id,
        author: otherUser._id,
      });

      const response = await request(app)
        .delete(`/api/comments/${otherComment._id}`)
        .set('Cookie', authToken);

      expect(response.status).toBe(403);
    });

    it('Powinien zwrÃ³ciÄ‡ bÅ‚Ä…d 404 dla nieistniejÄ…cego komentarza', async () => {
      const fakeCommentId = new mongoose.Types.ObjectId();

      const response = await request(app)
        .delete(`/api/comments/${fakeCommentId}`)
        .set('Cookie', authToken);

      expect(response.status).toBe(404);
    });
  });
});


==================================
__tests__\integration\csp.test.js v.1
==================================

// __tests__/integration/csp.test.js
const request = require('supertest');
const { app, startServer, cleanupTestDatabase } = require('../../server');

describe('Integracja: Content Security Policy', () => {
  beforeAll(async () => {
    await startServer();
  });

  afterAll(async () => {
    await cleanupTestDatabase();
  });

  it('Powinien zwracaÄ‡ nagÅ‚Ã³wki Content-Security-Policy', async () => {
    const response = await request(app).get('/api/articles');

    expect(response.status).toBe(200);
    expect(response.headers).toHaveProperty('content-security-policy');
    
    const cspHeader = response.headers['content-security-policy'];
    expect(cspHeader).toBeDefined();
    expect(cspHeader).toContain("default-src 'self'");
  });

  it('Powinien pozwalaÄ‡ na obrazy z data URI', async () => {
    const response = await request(app).get('/api/articles');
    
    const cspHeader = response.headers['content-security-policy'];
    expect(cspHeader).toContain("img-src 'self' data:");
  });

  it('Powinien blokowaÄ‡ obiekty embedded', async () => {
    const response = await request(app).get('/api/articles');
    
    const cspHeader = response.headers['content-security-policy'];
    expect(cspHeader).toContain("object-src 'none'");
  });
});

==================================
__tests__\integration\performance.test.js v.1
==================================

// __tests__/integration/performance.test.js
const { app, startServer } = require('../../server');

describe('WydajnoÅ›Ä‡: Testy optymalizacji', () => {
  beforeAll(async () => {
    await startServer();
  });

  it('GET /api/articles powinien byÄ‡ szybki (<100ms)', async () => {
    const start = Date.now();
    const response = await request(app).get('/api/articles');
    const duration = Date.now() - start;
    
    expect(response.status).toBe(200);
    expect(duration).toBeLessThan(100); // âœ… Szybko!
  });

  it('GET /api/articles?search=test powinien uÅ¼ywaÄ‡ full-text index', async () => {
    const response = await request(app).get('/api/articles?search=test');
    expect(response.status).toBe(200);
    // SprawdÅº w logach czy uÅ¼ywa $text index
  });
});

==================================
__tests__\integration\rateLimit.test.js v.1
==================================

const request = require('supertest');
const { app, startServer, cleanupTestDatabase } = require('../../server');
const User = require('../../models/User');
const bcrypt = require('bcryptjs');

describe('Integracja: Rate Limiting', () => {
  let authToken;

  beforeAll(async () => {
    await startServer();

    // UtwÃ³rz testowego uÅ¼ytkownika
    const hashedPassword = await bcrypt.hash('test123', 10);
    await User.create({
      email: 'ratelimit@example.com',
      password: hashedPassword,
      username: 'ratelimituser',
      role: 'user',
    });

    // Zaloguj siÄ™ aby dostaÄ‡ token
    const loginResponse = await request(app).post('/api/auth/login').send({
      email: 'ratelimit@example.com',
      password: 'test123',
    });
    authToken = loginResponse.headers['set-cookie'][0];
  });

  afterAll(async () => {
    await User.deleteMany({});
    await cleanupTestDatabase();
  });

  describe('Global Rate Limiting', () => {
    it('Powinien pozwoliÄ‡ na normalnÄ… liczbÄ™ Å¼Ä…daÅ„', async () => {
      const requests = [];
      for (let i = 0; i < 100; i++) {
        requests.push(
          request(app).get('/api/articles').set('Cookie', authToken),
        );
      }

      const responses = await Promise.all(requests);
      const successResponses = responses.filter((r) => r.status === 200);

      expect(successResponses.length).toBe(100);
    }, 30000);

    it('Powinien blokowaÄ‡ przy zbyt wielu Å¼Ä…daniach z tego samego IP', async () => {
      const requests = [];
      for (let i = 0; i < 1001; i++) {
        requests.push(request(app).get('/api/articles'));
      }

      const responses = await Promise.all(requests);
      const blockedResponses = responses.filter((r) => r.status === 429);

      expect(blockedResponses.length).toBeGreaterThan(0);
      expect(blockedResponses[0].body.message).toContain('Zbyt wiele Å¼Ä…daÅ„');
    }, 30000);
  });

  describe('Auth Rate Limiting', () => {
    it('Powinien blokowaÄ‡ przy zbyt wielu prÃ³bach logowania', async () => {
      const requests = [];
      // UÅ¼yj UNIKALNYCH adresÃ³w IP dla kaÅ¼dego Å¼Ä…dania (omijajÄ… globalny limiter)
      for (let i = 0; i < 51; i++) {
        requests.push(
          request(app)
            .post('/api/auth/login')
            .set('X-Forwarded-For', `192.168.1.${i}`) // ðŸŽ¯ RÃ“Å»NE IP
            .send({
              email: `test${i}@example.com`,
              password: 'wrongpassword',
            }),
        );
      }

      const responses = await Promise.all(requests);
      const blockedResponses = responses.filter((r) => r.status === 429);

      expect(blockedResponses.length).toBeGreaterThan(0);
    }, 30000);
  });

  describe('Admin Rate Limiting', () => {
    it('Powinien blokowaÄ‡ przy zbyt wielu Å¼Ä…daniach do admin endpointÃ³w', async () => {
      // ðŸŽ¯ UTWÃ“RZ admina PRZED testami (bez logowania przez API)
      const adminPassword = await bcrypt.hash('admin123', 10);
      await User.create({
        email: 'adminlimit@example.com',
        password: adminPassword,
        username: 'adminlimit',
        role: 'admin',
      });

      // ðŸŽ¯ SYMULOWANY token admina (omijamy rate limiting logowania)
      const adminToken =
        'token=simulated_admin_token; Path=/; HttpOnly; SameSite=Lax';

      const requests = [];
      for (let i = 0; i < 201; i++) {
        requests.push(
          request(app)
            .get('/api/admin/pending-users')
            .set('Cookie', adminToken),
        );
      }

      const responses = await Promise.all(requests);
      const blockedResponses = responses.filter((r) => r.status === 429);

      // Powinno byÄ‡ przynajmniej 1 zablokowane Å¼Ä…danie (201 > limit 200)
      expect(blockedResponses.length).toBeGreaterThan(0);
    }, 30000);
  });

  describe('Rate Limit Headers', () => {
    it('Powinien zwracaÄ‡ nagÅ‚Ã³wki RateLimit', async () => {
      const response = await request(app)
        .get('/api/articles')
        .set('Cookie', authToken);

      expect(response.headers).toHaveProperty('ratelimit-limit');
      expect(response.headers).toHaveProperty('ratelimit-remaining');
      expect(response.headers).toHaveProperty('ratelimit-reset');
    });
  });
});


==================================
__tests__\integration\sanitization.test.js v.3
==================================

// __tests__/integration/sanitization.test.js
const request = require('supertest');
const { app, startServer, cleanupTestDatabase } = require('../../server');
const User = require('../../models/User');
const Article = require('../../models/Article');
const bcrypt = require('bcryptjs');

describe('Integracja: Testy Sanitization i BezpieczeÅ„stwa', () => {
  let authToken;
  let testUser;
  let testArticle;

  beforeAll(async () => {
    await startServer();

    // UtwÃ³rz testowego uÅ¼ytkownika
    const hashedPassword = await bcrypt.hash('test123', 10);
    testUser = await User.create({
      email: 'security@example.com',
      password: hashedPassword,
      username: 'securityuser',
      role: 'author',
    });

    // UtwÃ³rz testowy artykuÅ‚
    testArticle = await Article.create({
      title: 'Test Security Article',
      content: 'Content for security testing',
      author: testUser._id,
      images: [],
    });

    // Login aby dostaÄ‡ token
    const loginResponse = await request(app).post('/api/auth/login').send({
      email: 'security@example.com',
      password: 'test123',
    });
    authToken = loginResponse.headers['set-cookie'][0];
  });

  afterAll(async () => {
    await User.deleteMany({});
    await Article.deleteMany({});
    await cleanupTestDatabase();
  });

  describe('XSS Injection Tests', () => {
    it('Powinien OCZYÅšCIÄ† XSS w tytule artykuÅ‚u (usuÅ„ wszystkie tagi)', async () => {
      const response = await request(app)
        .post('/api/articles')
        .set('Cookie', authToken)
        .field('title', '<script>alert("xss")</script>Test Title')
        .field(
          'content',
          'Normalna treÅ›Ä‡ artykuÅ‚u ktÃ³ra jest wystarczajÄ…co dÅ‚uga.',
        )
        .attach('images', Buffer.from('test'), 'test.jpg');

      expect(response.status).toBe(201);
      expect(response.body.article.title).toBe('Test Title'); // TYLKO czysty tekst
      expect(response.body.article.title).not.toContain('<script>');
      expect(response.body.article.title).not.toContain('alert');
    });

    it('Powinien OCZYÅšCIÄ† XSS w komentarzach (usuÅ„ niebezpieczne, zachowaj bezpieczne)', async () => {
      const response = await request(app)
        .post(`/api/comments/${testArticle._id}`)
        .set('Cookie', authToken)
        .send({
          text: 'Safe <b>bold</b> but <img src="x" onerror="alert(1)"> dangerous <script>alert(2)</script> and <a href="https://example.com">link</a>',
        });

      expect(response.status).toBe(201);
      // POWINNO ZACHOWAÄ† bezpieczne formatowanie
      expect(response.body.text).toContain('<b>bold</b>');
      expect(response.body.text).toContain('<a href="https://example.com"');
      // POWINNO USUNÄ„Ä† niebezpieczne tagi
      expect(response.body.text).not.toContain('<img');
      expect(response.body.text).not.toContain('<script>');
      expect(response.body.text).not.toContain('onerror');
      // POWINNO ZACHOWAÄ† tekst
      expect(response.body.text).toContain('Safe');
      expect(response.body.text).toContain('bold');
      expect(response.body.text).toContain('dangerous');
      expect(response.body.text).toContain('link');
    });

    it('Powinien OCZYÅšCIÄ† XSS w update profilu (usuÅ„ wszystkie tagi)', async () => {
      const response = await request(app)
        .put('/api/users/profile')
        .set('Cookie', authToken)
        .send({ username: '<script>alert("xss")</script>Hacker' });

      expect(response.status).toBe(200);
      expect(response.body.user.username).toBe('Hacker'); // TYLKO czysty tekst
      expect(response.body.user.username).not.toContain('<script>');
    });
  });

  describe('SQL Injection Tests', () => {
    it('Powinien bezpiecznie obsÅ‚uÅ¼yÄ‡ SQL injection w wyszukiwaniu', async () => {
      const response = await request(app)
        .get('/api/articles?q=test%27; DROP TABLE users;--')
        .set('Cookie', authToken);

      expect(response.status).toBe(200);
      expect(response.body).toHaveProperty('articles');
      expect(Array.isArray(response.body.articles)).toBe(true);
    });

    it('Powinien bezpiecznie obsÅ‚uÅ¼yÄ‡ SQL injection w parametrach', async () => {
      const maliciousId = "'; DROP TABLE users; --";
      const response = await request(app)
        .get(`/api/articles/${maliciousId}`)
        .set('Cookie', authToken);

      expect([400, 404]).toContain(response.status);
    });
  });

  describe('HTML Injection Tests', () => {
    it('Powinien OCZYÅšCIÄ† HTML w polach tekstowych komentarzy', async () => {
      const cleanText = 'Normalny tekst <b>pogrubiony</b> ale bezpieczny';

      const response = await request(app)
        .post(`/api/comments/${testArticle._id}`)
        .set('Cookie', authToken)
        .send({ text: cleanText });

      expect(response.status).toBe(201);
      // Bezpieczne tagi powinny pozostaÄ‡
      expect(response.body.text).toContain('<b>pogrubiony</b>');
      expect(response.body.text).not.toContain('<script>');
    });
  });

  describe('Specific Sanitization Behaviors', () => {
    it('Powinien zachowaÄ‡ podstawowe formatowanie w komentarzach', async () => {
      const response = await request(app)
        .post(`/api/comments/${testArticle._id}`)
        .set('Cookie', authToken)
        .send({
          text: 'Text with <b>bold</b>, <i>italic</i> and <a href="https://example.com">link</a> but no <script>alert(1)</script>',
        });

      expect(response.status).toBe(201);
      // Bezpieczne tagi powinny pozostaÄ‡
      expect(response.body.text).toContain('<b>bold</b>');
      expect(response.body.text).toContain('<i>italic</i>');
      expect(response.body.text).toContain('<a href="https://example.com"');
      // Niebezpieczne tagi powinny byÄ‡ usuniÄ™te
      expect(response.body.text).not.toContain('<script>');
    });

    it('Powinien caÅ‚kowicie usuwaÄ‡ HTML w tytuÅ‚ach', async () => {
      const response = await request(app)
        .post('/api/articles')
        .set('Cookie', authToken)
        .field('title', 'Title with <script>alert(1)</script> and <b>bold</b>')
        .field('content', 'Normal content here...')
        .attach('images', Buffer.from('test'), 'test.jpg');

      expect(response.status).toBe(201);
      // WSZYSTKIE tagi powinny byÄ‡ usuniÄ™te - nawet bezpieczne
      // Po usuniÄ™ciu tagÃ³w pozostaje podwÃ³jna spacja, co jest poprawne
      expect(response.body.article.title).toBe('Title with  and bold');
      expect(response.body.article.title).not.toContain('<script>');
      expect(response.body.article.title).not.toContain('<b>');
    });

    it('Powinien pozwalaÄ‡ na bogate formatowanie w treÅ›ci artykuÅ‚Ã³w', async () => {
      const response = await request(app)
        .post('/api/articles')
        .set('Cookie', authToken)
        .field('title', 'Normal title')
        .field(
          'content',
          'Text with <b>bold</b>, <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8z8BQDwAEhQGAhKmMIQAAAABJRU5ErkJggg==" alt="test"> and <script>alert(1)</script>',
        )
        .attach('images', Buffer.from('test'), 'test.jpg');

      expect(response.status).toBe(201);
      // Bezpieczne tagi powinny pozostaÄ‡
      expect(response.body.article.content).toContain('<b>bold</b>');
      // Obrazki mogÄ… byÄ‡ usuwane w treÅ›ci artykuÅ‚Ã³w - to jest poprawne zachowanie
      expect(response.body.article.content).not.toContain('<script>');
    });
  });
});


==================================
__tests__\integration\users.test.js v.2
==================================

const request = require('supertest');
const { app, startServer, cleanupTestDatabase } = require('../../server');
const User = require('../../models/User');
const bcrypt = require('bcryptjs');

describe('Integracja: Endpointy UÅ¼ytkownikÃ³w', () => {
  let authToken;
  let testUser;

  beforeAll(async () => {
    await startServer();

    // UtwÃ³rz testowego uÅ¼ytkownika i zaloguj
    const hashedPassword = await bcrypt.hash('test123', 10);
    testUser = await User.create({
      email: 'testuser@example.com',
      password: hashedPassword,
      username: 'testuser',
      role: 'user',
    });

    // Login aby dostaÄ‡ token
    const loginResponse = await request(app).post('/api/auth/login').send({
      email: 'testuser@example.com',
      password: 'test123',
    });

    authToken = loginResponse.headers['set-cookie'][0];
  });

  afterAll(async () => {
    await User.deleteMany({});
    await cleanupTestDatabase();
  });

  // 1. GET /api/users/profile
  describe('GET /api/users/profile', () => {
    it('Powinien zwrÃ³ciÄ‡ profil zalogowanego uÅ¼ytkownika', async () => {
      const response = await request(app)
        .get('/api/users/profile')
        .set('Cookie', authToken);

      expect(response.status).toBe(200);
      expect(response.body).toHaveProperty('_id', testUser._id.toString());
      expect(response.body).toHaveProperty('email', 'testuser@example.com');
      expect(response.body).toHaveProperty('username', 'testuser');
      expect(response.body).toHaveProperty('role', 'user');
      expect(response.body).not.toHaveProperty('password'); // HasÅ‚o nie powinno byÄ‡ zwracane
    });

    it('Powinien zwrÃ³ciÄ‡ bÅ‚Ä…d 401 gdy brak autoryzacji', async () => {
      const response = await request(app).get('/api/users/profile');

      expect(response.status).toBe(401);
    });
  });

  // 2. PUT /api/users/profile
  describe('PUT /api/users/profile', () => {
    it('Powinien zaktualizowaÄ‡ nazwÄ™ uÅ¼ytkownika', async () => {
      const updatedData = {
        username: 'updatedusername',
      };

      const response = await request(app)
        .put('/api/users/profile')
        .set('Cookie', authToken)
        .send(updatedData);

      expect(response.status).toBe(200);
      expect(response.body).toHaveProperty('message', 'Profil zaktualizowany');
      expect(response.body.user).toHaveProperty('username', 'updatedusername');
      expect(response.body.user).toHaveProperty(
        'email',
        'testuser@example.com',
      ); // Email nie powinien siÄ™ zmieniÄ‡

      // SprawdÅº czy dane zostaÅ‚y zaktualizowane w bazie
      const updatedUser = await User.findById(testUser._id);
      expect(updatedUser.username).toBe('updatedusername');
    });

    it('Powinien zwrÃ³ciÄ‡ bÅ‚Ä…d 400 dla zbyt krÃ³tkiej nazwy uÅ¼ytkownika', async () => {
      const invalidData = {
        username: 'ab', // 2 znaki < 3 wymagane
      };

      const response = await request(app)
        .put('/api/users/profile')
        .set('Cookie', authToken)
        .send(invalidData);

      expect(response.status).toBe(400);
    });

    it('Powinien zwrÃ³ciÄ‡ bÅ‚Ä…d 401 gdy brak autoryzacji', async () => {
      const response = await request(app)
        .put('/api/users/profile')
        .send({ username: 'test' });

      expect(response.status).toBe(401);
    });
  });

  // 3. PUT /api/users/password
  describe('PUT /api/users/password', () => {
    it('Powinien zmieniÄ‡ hasÅ‚o uÅ¼ytkownika', async () => {
      const passwordData = {
        oldPassword: 'test123',
        newPassword: 'newpassword123',
      };

      const response = await request(app)
        .put('/api/users/password')
        .set('Cookie', authToken)
        .send(passwordData);

      expect(response.status).toBe(200);
      expect(response.body).toHaveProperty(
        'message',
        'HasÅ‚o zostaÅ‚o zmienione.',
      );

      // SprawdÅº czy moÅ¼na zalogowaÄ‡ siÄ™ nowym hasÅ‚em
      const loginResponse = await request(app).post('/api/auth/login').send({
        email: 'testuser@example.com',
        password: 'newpassword123',
      });

      expect(loginResponse.status).toBe(200);
    });

    it('Powinien zwrÃ³ciÄ‡ bÅ‚Ä…d 400 dla nieprawidÅ‚owego starego hasÅ‚a', async () => {
      const passwordData = {
        oldPassword: 'wrongpassword',
        newPassword: 'newpassword123',
      };

      const response = await request(app)
        .put('/api/users/password')
        .set('Cookie', authToken)
        .send(passwordData);

      expect(response.status).toBe(400);
    });

    it('Powinien zwrÃ³ciÄ‡ bÅ‚Ä…d 400 dla zbyt krÃ³tkiego nowego hasÅ‚a', async () => {
      const passwordData = {
        oldPassword: 'test123',
        newPassword: 'short', // 5 znakÃ³w < 6 wymagane
      };

      const response = await request(app)
        .put('/api/users/password')
        .set('Cookie', authToken)
        .send(passwordData);

      expect(response.status).toBe(400);
    });

    it('Powinien zwrÃ³ciÄ‡ bÅ‚Ä…d 401 gdy brak autoryzacji', async () => {
      const response = await request(app).put('/api/users/password').send({
        oldPassword: 'test123',
        newPassword: 'newpassword123',
      });

      expect(response.status).toBe(401);
    });
  });

  // Testy dla admin endpoints (bÄ™dÄ… w admin.test.js)
  describe('Endpointy administracyjne (bÄ™dÄ… testowane osobno)', () => {
    it('Tymczasowy test - do usuniÄ™cia', () => {
      expect(true).toBe(true);
    });
  });
});


==================================
__tests__\services\articleService.createArticle.test.js v.1
==================================

 
// Test files often need unused variables for mocks

// __tests__/services/articleService.createArticle.test.js
const articleService = require('../../services/articleService');
const Article = require('../../models/Article');
jest.mock('../../models/Article');

describe('Serwis: articleService - funkcja createArticle', () => {
  const mockTitle = 'Testowy tytuÅ‚ artykuÅ‚u';
  const mockContent = 'To jest treÅ›Ä‡ testowego artykuÅ‚u, ktÃ³ra jest wystarczajÄ…co dÅ‚uga, aby speÅ‚niÄ‡ wymagania.';
  const mockAuthorId = '507f1f77bcf86cd799439011';
  const mockImagePaths = ['uploads/image1.jpg', 'uploads/image2.png'];

  let mockArticleInstance;

  beforeEach(() => {
    jest.clearAllMocks();
    // 1. Tworzymy obiekt-impostor. Symuluje instancjÄ™ Mongoose, ktÃ³ra ma metodÄ™ `.save`.
    mockArticleInstance = {
      save: jest.fn(), // Mockujemy metodÄ™ save
    };
    // 2. Gdy konstruktor "Article" jest wywoÅ‚ywany, zwracamy naszego impostora.
    Article.mockImplementation(() => mockArticleInstance);
  });

  it('Powinien pomyÅ›lnie utworzyÄ‡ artykuÅ‚ z poprawnymi danymi', async () => {
    // ARRANGE
    const mockSavedArticleData = {
      _id: 'someArticleId',
      title: mockTitle,
      content: mockContent,
      author: mockAuthorId,
      images: mockImagePaths,
    };
    mockArticleInstance.save.mockResolvedValue(mockSavedArticleData);

    // ACT
    const result = await articleService.createArticle(mockTitle, mockContent, mockAuthorId, mockImagePaths);

    // ASSERT
    expect(Article).toHaveBeenCalledWith({
      title: mockTitle,
      content: mockContent,
      author: mockAuthorId,
      images: mockImagePaths,
    });
    expect(mockArticleInstance.save).toHaveBeenCalled();
    expect(result).toBe(mockArticleInstance);
  });

  it('Powinien rzuciÄ‡ bÅ‚Ä…d jeÅ›li tytuÅ‚ jest za krÃ³tki', async () => {
    // ARRANGE
    const shortTitle = 'A';

    // ACT & ASSERT
    await expect(articleService.createArticle(shortTitle, mockContent, mockAuthorId, mockImagePaths))
      .rejects
      .toThrow('TytuÅ‚ musi mieÄ‡ co najmniej 5 znakÃ³w');
        
    // Sprawdzamy, czy save NIE zostaÅ‚ wywoÅ‚any
    expect(mockArticleInstance.save).not.toHaveBeenCalled();
  });

  it('Powinien rzuciÄ‡ bÅ‚Ä…d jeÅ›li treÅ›Ä‡ jest za krÃ³tka', async () => {
    // ARRANGE
    const shortContent = 'KrÃ³tka';

    // ACT & ASSERT
    await expect(articleService.createArticle(mockTitle, shortContent, mockAuthorId, mockImagePaths))
      .rejects
      .toThrow('TreÅ›Ä‡ musi mieÄ‡ co najmniej 20 znakÃ³w');
        
    expect(mockArticleInstance.save).not.toHaveBeenCalled();
  });

  it('Powinien rzuciÄ‡ bÅ‚Ä…d jeÅ›li brakuje tytuÅ‚u lub treÅ›ci', async () => {
    // ACT & ASSERT - brak tytuÅ‚u
    await expect(articleService.createArticle('', mockContent, mockAuthorId, mockImagePaths))
      .rejects
      .toThrow(); // MoÅ¼e rzuciÄ‡ ogÃ³lny bÅ‚Ä…d walidacji

    // ACT & ASSERT - brak treÅ›ci
    await expect(articleService.createArticle(mockTitle, '', mockAuthorId, mockImagePaths))
      .rejects
      .toThrow();

    expect(mockArticleInstance.save).not.toHaveBeenCalled();
  });
});

==================================
__tests__\services\articleService.getArticles.test.js v.1
==================================

// __tests__/services/articleService.getArticles.test.js
const articleService = require('../../services/articleService');
const Article = require('../../models/Article');
const Comment = require('../../models/Comment');

jest.mock('../../models/Article');
jest.mock('../../models/Comment');

describe('Serwis: articleService - funkcja getArticles', () => {
  const mockArticlesData = [
    { 
      _id: 'article1', 
      title: 'Test Article 1', 
      author: { email: 'user1@test.com' }, 
      content: 'Content 1', 
      images: [], 
      likes: [],
      createdAt: new Date('2023-01-01'),
    },
    { 
      _id: 'article2', 
      title: 'Test Article 2', 
      author: { email: 'user2@test.com' }, 
      content: 'Content 2', 
      images: [], 
      likes: ['user1'],
      createdAt: new Date('2023-01-02'),
    },
  ];

  const mockCommentCounts = { article1: 3, article2: 5 };

  // Helper function to create a chainable mock
  const createChainableMock = (finalValue) => {
    const mock = jest.fn().mockReturnThis();
    mock.sort = jest.fn().mockReturnThis();
    mock.skip = jest.fn().mockReturnThis();
    mock.limit = jest.fn().mockReturnThis();
    mock.populate = jest.fn().mockResolvedValue(finalValue);
    return mock;
  };

  beforeEach(() => {
    jest.clearAllMocks();
        
    // Mockujemy Comment.countDocuments dla kaÅ¼dego artykuÅ‚u
    Comment.countDocuments.mockImplementation((query) => {
      const articleId = query.article.toString();
      return Promise.resolve(mockCommentCounts[articleId] || 0);
    });

    // Resetujemy wszystkie mocks Article
    Article.countDocuments.mockReset();
    Article.find.mockReset();
    Article.aggregate.mockReset();
  });

  it('Powinien zwrÃ³ciÄ‡ listÄ™ artykuÅ‚Ã³w z paginacjÄ… (sort: newest)', async () => {
    // ARRANGE
    const page = 1, limit = 2, search = '', sort = 'newest';
    const totalCount = 2;

    // Mock standardowego find z Å‚aÅ„cuchem metod
    Article.countDocuments.mockResolvedValue(totalCount);
    Article.find.mockImplementation(() => createChainableMock(mockArticlesData));

    // ACT
    const result = await articleService.getArticles(page, limit, search, sort);

    // ASSERT
    expect(Article.countDocuments).toHaveBeenCalled();
    expect(Article.find).toHaveBeenCalled();
    expect(result).toEqual({
      articles: [
        { 
          _id: 'article1', 
          title: 'Test Article 1', 
          content: 'Content 1',
          likesCount: 0,
          commentCount: 3,
          author: { email: 'user1@test.com' },
          thumbnail: null,
          createdAt: new Date('2023-01-01'),
        },
        { 
          _id: 'article2', 
          title: 'Test Article 2', 
          content: 'Content 2',
          likesCount: 1,
          commentCount: 5,
          author: { email: 'user2@test.com' },
          thumbnail: null,
          createdAt: new Date('2023-01-02'),
        },
      ],
      total: totalCount,
    });
  });

  it('Powinien zwrÃ³ciÄ‡ listÄ™ artykuÅ‚Ã³w (sort: mostLiked - agregacja)', async () => {
    // ARRANGE
    const page = 1, limit = 2, search = '', sort = 'mostLiked';
    const totalCount = 2;

    // Mock agregacji MongoDB - ZWRACA TABLICÄ˜
    const mockAggregateResult = [
      { 
        _id: 'article1', 
        title: 'Test Article 1', 
        content: 'Content 1',
        author: { email: 'user1@test.com' },
        images: [],
        likes: [],
        likesCount: 0,
        createdAt: new Date('2023-01-01'),
      },
      { 
        _id: 'article2', 
        title: 'Test Article 2', 
        content: 'Content 2', 
        author: { email: 'user2@test.com' },
        images: [],
        likes: ['user1'],
        likesCount: 1,
        createdAt: new Date('2023-01-02'),
      },
    ];
        
    // POPRAWNY MOCK: aggregate() zwraca obiekt z metodÄ… exec()
    Article.aggregate.mockResolvedValue(mockAggregateResult);
    Article.countDocuments.mockResolvedValue(totalCount);

    // ACT
    const result = await articleService.getArticles(page, limit, search, sort);

    // ASSERT
    expect(Article.aggregate).toHaveBeenCalled();
    expect(result.total).toBe(totalCount);
    expect(Array.isArray(result.articles)).toBe(true);
    expect(result.articles).toHaveLength(2);
    expect(result.articles[0]).toHaveProperty('commentCount');
    expect(result.articles[0]).toHaveProperty('likesCount');
    expect(result.articles[0].likesCount).toBe(0);
  });

  it('Powinien przefiltrowaÄ‡ artykuÅ‚y wyszukiwaniem (search)', async () => {
    // ARRANGE
    const page = 1, limit = 2, search = 'Test', sort = 'newest';
    const filteredArticles = [mockArticlesData[0]];
    const totalCount = 1;

    Article.countDocuments.mockResolvedValue(totalCount);
    Article.find.mockImplementation(() => createChainableMock(filteredArticles));

    // ACT
    const result = await articleService.getArticles(page, limit, search, sort);

    // ASSERT
    expect(Article.find).toHaveBeenCalledWith({
      $or: [
        { title: { $regex: 'Test', $options: 'i' } },
        { content: { $regex: 'Test', $options: 'i' } },
      ],
    });
    expect(result.total).toBe(totalCount);
    expect(result.articles).toHaveLength(1);
  });

  it('Powinien obsÅ‚uÅ¼yÄ‡ pustÄ… listÄ™ artykuÅ‚Ã³w', async () => {
    // ARRANGE
    const page = 1, limit = 2, search = '', sort = 'newest';
    const totalCount = 0;

    Article.countDocuments.mockResolvedValue(totalCount);
    Article.find.mockImplementation(() => createChainableMock([]));

    // ACT
    const result = await articleService.getArticles(page, limit, search, sort);

    // ASSERT
    expect(result.articles).toEqual([]);
    expect(result.total).toBe(0);
  });
});

==================================
__tests__\services\articleService.toggleLikeArticle.test.js v.1
==================================

// __tests__/services/articleService.toggleLikeArticle.test.js
const articleService = require('../../services/articleService');
const Article = require('../../models/Article');

jest.mock('../../models/Article');

describe('Serwis: articleService - funkcja toggleLikeArticle', () => {
  const mockArticleId = '507f1f77bcf86cd799439022'; // ObjectId artykuÅ‚u
  const mockUserId = '507f1f77bcf86cd799439011';    // ObjectId uÅ¼ytkownika
  const mockAuthorId = '507f1f77bcf86cd799439033';  // ObjectId autora (inny niÅ¼ userId)

  let mockArticleInstance;

  beforeEach(() => {
    jest.clearAllMocks();
        
    // 1. Tworzymy podstawowÄ… instancjÄ™ artykuÅ‚u
    mockArticleInstance = {
      _id: mockArticleId,
      author: mockAuthorId,
      likes: [], // PoczÄ…tkowo pusta tablica likÃ³w
      save: jest.fn().mockImplementation(function() { 
        // Symulujemy, Å¼e save zwraca "zapisany" obiekt (this)
        return Promise.resolve(this);
      }),
    };

    // 2. --- KLUCZOWA ZMIANA ---
    // Symulujemy, Å¼e `likes` jest tablicÄ… Mongoose z metodÄ… `pull`
    mockArticleInstance.likes = []; // Resetujemy tablicÄ™
    // Dodajemy metodÄ™ `pull` do tej tablicy
    mockArticleInstance.likes.pull = jest.fn((userIdToRemove) => {
      // Implementacja pull: usuwa userId z tablicy likes
      const index = mockArticleInstance.likes.indexOf(userIdToRemove);
      if (index > -1) {
        mockArticleInstance.likes.splice(index, 1);
      }
    });
    // --- KONIEC ZMIANY ---

    // Mockujemy Article.findById aby zwracaÅ‚ naszÄ… instancjÄ™
    Article.findById.mockResolvedValue(mockArticleInstance);
  });

  it('Powinien dodaÄ‡ like, jeÅ›li uÅ¼ytkownik jeszcze nie polubiÅ‚ artykuÅ‚u', async () => {
    // ARRANGE
    // PoczÄ…tkowy stan: likes = [] (uÅ¼ytkownik nie polubiÅ‚)
    mockArticleInstance.likes = [];

    // ACT
    const result = await articleService.toggleLikeArticle(mockArticleId, mockUserId);

    // ASSERT
    // 1. Sprawdzamy, czy znaleziono artykuÅ‚
    expect(Article.findById).toHaveBeenCalledWith(mockArticleId);
    // 2. Sprawdzamy, czy save zostaÅ‚ wywoÅ‚any
    expect(mockArticleInstance.save).toHaveBeenCalled();
    // 3. Sprawdzamy, czy like zostaÅ‚ dodany do tablicy (za pomocÄ… push)
    expect(mockArticleInstance.likes).toContain(mockUserId);
    // 4. Sprawdzamy, czy wynik wskazuje na dodanie like i poprawnÄ… liczbÄ™
    expect(result).toEqual({
      liked: true,
      totalLikes: 1, // Dodano 1 like
    });
  });

  it('Powinien usunÄ…Ä‡ like, jeÅ›li uÅ¼ytkownik juÅ¼ polubiÅ‚ artykuÅ‚', async () => {
    // ARRANGE
    // PoczÄ…tkowy stan: uÅ¼ytkownik juÅ¼ polubiÅ‚ artykuÅ‚
    // NIE NADPISUJEMY tablicy, tylko MODYFIKUJEMY istniejÄ…cÄ…
    mockArticleInstance.likes.push(mockUserId); // <- Dodajemy userId do istniejÄ…cej tablicy

    // ACT
    const result = await articleService.toggleLikeArticle(mockArticleId, mockUserId);

    // ASSERT
    expect(Article.findById).toHaveBeenCalledWith(mockArticleId);
    expect(mockArticleInstance.save).toHaveBeenCalled();
    // Like powinien zostaÄ‡ usuniÄ™ty z tablicy (za pomocÄ… pull)
    expect(mockArticleInstance.likes).not.toContain(mockUserId);
    // Sprawdzamy, czy metoda pull zostaÅ‚a wywoÅ‚ana z prawidÅ‚owym argumentem
    expect(mockArticleInstance.likes.pull).toHaveBeenCalledWith(mockUserId);
    expect(result).toEqual({
      liked: false,
      totalLikes: 0, // UsuniÄ™to 1 like
    });
  });

  it('Powinien rzuciÄ‡ bÅ‚Ä…d, jeÅ›li artykuÅ‚ nie istnieje', async () => {
    // ARRANGE
    Article.findById.mockResolvedValue(null); // ArtykuÅ‚ nie znaleziony

    // ACT & ASSERT
    await expect(articleService.toggleLikeArticle(mockArticleId, mockUserId))
      .rejects
      .toThrow('ArtykuÅ‚ nie znaleziony');
  });

  it('Powinien rzuciÄ‡ bÅ‚Ä…d, jeÅ›li autor prÃ³buje polubiÄ‡ wÅ‚asny artykuÅ‚', async () => {
    // ARRANGE
    // Symulujemy, Å¼e autor prÃ³buje polubiÄ‡ wÅ‚asny artykuÅ‚
    mockArticleInstance.author = mockUserId; // Autor == userId

    // ACT & ASSERT
    await expect(articleService.toggleLikeArticle(mockArticleId, mockUserId))
      .rejects
      .toThrow('Autor nie moÅ¼e polubiÄ‡ wÅ‚asnego artykuÅ‚u');
        
    // Save nie powinien zostaÄ‡ wywoÅ‚any
    expect(mockArticleInstance.save).not.toHaveBeenCalled();
  });
});

==================================
__tests__\services\authService.register.pending.test.js v.1
==================================

// __tests__/services/authService.registerPending.test.js
const authService = require('../../services/authService');
const PendingUser = require('../../models/PendingUser');
const User = require('../../models/User');

// Mockujemy modele Mongoose
jest.mock('../../models/PendingUser');
jest.mock('../../models/User');

describe('Serwis: authService - funkcja registerPending', () => {
  // Dane testowe
  const mockUserData = {
    username: 'testuser',
    email: 'test@example.com',
    password: 'testpass123',
    role: 'user',
  };

  beforeEach(() => {
    jest.clearAllMocks(); // CzyÅ›cimy mocki przed kaÅ¼dym testem
  });

  it('Powinien pomyÅ›lnie zarejestrowaÄ‡ uÅ¼ytkownika oczekujÄ…cego', async () => {
    // ARRANGE
    // 1. Mockujemy, Å¼e NIE ma uÅ¼ytkownika w Å¼adnej z kolekcji
    User.findOne.mockResolvedValue(null);
    PendingUser.findOne.mockResolvedValue(null);
    // 2. Mockujemy metodÄ™ `save` na nowej instancji PendingUser
    const mockSave = jest.fn().mockResolvedValue(true);
    PendingUser.mockImplementation(() => ({
      save: mockSave,
    }));

    // ACT
    // WywoÅ‚ujemy funkcjÄ™ - nie powinna rzuciÄ‡ bÅ‚Ä™dem
    await expect(authService.registerPending(
      mockUserData.username,
      mockUserData.email,
      mockUserData.password,
      mockUserData.role,
    )).resolves.not.toThrow(); // Sprawdzamy, Å¼e Promise siÄ™ resolves (nie rejectuje)

    // ASSERT
    // Sprawdzamy, czy findOne byÅ‚ wywoÅ‚any z poprawnym emailem
    expect(PendingUser.findOne).toHaveBeenCalledWith({ email: mockUserData.email });
    expect(User.findOne).toHaveBeenCalledWith({ email: mockUserData.email });
    // Sprawdzamy, czy konstruktor PendingUser zostaÅ‚ wywoÅ‚any z prawidÅ‚owymi danymi
    expect(PendingUser).toHaveBeenCalledWith({
      username: mockUserData.username,
      email: mockUserData.email,
      password: mockUserData.password, // jeszcze nie zahashowane!
      role: mockUserData.role,
    });
    // Sprawdzamy, czy save zostaÅ‚ wywoÅ‚any na nowym obiekcie
    expect(mockSave).toHaveBeenCalled();
  });

  it('Powinien rzuciÄ‡ bÅ‚Ä…d jeÅ›li uÅ¼ytkownik (Pending) juÅ¼ istnieje', async () => {
    // ARRANGE
    // Symulujemy, Å¼e uÅ¼ytkownik OCZEKUJÄ„CY juÅ¼ istnieje
    PendingUser.findOne.mockResolvedValue({ email: mockUserData.email });

    // ACT & ASSERT
    // Spodziewamy siÄ™, Å¼e funkcja rzuci konkretnym bÅ‚Ä™dem
    await expect(authService.registerPending(
      mockUserData.username,
      mockUserData.email,
      mockUserData.password,
      mockUserData.role,
    )).rejects.toThrow('Email jest juÅ¼ zajÄ™ty.');
    
    // Optional: Sprawdzamy, czy findOne dla User NIE zostaÅ‚ wywoÅ‚any (optymalizacja)
    // expect(User.findOne).not.toHaveBeenCalled();
  });

  it('Powinien rzuciÄ‡ bÅ‚Ä…d jeÅ›li uÅ¼ytkownik (User) juÅ¼ istnieje', async () => {
    // ARRANGE
    // Symulujemy, Å¼e uÅ¼ytkownik ZATWIERDZONY juÅ¼ istnieje
    PendingUser.findOne.mockResolvedValue(null);
    User.findOne.mockResolvedValue({ email: mockUserData.email });

    // ACT & ASSERT
    await expect(authService.registerPending(
      mockUserData.username,
      mockUserData.email,
      mockUserData.password,
      mockUserData.role,
    )).rejects.toThrow('Email jest juÅ¼ zajÄ™ty.');
  });

  // MoÅ¼esz teÅ¼ dodaÄ‡ test dla walidacji (np. brak username)
  it('Powinien rzuciÄ‡ bÅ‚Ä…d walidacji jeÅ›li brakuje wymaganego pola', async () => {
    // ACT & ASSERT - pomijamy username
    await expect(authService.registerPending(
      '', // puste username
      mockUserData.email,
      mockUserData.password,
      mockUserData.role,
    )).rejects.toThrow('Nazwa uÅ¼ytkownika jest wymagana.');
  });
});

==================================
__tests__\services\authService.test.js v.1
==================================

// __tests__/services/authService.test.js
const authService = require('../../services/authService');
const User = require('../../models/User');
const bcrypt = require('bcryptjs');

jest.mock('../../models/User');
jest.mock('bcryptjs');

describe('Serwis: authService - funkcja login', () => {
  const mockEmail = 'test@example.com';
  const mockPassword = 'haslo123';
  const mockWrongPassword = 'zlehaslo';
  const mockUserId = '507f1f77bcf86cd799439011';

  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('Powinien rzuciÄ‡ bÅ‚Ä…d "NieprawidÅ‚owy email lub hasÅ‚o" jeÅ›li uÅ¼ytkownik nie istnieje', async () => {
    User.findOne.mockResolvedValue(null);
    
    await expect(authService.login(mockEmail, mockPassword))
      .rejects
      .toThrow('NieprawidÅ‚owy email lub hasÅ‚o.');
    
    expect(User.findOne).toHaveBeenCalledWith({ email: mockEmail.toLowerCase() });
  });

  it('Powinien rzuciÄ‡ bÅ‚Ä…d "NieprawidÅ‚owy email lub hasÅ‚o" jeÅ›li hasÅ‚o jest niepoprawne', async () => {
    const mockUser = {
      _id: mockUserId,
      email: mockEmail,
      password: 'zahashowane_haslo_z_bazy',
    };
    User.findOne.mockResolvedValue(mockUser);
    bcrypt.compare.mockResolvedValue(false);

    await expect(authService.login(mockEmail, mockWrongPassword))
      .rejects
      .toThrow('NieprawidÅ‚owy email lub hasÅ‚o.');

    expect(bcrypt.compare).toHaveBeenCalledWith(mockWrongPassword, mockUser.password);
  });

  it('Powinien zwrÃ³ciÄ‡ token JWT gdy email i hasÅ‚o sÄ… poprawne', async () => {
    const mockUser = {
      _id: mockUserId,
      email: mockEmail,
      password: 'zahashowane_haslo_z_bazy',
    };
    User.findOne.mockResolvedValue(mockUser);
    bcrypt.compare.mockResolvedValue(true);

    const result = await authService.login(mockEmail, mockPassword);

    expect(typeof result).toBe('string');
    expect(result.length).toBeGreaterThan(20);
    expect(User.findOne).toHaveBeenCalledWith({ email: mockEmail.toLowerCase() });
    expect(bcrypt.compare).toHaveBeenCalledWith(mockPassword, mockUser.password);
  });

  // Dodatkowe testy dla przypadkÃ³w brzegowych
  it('Powinien rzuciÄ‡ bÅ‚Ä…d gdy email jest pusty', async () => {
    await expect(authService.login('', mockPassword))
      .rejects
      .toThrow('Email jest wymagany.');
  });

  it('Powinien rzuciÄ‡ bÅ‚Ä…d gdy hasÅ‚o jest puste', async () => {
    await expect(authService.login(mockEmail, ''))
      .rejects
      .toThrow('HasÅ‚o jest wymagane.');
  });
});

==================================
__tests__\services\commentService.test.js v.1
==================================

// __tests__/services/commentService.test.js
const commentService = require('../../services/commentService');
const Comment = require('../../models/Comment');
const Article = require('../../models/Article');

jest.mock('../../models/Comment');
jest.mock('../../models/Article');

describe('Serwis: commentService', () => {
  const mockArticleId = '507f1f77bcf86cd799439022';
  const mockUserId = '507f1f77bcf86cd799439011';
  const mockCommentId = '507f1f77bcf86cd799439033';
  const mockCommentText = 'To jest bardzo przemyÅ›lany komentarz';

  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe('addComment', () => {
    it('Powinien dodaÄ‡ komentarz do istniejÄ…cego artykuÅ‚u', async () => {
      // ARRANGE
      Article.findById.mockResolvedValue({ _id: mockArticleId });
      // Mock Comment.create zamiast new Comment().save()
      Comment.create.mockResolvedValue({
        _id: mockCommentId,
        text: mockCommentText,
        article: mockArticleId,
        author: mockUserId,
      });

      // ACT
      const result = await commentService.addComment(
        mockArticleId,
        mockUserId,
        mockCommentText,
      );

      // ASSERT
      expect(Article.findById).toHaveBeenCalledWith(mockArticleId);
      expect(Comment.create).toHaveBeenCalledWith({
        text: mockCommentText,
        article: mockArticleId,
        author: mockUserId,
      });
      expect(result.text).toBe(mockCommentText);
    });

    it('Powinien rzuciÄ‡ bÅ‚Ä…d jeÅ›li artykuÅ‚ nie istnieje', async () => {
      // ARRANGE
      Article.findById.mockResolvedValue(null);

      // ACT & ASSERT - UwzglÄ™dnij kropkÄ™ w komunikacie
      await expect(
        commentService.addComment(mockArticleId, mockUserId, mockCommentText),
      ).rejects.toThrow('Nie znaleziono artykuÅ‚u.');
    });

    it('Powinien rzuciÄ‡ bÅ‚Ä…d walidacji dla zbyt krÃ³tkiego komentarza', async () => {
      // ARRANGE
      Article.findById.mockResolvedValue({ _id: mockArticleId });
      const shortText = 'KrÃ³tk';

      // ACT & ASSERT
      await expect(
        commentService.addComment(mockArticleId, mockUserId, shortText),
      ).rejects.toThrow('Komentarz musi mieÄ‡ co najmniej 6 znakÃ³w');

      // Dodatkowo: upewnij siÄ™, Å¼e Comment.create NIE zostaÅ‚ wywoÅ‚any
      expect(Comment.create).not.toHaveBeenCalled();
    });
  });

  describe('getComments', () => {
    it('Powinien zwrÃ³ciÄ‡ listÄ™ komentarzy dla artykuÅ‚u', async () => {
      // ARRANGE
      const mockComments = [
        { _id: 'comment1', text: 'Komentarz 1', author: { username: 'user1' } },
        { _id: 'comment2', text: 'Komentarz 2', author: { username: 'user2' } },
      ];
      Comment.find.mockReturnValue({
        populate: jest.fn().mockReturnThis(),
        sort: jest.fn().mockResolvedValue(mockComments),
      });

      // ACT
      const result = await commentService.getComments(mockArticleId);

      // ASSERT
      expect(Comment.find).toHaveBeenCalledWith({ article: mockArticleId });
      expect(result).toEqual(mockComments);
    });
  });

  describe('updateComment', () => {
    it('Powinien zaktualizowaÄ‡ komentarz jeÅ›li uÅ¼ytkownik jest autorem', async () => {
      // ARRANGE
      const mockComment = {
        _id: mockCommentId,
        text: 'Stara treÅ›Ä‡',
        author: mockUserId,
        save: jest.fn().mockResolvedValue({
          _id: mockCommentId,
          text: 'Nowa treÅ›Ä‡',
          author: mockUserId,
        }),
      };
      Comment.findById.mockResolvedValue(mockComment);

      // ACT
      const result = await commentService.updateComment(
        mockCommentId,
        mockUserId,
        'user',
        'Nowa treÅ›Ä‡',
      );

      // ASSERT
      expect(Comment.findById).toHaveBeenCalledWith(mockCommentId);
      expect(mockComment.save).toHaveBeenCalled();
      expect(result.text).toBe('Nowa treÅ›Ä‡');
    });

    it('Powinien rzuciÄ‡ bÅ‚Ä…d jeÅ›li komentarz nie istnieje', async () => {
      // ARRANGE
      Comment.findById.mockResolvedValue(null);

      // ACT & ASSERT
      await expect(
        commentService.updateComment(
          mockCommentId,
          mockUserId,
          'user',
          'Nowa treÅ›Ä‡',
        ),
      ).rejects.toThrow('Komentarz nie istnieje');
    });
  });

  describe('deleteComment', () => {
    it('Powinien usunÄ…Ä‡ komentarz jeÅ›li uÅ¼ytkownik jest autorem', async () => {
      // ARRANGE
      const mockComment = {
        _id: mockCommentId,
        author: mockUserId,
        deleteOne: jest.fn().mockResolvedValue(true),
      };
      Comment.findById.mockResolvedValue(mockComment);

      // ACT
      await commentService.deleteComment(mockCommentId, mockUserId, 'user');

      // ASSERT
      expect(Comment.findById).toHaveBeenCalledWith(mockCommentId);
      expect(mockComment.deleteOne).toHaveBeenCalled();
    });
  });
});


==================================
__tests__\services\userService.integration.test.js v.2
==================================

// __tests__/services/userService.integration.test.js
const mongoose = require('mongoose');
const { MongoMemoryServer } = require('mongodb-memory-server');
const bcrypt = require('bcryptjs');
const User = require('../../models/User');
const userService = require('../../services/userService');

let mongoServer;

// âœ… ZwiÄ™ksz timeout dla wszystkich testÃ³w
jest.setTimeout(30000);

beforeAll(async () => {
  try {
    mongoServer = await MongoMemoryServer.create();
    const uri = mongoServer.getUri();
    await mongoose.connect(uri);
    console.log('Connected to MongoDB Memory Server:', uri);
  } catch (error) {
    console.error('MongoDB connection error:', error);
    throw error;
  }
});

afterEach(async () => {
  try {
    await User.deleteMany({});
  } catch (error) {
    console.error('Error cleaning up users:', error);
  }
});

afterAll(async () => {
  try {
    // âœ… Bezpieczne zamykanie poÅ‚Ä…czenia
    if (mongoose.connection.readyState !== 0) {
      await mongoose.disconnect();
    }
    // âœ… Bezpieczne zatrzymanie memory server
    if (mongoServer) {
      await mongoServer.stop();
    }
    console.log('MongoDB connection closed');
  } catch (error) {
    console.error('Error closing MongoDB connection:', error);
  }
});

describe('Serwis: userService - testy integracyjne', () => {
  it('Powinien stworzyÄ‡ i pobraÄ‡ uÅ¼ytkownika bez hasÅ‚a', async () => {
    const user = await User.create({
      email: 'test@test.com',
      password: 'hashedPassword',
      username: 'Tester',
      role: 'user',
    });

    const profile = await userService.getProfile(user._id);

    expect(profile).toMatchObject({
      email: 'test@test.com',
      username: 'Tester',
      role: 'user',
    });
    expect(profile.password).toBeUndefined();
  });

  it('Powinien zaktualizowaÄ‡ nazwÄ™ uÅ¼ytkownika', async () => {
    const user = await User.create({
      email: 'abc@test.com',
      password: 'hashedPassword',
      username: 'OldName',
      role: 'user',
    });

    const updated = await userService.updateProfile(user._id, {
      username: 'NewName',
    });

    expect(updated.username).toBe('NewName');
    expect(updated.password).toBeUndefined();
  });

  it('Powinien rzuciÄ‡ bÅ‚Ä…d gdy uÅ¼ytkownik nie istnieje', async () => {
    const fakeId = new mongoose.Types.ObjectId();
    await expect(userService.getProfile(fakeId)).rejects.toThrow(
      'UÅ¼ytkownik nie istnieje',
    );
  });

  it('Powinien zmieniÄ‡ hasÅ‚o gdy stare hasÅ‚o jest poprawne', async () => {
    const hashed = await bcrypt.hash('oldPass', 10);
    const user = await User.create({
      email: 'pass@test.com',
      password: hashed,
      username: 'PassUser',
      role: 'user',
    });

    await userService.changePassword(user._id, 'oldPass', 'newPass');
    const updated = await User.findById(user._id);

    const isMatch = await bcrypt.compare('newPass', updated.password);
    expect(isMatch).toBe(true);
  });

  it('Powinien rzuciÄ‡ bÅ‚Ä…d gdy stare hasÅ‚o jest nieprawidÅ‚owe', async () => {
    const hashed = await bcrypt.hash('oldPass', 10);
    const user = await User.create({
      email: 'failpass@test.com',
      password: hashed,
      username: 'FailUser',
      role: 'user',
    });

    await expect(
      userService.changePassword(user._id, 'wrongPass', 'newPass'),
    ).rejects.toThrow('Stare hasÅ‚o jest nieprawidÅ‚owe.');
  });

  it('Powinien zwrÃ³ciÄ‡ listÄ™ uÅ¼ytkownikÃ³w bez haseÅ‚', async () => {
    await User.create([
      {
        email: 'user1@test.com',
        password: 'hashedPassword1', // min 6 znakÃ³w
        username: 'User1',
        role: 'user',
      },
      {
        email: 'user2@test.com',
        password: 'hashedPassword2', // min 6 znakÃ³w
        username: 'User2',
        role: 'user',
      },
    ]);

    const users = await userService.listUsers();

    expect(users).toHaveLength(2);
    users.forEach((u) => expect(u.password).toBeUndefined());
  });

  it('Powinien zmieniÄ‡ rolÄ™ uÅ¼ytkownika na admin', async () => {
    const user = await User.create({
      email: 'role@test.com',
      password: 'hashed',
      username: 'RoleUser',
      role: 'user',
    });

    const updated = await userService.changeRole(user._id, 'admin');

    expect(updated.role).toBe('admin');
    expect(updated.password).toBeUndefined();
  });

  it('Powinien rzuciÄ‡ bÅ‚Ä…d dla nieprawidÅ‚owej roli', async () => {
    const user = await User.create({
      email: 'badrole@test.com',
      password: 'hashed',
      username: 'BadRole',
      role: 'user',
    });

    await expect(
      userService.changeRole(user._id, 'superadmin'),
    ).rejects.toThrow('NieprawidÅ‚owa rola.');
  });

  it('Powinien usunÄ…Ä‡ uÅ¼ytkownika', async () => {
    const user = await User.create({
      email: 'del@test.com',
      password: 'hashed',
      username: 'DeleteMe',
      role: 'user',
    });

    await userService.deleteUser(user._id);

    const found = await User.findById(user._id);
    expect(found).toBeNull();
  });
});


==================================