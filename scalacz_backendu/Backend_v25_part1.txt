Backend v.25

==================================
STRUKTURA PROJEKTU
==================================

+ 
  - .editorconfig
  - .env
  - .env.test
  # [EXCLUDED] .git
  - .gitattributes
  - .gitignore
  - .prettierrc
  + .vscode
    - .vscode\settings.json
  - Plan Backend.txt
  # [EXCLUDED] README.md
  + __tests__
    + __tests__\controllers
      - __tests__\controllers\adminController.test.js
    + __tests__\integration
      - __tests__\integration\admin.test.js
      - __tests__\integration\articles.test.js
      - __tests__\integration\auth.test.js
      - __tests__\integration\cache.test.js
      - __tests__\integration\comments.test.js
      - __tests__\integration\csp.test.js
      - __tests__\integration\performance.test.js
      - __tests__\integration\rateLimit.test.js
      - __tests__\integration\sanitization.test.js
      - __tests__\integration\users.test.js
    + __tests__\services
      - __tests__\services\articleService.createArticle.test.js
      - __tests__\services\articleService.getArticles.test.js
      - __tests__\services\articleService.toggleLikeArticle.test.js
      - __tests__\services\authService.register.pending.test.js
      - __tests__\services\authService.test.js
      - __tests__\services\commentService.test.js
      - __tests__\services\userService.integration.test.js
      - __tests__\services\userService.test.js
    + __tests__\utils
      - __tests__\utils\sanitize.test.js
  + backup
    + backup\cms
      - backup\cms\articles.bson
      - backup\cms\articles.metadata.json
      - backup\cms\comments.bson
      - backup\cms\comments.metadata.json
      - backup\cms\pendingusers.bson
      - backup\cms\pendingusers.metadata.json
      - backup\cms\users.bson
      - backup\cms\users.metadata.json
  + controllers
    - controllers\adminController.js
    - controllers\articleController.js
    - controllers\authController.js
    - controllers\commentController.js
    - controllers\userController.js
  - docker-compose.yml
  - eslint.config.js
  - jest-mongodb-config.js
  - jest.config.js
  - jest.setup.js
  + middleware
    - middleware\authMiddleware.js
    - middleware\cacheMiddleware.js
    - middleware\cspMiddleware.js
    - middleware\isAuthor.js
    - middleware\isCommentAuthor.js
    - middleware\performanceMiddleware.js
    - middleware\rateLimit.js
    - middleware\requireAdmin.js
    - middleware\requireAuthorOrAdmin.js
    - middleware\sanitizeMiddleware.js
    - middleware\upload.js
    - middleware\validateObjectId.js
  + models
    - models\Article.js
    - models\Comment.js
    - models\PendingUser.js
    - models\User.js
  # [EXCLUDED] node_modules
  # [EXCLUDED] package-lock.json
  - package.json
  + routes
    - routes\adminRoutes.js
    - routes\articleRoutes.js
    - routes\authRoutes.js
    - routes\commentRoutes.js
    - routes\userRoutes.js
  # [EXCLUDED] scalacz_backendu
  + scripts
    - scripts\createIndexes.js
  - server.js
  + services
    - services\articleService.js
    - services\authService.js
    - services\commentService.js
    - services\userService.js
  + uploads
    - uploads\1754068886780-2025-05-08_17-46-27(1)-01.jpg
    - uploads\1754152749228-92812186_3218584588186739_8353233957860409344_n.jpg
    - uploads\1754156567535-92989817_3218584841520047_9082093743397404672_n.jpg
    - uploads\1754241925862-92989817_3218584841520047_9082093743397404672_n.jpg
    - uploads\1754310977682-92812186_3218584588186739_8353233957860409344_n.jpg
    - uploads\1754310977688-92948159_3218584998186698_4977806751773491200_n.jpg
    - uploads\1754310977693-92989817_3218584841520047_9082093743397404672_n.jpg
    - uploads\1754310977698-93254356_3218584681520063_688158527956451328_n.jpg
    - uploads\1754310977702-93303604_3218584784853386_6430330249937944576_n.jpg
    - uploads\1754332478792-93254356_3218584681520063_688158527956451328_n.jpg
    - uploads\1754332492051-93254356_3218584681520063_688158527956451328_n.jpg
    - uploads\1754332582184-93303604_3218584784853386_6430330249937944576_n.jpg
    - uploads\1754332738296-92948159_3218584998186698_4977806751773491200_n.jpg
    - uploads\1754332774555-92989817_3218584841520047_9082093743397404672_n.jpg
    - uploads\1754367503118-93303604_3218584784853386_6430330249937944576_n.jpg
    - uploads\1754387409764-92948159_3218584998186698_4977806751773491200_n.jpg
    - uploads\1754462018664-415954181.jpg
    - uploads\1754462123958-301796897.jpg
    - uploads\1754462384224-743992369.jpg
    - uploads\1754462515056-53701265.jpg
    - uploads\1754466490832-679145436.jpg
    - uploads\1754487751546-136461086.jpg
    - uploads\1754487788362-92598928.jpg
    - uploads\1754487826811-398469964.jpg
    - uploads\1754487826814-856807431.jpg
    - uploads\1754487826816-273726342.jpg
    - uploads\1754488665308-463888655.jpg
    - uploads\1754491303538-69773656.jpg
    - uploads\1754497317961-377443572.jpg
    - uploads\1754497317966-945997040.jpg
    - uploads\1756234408292-979512228.jpg
    - uploads\1756318975759-173818095.jpg
    - uploads\1756657307658-499081012.jpg
    - uploads\1756657756825-346829626.jpg
    - uploads\1756660214711-314048676.jpg
    - uploads\1756660258451-415853295.jpg
    - uploads\1756666053549-600682487.jpg
    - uploads\1756666082989-109778181.jpg
    - uploads\1756744162941-217753623.jpg
    - uploads\1756744538323-605333134.jpg
    - uploads\1756744538482-68374677.jpg
    - uploads\1756745272824-824896344.jpg
    - uploads\1756745273002-44688382.jpg
    - uploads\1756745273027-493877727.jpg
    - uploads\1756745811922-747871621.jpg
    - uploads\1756745812075-501152157.jpg
    - uploads\1756745812104-105262893.jpg
    - uploads\1756745873396-210006023.jpg
    - uploads\1756745873555-546599603.jpg
    - uploads\1756745873579-506963760.jpg
    - uploads\1756746218568-965732117.jpg
    - uploads\1756746218719-971552728.jpg
    - uploads\1756746218745-850609998.jpg
    - uploads\1756746282522-535178564.jpg
    - uploads\1756746282682-616618260.jpg
    - uploads\1756746282706-178996590.jpg
    - uploads\1756746481683-500058792.jpg
    - uploads\1756746481836-337460984.jpg
    - uploads\1756746481860-936692384.jpg
    - uploads\1756746538450-581221730.jpg
    - uploads\1756746538604-660689319.jpg
    - uploads\1756746538627-560811603.jpg
    - uploads\1756746717467-978772927.jpg
    - uploads\1756746717622-669638575.jpg
    - uploads\1756746717647-904674377.jpg
    - uploads\1756746804710-597519531.jpg
    - uploads\1756746804864-726654006.jpg
    - uploads\1756746804888-908441161.jpg
    - uploads\1756748436539-837513395.jpg
    - uploads\1756748436697-184509137.jpg
    - uploads\1756748436720-644344373.jpg
    - uploads\1756748591145-616193290.jpg
    - uploads\1756748591309-857443350.jpg
    - uploads\1756748591334-436700840.jpg
    - uploads\1756748903181-441438040.jpg
    - uploads\1756748903362-64697141.jpg
    - uploads\1756748903398-813462936.jpg
    - uploads\1756749131394-563604330.jpg
    - uploads\1756749131579-114911805.jpg
    - uploads\1756749131608-175554828.jpg
    - uploads\1756749401413-295028329.jpg
    - uploads\1756749401601-994645613.jpg
    - uploads\1756749401629-433218701.jpg
    - uploads\1756749668873-273283291.jpg
    - uploads\1756749669055-329166563.jpg
    - uploads\1756749669083-769996504.jpg
    - uploads\1756751265309-698354318.jpg
    - uploads\1756751265493-994886699.jpg
    - uploads\1756751265523-985679947.jpg
    - uploads\1756751529000-357944819.jpg
    - uploads\1756751529185-646635373.jpg
    - uploads\1756751529216-246750683.jpg
    - uploads\1756752724739-505985337.jpg
    - uploads\1756752724922-289345804.jpg
    - uploads\1756752724949-104778983.jpg
    - uploads\1756752753654-358592865.jpg
    - uploads\1756752754940-59077898.jpg
    - uploads\1756752755119-712420293.jpg
    - uploads\1756752755148-159481951.jpg
  + utils
    - utils\AppError.js
    - utils\advancedValidate.js
    - utils\emailTemplates.js
    - utils\logger.js
    - utils\mailer.js
    - utils\queryLogger.js
    - utils\redisClient.js
    - utils\sanitize.js
    - utils\validate.js

==================================
.editorconfig v.1
==================================

root = true

[*]
indent_style = space
indent_size = 2
end_of_line = lf
charset = utf-8
trim_trailing_whitespace = true
insert_final_newline = true

[*.js]
quote_type = single

[*.json]
quote_type = double

==================================
.env v.1
==================================

# Serwer aplikacji
PORT=5000
MONGO_URI=mongodb+srv://miroslawrup7:4snR6SR5f8RPM@cms-cluster.ippwmyf.mongodb.net/cms?retryWrites=true&w=majority
# MONGO_URI=mongodb://localhost:27017/cms
JWT_SECRET=twoj_tajny_klucz_ktory_nie_jest_prosty^%45
FRONTEND_URL=http://localhost:3000

# SMTP / Email
SMTP_HOST=smtp.gmail.com
SMTP_PORT=587
SMTP_SECURE=false
SMTP_USER=mirruptek7@gmail.com
SMTP_PASS=jcrjnhkarjnjvnql
MAIL_FROM="CMS <no-reply@twojadomena.pl>"

# Inne
APP_NAME=CMS

==================================
.env.test v.2
==================================

# .env.test
JWT_SECRET="super-tajny-testowy-klucz-ktory-nie-jest-tajny"
MONGO_URI="mongodb+srv://miroslawrup7:4snR6SR5f8RPM@cms-cluster.ippwmyf.mongodb.net/cms-test?retryWrites=true&w=majority"

# .env.test
REDIS_URL=redis://localhost:6379
REDIS_CACHE_TTL=60 # Krótszy TTL dla testów

==================================
.gitattributes v.1
==================================

* text=auto

==================================
.gitignore v.3
==================================

# Node modules
**/node_modules/

# Env files
**/.env

# System files
.DS_Store
Thumbs.db

# Logs
**/logs/
**/*.log




==================================
.prettierrc v.1
==================================

{
  "semi": true,
  "trailingComma": "all",
  "singleQuote": true,
  "printWidth": 80,
  "tabWidth": 2,
  "useTabs": false,
  "endOfLine": "lf"
}

==================================
.vscode\settings.json v.1
==================================

{
  "[javascript]": {
    "editor.defaultFormatter": "esbenp.prettier-vscode",
    "editor.formatOnSave": true
  },
  "editor.codeActionsOnSave": {
    "source.fixAll.eslint": "explicit"
  },
  "eslint.validate": ["javascript"],
  "prettier.requireConfig": true
}


==================================
Plan Backend.txt v.1
==================================

🟢 ETAP 1: TESTY JEDNOSTKOWE I INTEGRACYJNE USŁUG - ✅ 100%

1.1. Testy jednostkowe Services
    ✅ articleService (create, get, toggleLike)
    ✅ authService (login, registerPending)
    ✅ commentService
    ✅ userService (jednostkowe)
    ✅ adminController
1.2. Testy integracyjne Services
    ✅ userService.integration.test.js z MongoDB Memory Server
    ✅ Konfiguracja testowej bazy w pamięci
    ✅ Bezpieczne zarządzanie połączeniami
1.3. Konfiguracja i tooling
    ✅ ESLint + Prettier skonfigurowane
    ✅ Automatyczne formatowanie
    ✅ MongoDB Memory Server 

🟡 ETAP 2: TESTY INTEGRACYJNE ENDPOINTÓW HTTP - 🔄 0%

2.1. Endpointy autentykacji
    ✅ POST /api/auth/login - logowanie
    ✅ POST /api/auth/register-pending - rejestracja oczekująca
    ✅ POST /api/auth/logout - wylogowanie
2.2. Endpointy artykułów
    ✅ GET /api/articles - lista z paginacją
    ✅ POST /api/articles - tworzenie artykułu
    ✅ GET /api/articles/:id - pojedynczy artykuł
    ✅ PUT /api/articles/:id - edycja artykułu
    ✅ DELETE /api/articles/:id - usuwanie artykułu
    ✅ POST /api/articles/:id/like - like/dislike
2.3. Endpointy komentarzy
    ✅ GET /api/comments/:id - komentarze artykułu
    ✅ POST /api/comments/:id - dodawanie komentarza
    ✅ PUT /api/comments/:id - edycja komentarza
    ✅ DELETE /api/comments/:id - usuwanie komentarza
2.4. Endpointy użytkowników
    ✅ GET /api/users/profile - profil użytkownika
    ✅ PUT /api/users/profile - edycja profilu
    ✅ PUT /api/users/password - zmiana hasła
2.5. Endpointy administracyjne
    ✅ GET /api/admin/pending-users - lista użytkowników oczekujących
    ✅ POST /api/admin/approve/:id - zatwierdzanie użytkownika
    ✅ DELETE /api/admin/reject/:id - odrzucanie użytkownika

🔵 ETAP 3: OPTYMALIZACJA I ZABEZPIECZENIA - 🔄 0%

3.1. Bezpieczeństwo
    ✅ Rate limiting dla wszystkich endpointów
    ✅ Weryfikacja sanitization
    ✅ Content Security Policy headers

3.2. Wydajność
    ✅ Cache'owanie odpowiedzi (Redis)
    ⚪ Optymalizacja zapytań MongoDB
    ⚪ Paginacja dla wszystkich list

3.3. Logowanie i monitoring
    ⚪ Strukturalne logowanie (JSON)
    ⚪ Dodanie request IDs
    ⚪ Metryki wydajności

🟣 ETAP 4: ROZSZERZENIE FUNKCJONALNOŚCI - 🔄 0%

4.1. API Documentation
    ⚪ Swagger/OpenAPI documentation
    ⚪ API versioning przygotowanie

4.2. Zaawansowane features
    ⚪ Full-text search (Elasticsearch)
    ⚪ Notifications system
    ⚪ File upload optimization
    ⚪ Background jobs (bull.js)

4.3. DevOps przygotowanie
    ⚪ Dockerfile i docker-compose
    ⚪ Environment-based configuration
    ⚪ Health checks i readiness probe


==================================
__tests__\controllers\adminController.test.js v.1
==================================

// __tests__/controllers/adminController.test.js
const adminController = require('../../controllers/adminController');
const PendingUser = require('../../models/PendingUser');
const User = require('../../models/User');
const { sendMail } = require('../../utils/mailer');
/* eslint-disable no-unused-vars */
const AppError = require('../../utils/AppError');
/* eslint-enable no-unused-vars */
const bcrypt = require('bcryptjs');

// Mockujemy zależności
jest.mock('../../models/PendingUser');
jest.mock('../../models/User');
jest.mock('../../utils/mailer');
jest.mock('bcryptjs');
jest.mock('../../utils/AppError', () => {
  return jest.fn().mockImplementation((message, statusCode) => {
    const error = new Error(message);
    error.statusCode = statusCode;
    return error;
  });
});

describe('Kontroler: adminController', () => {
  let req, res, next;

  beforeEach(() => {
    jest.clearAllMocks();

    // Mock request, response i next
    req = {
      query: {},
      params: {},
      body: {},
    };
    res = {
      json: jest.fn(),
      status: jest.fn().mockReturnThis(),
    };
    next = jest.fn();
  });

  describe('getPendingUsers', () => {
    it('Powinien zwrócić listę użytkowników oczekujących z paginacją', async () => {
      // ARRANGE
      req.query = { page: '1', limit: '10', search: 'test' };
      const mockUsers = [
        { _id: '1', username: 'testuser1', email: 'test1@example.com' },
        { _id: '2', username: 'testuser2', email: 'test2@example.com' },
      ];

      PendingUser.countDocuments.mockResolvedValue(2);
      PendingUser.find.mockReturnValue({
        sort: jest.fn().mockReturnThis(),
        skip: jest.fn().mockReturnThis(),
        limit: jest.fn().mockReturnThis(),
        lean: jest.fn().mockResolvedValue(mockUsers),
      });

      // ACT
      await adminController.getPendingUsers(req, res, next);

      // ASSERT
      expect(PendingUser.countDocuments).toHaveBeenCalledWith({
        $or: [
          { username: { $regex: 'test', $options: 'i' } },
          { email: { $regex: 'test', $options: 'i' } },
        ],
      });
      expect(res.json).toHaveBeenCalledWith({
        total: 2,
        page: 1,
        limit: 10,
        users: mockUsers,
      });
    });

    it('Powinien obsłużyć błąd podczas pobierania użytkowników', async () => {
      // ARRANGE
      const error = new Error('Database error');
      PendingUser.countDocuments.mockRejectedValue(error);

      // ACT
      await adminController.getPendingUsers(req, res, next);

      // ASSERT
      expect(next).toHaveBeenCalledWith(error);
    });
  });

  describe('approveUser', () => {
    it('Powinien zatwierdzić użytkownika i wysłać email', async () => {
      // ARRANGE
      req.params = { id: 'pending123' };
      const mockPendingUser = {
        _id: 'pending123',
        username: 'testuser',
        email: 'test@example.com',
        password: 'rawpassword',
        role: 'user',
        deleteOne: jest.fn().mockResolvedValue(true),
      };

      const mockSavedUser = {
        _id: 'newUserId123', // ✅ TUTAJ JEST _id
        username: 'testuser',
        email: 'test@example.com',
        role: 'user',
      };

      PendingUser.findById.mockResolvedValue(mockPendingUser);
      User.findOne.mockResolvedValue(null);

      // Mock bcrypt.hash
      bcrypt.hash.mockResolvedValue('hashedpassword');

      // Mock User constructor and save - ZWRACA OBIEKT Z _id
      const mockSave = jest.fn().mockResolvedValue(mockSavedUser);
      User.mockImplementation(() => ({
        save: mockSave,
      }));

      sendMail.mockResolvedValue(true);

      // ACT
      await adminController.approveUser(req, res, next);

      // ASSERT
      expect(PendingUser.findById).toHaveBeenCalledWith('pending123');
      expect(User.findOne).toHaveBeenCalledWith({ email: 'test@example.com' });
      expect(bcrypt.hash).toHaveBeenCalledWith('rawpassword', 10);
      expect(User).toHaveBeenCalledWith({
        username: 'testuser',
        email: 'test@example.com',
        password: 'hashedpassword',
        role: 'user',
      });
      expect(mockSave).toHaveBeenCalled();
      expect(sendMail).toHaveBeenCalled();
      expect(res.json).toHaveBeenCalledWith({
        message: 'Użytkownik zatwierdzony i dodany do systemu.',
        userId: 'newUserId123', // ✅ TERAZ BĘDZIE PASOWAĆ
      });
    });

    it('Powinien rzucić błąd gdy wniosek nie istnieje', async () => {
      // ARRANGE
      req.params = { id: 'nonexistent' };
      PendingUser.findById.mockResolvedValue(null);

      // ACT
      await adminController.approveUser(req, res, next);

      // ASSERT
      expect(next).toHaveBeenCalledWith(expect.any(Error));
      expect(next.mock.calls[0][0].statusCode).toBe(404);
    });

    it('Powinien rzucić błąd gdy email już istnieje w systemie', async () => {
      // ARRANGE
      req.params = { id: 'pending123' };
      const mockPendingUser = {
        _id: 'pending123',
        email: 'existing@example.com',
        deleteOne: jest.fn().mockResolvedValue(true),
      };

      PendingUser.findById.mockResolvedValue(mockPendingUser);
      User.findOne.mockResolvedValue({ email: 'existing@example.com' });

      // ACT
      await adminController.approveUser(req, res, next);

      // ASSERT
      expect(next).toHaveBeenCalledWith(expect.any(Error));
      expect(next.mock.calls[0][0].statusCode).toBe(400);
    });
  });

  describe('rejectUser', () => {
    it('Powinien odrzucić użytkownika i wysłać email', async () => {
      // ARRANGE
      req.params = { id: 'pending123' };
      const mockPendingUser = {
        _id: 'pending123',
        username: 'testuser',
        email: 'test@example.com',
        deleteOne: jest.fn().mockResolvedValue(true),
      };

      PendingUser.findById.mockResolvedValue(mockPendingUser);
      sendMail.mockResolvedValue(true);

      // ACT
      await adminController.rejectUser(req, res, next);

      // ASSERT
      expect(PendingUser.findById).toHaveBeenCalledWith('pending123');
      expect(sendMail).toHaveBeenCalled();
      expect(mockPendingUser.deleteOne).toHaveBeenCalled();
      expect(res.json).toHaveBeenCalledWith({
        message: 'Wniosek został odrzucony.',
      });
    });

    it('Powinien obsłużyć błąd wysyłki emaila przy odrzuceniu', async () => {
      // ARRANGE
      req.params = { id: 'pending123' };
      const mockPendingUser = {
        _id: 'pending123',
        username: 'testuser',
        email: 'test@example.com',
        deleteOne: jest.fn().mockResolvedValue(true),
      };

      PendingUser.findById.mockResolvedValue(mockPendingUser);
      const mailError = new Error('SMTP error');
      sendMail.mockRejectedValue(mailError);

      // ACT
      await adminController.rejectUser(req, res, next);

      // ASSERT
      expect(sendMail).toHaveBeenCalled();
      expect(mockPendingUser.deleteOne).toHaveBeenCalled();
      expect(res.json).toHaveBeenCalledWith({
        message: 'Wniosek został odrzucony.',
      });
    });

    it('Powinien rzucić błąd gdy wniosek nie istnieje', async () => {
      // ARRANGE
      req.params = { id: 'nonexistent' };
      PendingUser.findById.mockResolvedValue(null);

      // ACT
      await adminController.rejectUser(req, res, next);

      // ASSERT
      expect(next).toHaveBeenCalledWith(expect.any(Error));
      expect(next.mock.calls[0][0].statusCode).toBe(404);
    });
  });
});


==================================
__tests__\integration\admin.test.js v.2
==================================

const request = require('supertest');
const mongoose = require('mongoose');
const { app, startServer, cleanupTestDatabase } = require('../../server');
const PendingUser = require('../../models/PendingUser');
const User = require('../../models/User');
const bcrypt = require('bcryptjs');

describe('Integracja: Endpointy Administracyjne', () => {
  let adminAuthToken;
  let userAuthToken;
  let _adminUser;
  let _regularUser;
  let pendingUser1;
  let pendingUser2;

  beforeAll(async () => {
    await startServer();

    // Utwórz administratora
    const hashedAdminPassword = await bcrypt.hash('admin123', 10);
    _adminUser = await User.create({
      email: 'admin@example.com',
      password: hashedAdminPassword,
      username: 'adminuser',
      role: 'admin',
    });

    // Utwórz zwykłego użytkownika
    const hashedUserPassword = await bcrypt.hash('user123', 10);
    _regularUser = await User.create({
      email: 'regular@example.com',
      password: hashedUserPassword,
      username: 'regularuser',
      role: 'user',
    });

    // Utwórz użytkowników oczekujących
    pendingUser1 = await PendingUser.create({
      username: 'pendinguser1',
      email: 'pending1@example.com',
      password: 'pendingpass1',
      role: 'user',
    });

    pendingUser2 = await PendingUser.create({
      username: 'pendinguser2',
      email: 'pending2@example.com',
      password: 'pendingpass2',
      role: 'author',
    });

    // Login jako admin aby dostać token
    const adminLoginResponse = await request(app).post('/api/auth/login').send({
      email: 'admin@example.com',
      password: 'admin123',
    });
    adminAuthToken = adminLoginResponse.headers['set-cookie'][0];

    // Login jako zwykły użytkownik
    const userLoginResponse = await request(app).post('/api/auth/login').send({
      email: 'regular@example.com',
      password: 'user123',
    });
    userAuthToken = userLoginResponse.headers['set-cookie'][0];
  });

  afterAll(async () => {
    await PendingUser.deleteMany({});
    await User.deleteMany({});
    await cleanupTestDatabase();
  });

  // 1. GET /api/admin/pending-users
  describe('GET /api/admin/pending-users', () => {
    it('Powinien zwrócić listę użytkowników oczekujących dla administratora', async () => {
      const response = await request(app)
        .get('/api/admin/pending-users')
        .set('Cookie', adminAuthToken);

      expect(response.status).toBe(200);
      expect(response.body).toHaveProperty('users');
      expect(Array.isArray(response.body.users)).toBe(true);
      expect(response.body.users.length).toBe(2);
      expect(response.body).toHaveProperty('total', 2);
    });

    it('Powinien zwrócić błąd 403 dla zwykłego użytkownika', async () => {
      const response = await request(app)
        .get('/api/admin/pending-users')
        .set('Cookie', userAuthToken);

      expect(response.status).toBe(403);
    });

    it('Powinien zwrócić błąd 401 gdy brak autoryzacji', async () => {
      const response = await request(app).get('/api/admin/pending-users');

      expect(response.status).toBe(401);
    });
  });

  // 2. POST /api/admin/approve/:id
  describe('POST /api/admin/approve/:id', () => {
    it('Powinien zatwierdzić użytkownika oczekującego', async () => {
      const response = await request(app)
        .post(`/api/admin/approve/${pendingUser1._id}`)
        .set('Cookie', adminAuthToken);

      expect(response.status).toBe(200);
      expect(response.body).toHaveProperty(
        'message',
        'Użytkownik zatwierdzony i dodany do systemu.',
      );
      expect(response.body).toHaveProperty('userId');

      // Sprawdź czy użytkownik został przeniesiony do kolekcji User
      const approvedUser = await User.findOne({
        email: 'pending1@example.com',
      });
      expect(approvedUser).not.toBeNull();
      expect(approvedUser.username).toBe('pendinguser1');

      // Sprawdź czy użytkownik został usunięty z kolekcji PendingUser
      const pendingUser = await PendingUser.findById(pendingUser1._id);
      expect(pendingUser).toBeNull();
    });

    it('Powinien zwrócić błąd 404 dla nieistniejącego użytkownika oczekującego', async () => {
      const fakeId = new mongoose.Types.ObjectId();

      const response = await request(app)
        .post(`/api/admin/approve/${fakeId}`)
        .set('Cookie', adminAuthToken);

      expect(response.status).toBe(404);
    });

    it('Powinien zwrócić błąd 403 dla zwykłego użytkownika', async () => {
      const response = await request(app)
        .post(`/api/admin/approve/${pendingUser2._id}`)
        .set('Cookie', userAuthToken);

      expect(response.status).toBe(403);
    });
  });

  // 3. DELETE /api/admin/reject/:id
  describe('DELETE /api/admin/reject/:id', () => {
    it('Powinien odrzucić użytkownika oczekującego', async () => {
      const response = await request(app)
        .delete(`/api/admin/reject/${pendingUser2._id}`)
        .set('Cookie', adminAuthToken);

      expect(response.status).toBe(200);
      expect(response.body).toHaveProperty(
        'message',
        'Wniosek został odrzucony.',
      );

      // Sprawdź czy użytkownik został usunięty z kolekcji PendingUser
      const rejectedUser = await PendingUser.findById(pendingUser2._id);
      expect(rejectedUser).toBeNull();

      // Sprawdź czy użytkownik NIE został dodany do kolekcji User
      const userInSystem = await User.findOne({
        email: 'pending2@example.com',
      });
      expect(userInSystem).toBeNull();
    });

    it('Powinien zwrócić błąd 404 dla nieistniejącego użytkownika oczekującego', async () => {
      const fakeId = new mongoose.Types.ObjectId();

      const response = await request(app)
        .delete(`/api/admin/reject/${fakeId}`)
        .set('Cookie', adminAuthToken);

      expect(response.status).toBe(404);
    });

    it('Powinien zwrócić błąd 403 dla zwykłego użytkownika', async () => {
      // Utwórz kolejnego użytkownika oczekującego do testu
      const testPendingUser = await PendingUser.create({
        username: 'testreject',
        email: 'testreject@example.com',
        password: 'testpass',
        role: 'user',
      });

      const response = await request(app)
        .delete(`/api/admin/reject/${testPendingUser._id}`)
        .set('Cookie', userAuthToken);

      expect(response.status).toBe(403);

      // Posprzątaj
      await PendingUser.findByIdAndDelete(testPendingUser._id);
    });
  });
});


==================================
__tests__\integration\articles.test.js v.2
==================================

// __tests__/integration/articles.test.js
const request = require('supertest');
const mongoose = require('mongoose');
const { app, startServer, cleanupTestDatabase } = require('../../server');
const Article = require('../../models/Article');
const User = require('../../models/User');
const bcrypt = require('bcryptjs');

describe('Integracja: Endpointy Artykułów', () => {
  let authToken;
  let testUser;

  beforeAll(async () => {
    await startServer();

    // Utwórz testowego użytkownika i zaloguj
    const hashedPassword = await bcrypt.hash('test123', 10);
    testUser = await User.create({
      email: 'author@example.com',
      password: hashedPassword,
      username: 'author',
      role: 'author',
    });

    // Login aby dostać token
    const loginResponse = await request(app).post('/api/auth/login').send({
      email: 'author@example.com',
      password: 'test123',
    });

    authToken = loginResponse.headers['set-cookie'][0];
  });

  afterEach(async () => {
    await Article.deleteMany({});
  });

  afterAll(async () => {
    await User.deleteMany({});
    await cleanupTestDatabase();
  });

  // ✅ TEST 1: GET /api/articles - lista z paginacją
  describe('GET /api/articles', () => {
    it('Powinien zwrócić listę artykułów z paginacją', async () => {
      // Utwórz testowe artykuły
      await Article.create([
        {
          title: 'Test Article 1',
          content: 'Content of article 1',
          author: testUser._id,
          images: [],
        },
        {
          title: 'Test Article 2',
          content: 'Content of article 2',
          author: testUser._id,
          images: [],
        },
      ]);

      const response = await request(app)
        .get('/api/articles?page=1&limit=2')
        .set('Cookie', authToken);

      expect(response.status).toBe(200);
      expect(response.body).toHaveProperty('articles');
      expect(response.body).toHaveProperty('total');
      expect(response.body.articles).toHaveLength(2);
    });
  });

  // ✅ TEST 2: POST /api/articles - tworzenie artykułu
  describe('POST /api/articles', () => {
    it('Powinien utworzyć nowy artykuł', async () => {
      const response = await request(app)
        .post('/api/articles')
        .set('Cookie', authToken)
        .field('title', 'New Test Article')
        .field('content', 'This is the content of the new article')
        .attach('images', Buffer.from('test'), 'test.jpg');

      expect(response.status).toBe(201);
      expect(response.body).toHaveProperty('message', 'Artykuł utworzony');
      expect(response.body).toHaveProperty('article');
    });
  });

  // ✅ TEST 3: GET /api/articles/:id - pojedynczy artykuł
  describe('GET /api/articles/:id', () => {
    it('Powinien zwrócić pojedynczy artykuł', async () => {
      const article = await Article.create({
        title: 'Single Article',
        content: 'Content for single article',
        author: testUser._id,
        images: [],
      });

      const response = await request(app)
        .get(`/api/articles/${article._id}`)
        .set('Cookie', authToken);

      expect(response.status).toBe(200);
      expect(response.body).toHaveProperty('title', 'Single Article');
    });
  });

  // ✅ TEST 4: PUT /api/articles/:id - edycja artykułu
  describe('PUT /api/articles/:id', () => {
    it('Powinien zaktualizować artykuł', async () => {
      const article = await Article.create({
        title: 'Old Title',
        content: 'Old content',
        author: testUser._id,
        images: [],
      });

      const response = await request(app)
        .put(`/api/articles/${article._id}`)
        .set('Cookie', authToken)
        .send({
          title: 'Updated Title',
          content: 'This is updated content that is longer than 20 characters', // Minimum 20 znaków
        });

      expect(response.status).toBe(200);
      expect(response.body).toHaveProperty('message', 'Artykuł zaktualizowany');
    });
  });

  // ✅ TEST 5: DELETE /api/articles/:id - usuwanie artykułu
  describe('DELETE /api/articles/:id', () => {
    it('Powinien usunąć artykuł', async () => {
      const article = await Article.create({
        title: 'Article to delete',
        content: 'Content to delete',
        author: testUser._id,
        images: [],
      });

      const response = await request(app)
        .delete(`/api/articles/${article._id}`)
        .set('Cookie', authToken);

      expect(response.status).toBe(204);
    });
  });

  // ✅ TEST 6: POST /api/articles/:id/like - like/dislike
  describe('POST /api/articles/:id/like', () => {
    it('Powinien dodać like do artykułu', async () => {
      const article = await Article.create({
        title: 'Article to like',
        content: 'Content to like',
        author: new mongoose.Types.ObjectId(), // Inny autor
        images: [],
      });

      const response = await request(app)
        .post(`/api/articles/${article._id}/like`)
        .set('Cookie', authToken);

      expect(response.status).toBe(200);
      expect(response.body).toHaveProperty('liked', true);
    });
  });
});


==================================
__tests__\integration\auth.test.js v.1
==================================

// __tests__/integration/auth.test.js
const request = require('supertest');
const { app, startServer, cleanupTestDatabase } = require('../../server');
const User = require('../../models/User');
const PendingUser = require('../../models/PendingUser');
const bcrypt = require('bcryptjs');

describe('Integracja: Endpointy Autentykacji', () => {
  beforeAll(async () => {
    await startServer();
  });

  afterEach(async () => {
    // Czyść wszystkie kolekcje po każdym teście
    await User.deleteMany({});
    await PendingUser.deleteMany({});
  });

  afterAll(async () => {
    await cleanupTestDatabase();
  });

  describe('POST /api/auth/login', () => {
    it('Powinien zalogować użytkownika i zwrócić cookie z tokenem', async () => {
      // 1. Utwórz aktywnego użytkownika
      const hashedPassword = await bcrypt.hash('test123', 10);
      await User.create({
        email: 'test@example.com',
        password: hashedPassword,
        username: 'testuser',
        role: 'user',
      });

      // 2. Wyślij request login
      const response = await request(app).post('/api/auth/login').send({
        email: 'test@example.com',
        password: 'test123',
      });

      // 3. Sprawdź response
      expect(response.status).toBe(200);
      expect(response.body).toEqual({ message: 'Zalogowano pomyślnie.' });

      // 4. Sprawdź czy token jest w cookies
      const cookies = response.headers['set-cookie'];
      expect(cookies).toBeDefined();
      expect(cookies.some((cookie) => cookie.includes('token'))).toBe(true);
    });

    it('Powinien zwrócić błąd 400 dla nieprawidłowych danych', async () => {
      const response = await request(app).post('/api/auth/login').send({
        email: 'wrong@example.com',
        password: 'wrongpassword',
      });

      expect(response.status).toBe(400);
      expect(response.body).toEqual({
        message: 'Nieprawidłowy email lub hasło.',
      });
    });

    it('Powinien zwrócić błąd 400 dla brakującego emaila', async () => {
      const response = await request(app).post('/api/auth/login').send({
        password: 'test123',
      });

      expect(response.status).toBe(400);
      expect(response.body).toHaveProperty('message');
    });
  });

  describe('POST /api/auth/register-pending', () => {
    it('Powinien zarejestrować użytkownika oczekującego', async () => {
      const response = await request(app)
        .post('/api/auth/register-pending')
        .send({
          username: 'newuser',
          email: 'new@example.com',
          password: 'password123',
          role: 'user',
        });

      expect(response.status).toBe(201);
      expect(response.body).toEqual({
        message: 'Wniosek o rejestrację został przesłany.',
      });

      // Sprawdź czy użytkownik jest w kolekcji pending
      const pendingUser = await PendingUser.findOne({
        email: 'new@example.com',
      });
      expect(pendingUser).not.toBeNull();
      expect(pendingUser.username).toBe('newuser');
    });

    it('Powinien zwrócić błąd 400 dla zajętego emaila', async () => {
      // Najpierw utwórz użytkownika
      await PendingUser.create({
        username: 'existing',
        email: 'existing@example.com',
        password: 'password123',
        role: 'user',
      });

      const response = await request(app)
        .post('/api/auth/register-pending')
        .send({
          username: 'newuser',
          email: 'existing@example.com', // Ten sam email
          password: 'password123',
          role: 'user',
        });

      expect(response.status).toBe(400);
      expect(response.body).toEqual({ message: 'Email jest już zajęty.' });
    });
  });

  describe('POST /api/auth/logout', () => {
    it('Powinien wylogować użytkownika i wyczyścić cookie', async () => {
      const response = await request(app).post('/api/auth/logout').send();

      expect(response.status).toBe(200);
      expect(response.body).toEqual({ message: 'Wylogowano.' });

      // Sprawdź czy cookie jest czyszczone
      const cookies = response.headers['set-cookie'];
      expect(cookies).toBeDefined();
      expect(cookies.some((cookie) => cookie.includes('token=;'))).toBe(true);
    });
  });
});


==================================
__tests__\integration\cache.test.js v.1
==================================

// __tests__/integration/cache.test.js
const request = require('supertest');
const { app, startServer, cleanupTestDatabase } = require('../../server');
const redisClient = require('../../utils/redisClient');

describe('Integracja: Cache Redis', () => {
  beforeAll(async () => {
    await startServer();
  });

  afterAll(async () => {
    await redisClient.disconnect();
    await cleanupTestDatabase();
  });

  it('Powinien cache\'ować odpowiedzi GET /api/articles', async () => {
    // Pierwsze request - cache MISS
    const response1 = await request(app).get('/api/articles');
    expect(response1.status).toBe(200);

    // Drugie request - cache HIT
    const response2 = await request(app).get('/api/articles');
    expect(response2.status).toBe(200);

    // Sprawdź nagłówki lub czas odpowiedzi
    // (w rzeczywistości cache jest transparentny dla klienta)
  });

  it('Nie powinien cache\'ować POST requests', async () => {
    const response = await request(app)
      .post('/api/articles')
      .set('Cookie', authToken) // potrzebny token
      .send({ title: 'Test', content: 'Content' });
    
    expect(response.status).toBe(201);
    // POST nie powinien być cache'owany
  });
});

==================================
__tests__\integration\comments.test.js v.2
==================================

const request = require('supertest');
const mongoose = require('mongoose');
const { app, startServer, cleanupTestDatabase } = require('../../server');
const Article = require('../../models/Article');
const Comment = require('../../models/Comment');
const User = require('../../models/User');
const bcrypt = require('bcryptjs');

describe('Integracja: Endpointy Komentarzy', () => {
  let authToken;
  let testUser;
  let testArticle;
  let testComment;

  beforeAll(async () => {
    await startServer();

    // Utwórz testowego użytkownika i zaloguj
    const hashedPassword = await bcrypt.hash('test123', 10);
    testUser = await User.create({
      email: 'commenter@example.com',
      password: hashedPassword,
      username: 'commenter',
      role: 'user',
    });

    // Login aby dostać token
    const loginResponse = await request(app).post('/api/auth/login').send({
      email: 'commenter@example.com',
      password: 'test123',
    });

    authToken = loginResponse.headers['set-cookie'][0];
  });

  beforeEach(async () => {
    // Utwórz testowy artykuł przed każdym testem
    testArticle = await Article.create({
      title: 'Test Article for Comments',
      content:
        'Content for comments test. This should be long enough for validation.',
      author: testUser._id,
      images: [],
    });

    // Utwórz testowy komentarz
    testComment = await Comment.create({
      text: 'Initial test comment for testing purposes',
      article: testArticle._id,
      author: testUser._id,
    });
  });

  afterEach(async () => {
    await Comment.deleteMany({});
    await Article.deleteMany({});
  });

  afterAll(async () => {
    await User.deleteMany({});
    await cleanupTestDatabase();
  });

  // 1. GET /api/comments/:id (articleId)
  describe('GET /api/comments/:id', () => {
    it('Powinien zwrócić listę komentarzy dla artykułu', async () => {
      const response = await request(app)
        .get(`/api/comments/${testArticle._id}`)
        .set('Cookie', authToken);

      expect(response.status).toBe(200);
      expect(Array.isArray(response.body)).toBe(true);
      expect(response.body.length).toBe(1);
      expect(response.body[0]).toHaveProperty(
        'text',
        'Initial test comment for testing purposes',
      );
    });

    it('Powinien zwrócić pustą listę gdy brak komentarzy', async () => {
      await Comment.deleteMany({});

      const response = await request(app)
        .get(`/api/comments/${testArticle._id}`)
        .set('Cookie', authToken);

      expect(response.status).toBe(200);
      expect(Array.isArray(response.body)).toBe(true);
      expect(response.body.length).toBe(0);
    });

    it('Powinien zwrócić pustą listę dla nieistniejącego artykułu', async () => {
      const fakeArticleId = new mongoose.Types.ObjectId();

      const response = await request(app)
        .get(`/api/comments/${fakeArticleId}`)
        .set('Cookie', authToken);

      expect(response.status).toBe(200);
      expect(Array.isArray(response.body)).toBe(true);
      expect(response.body.length).toBe(0); // Pusta tablica zamiast błędu 404
    });
  });

  // 2. POST /api/comments/:id (articleId)
  describe('POST /api/comments/:id', () => {
    it('Powinien dodać komentarz do artykułu', async () => {
      const newComment = {
        text: 'This is a new test comment with sufficient length',
      };

      const response = await request(app)
        .post(`/api/comments/${testArticle._id}`)
        .set('Cookie', authToken)
        .send(newComment);

      expect(response.status).toBe(201);
      expect(response.body).toHaveProperty('text', newComment.text);
      expect(response.body).toHaveProperty(
        'article',
        testArticle._id.toString(),
      );
      expect(response.body).toHaveProperty('author');

      // Sprawdź czy komentarz jest w bazie
      const comments = await Comment.find({ article: testArticle._id });
      expect(comments).toHaveLength(2);
    });

    it('Powinien zwrócić błąd 400 dla zbyt krótkiego komentarza', async () => {
      const shortComment = {
        text: 'Short', // 5 znaków < 6 wymaganych
      };

      const response = await request(app)
        .post(`/api/comments/${testArticle._id}`)
        .set('Cookie', authToken)
        .send(shortComment);

      expect(response.status).toBe(400);
      expect(response.body).toHaveProperty('message');
    });

    it('Powinien zwrócić błąd 404 dla nieistniejącego artykułu', async () => {
      const fakeArticleId = new mongoose.Types.ObjectId();
      const newComment = {
        text: 'Comment for non-existent article',
      };

      const response = await request(app)
        .post(`/api/comments/${fakeArticleId}`)
        .set('Cookie', authToken)
        .send(newComment);

      expect(response.status).toBe(404);
    });
  });

  // 3. PUT /api/comments/:id (commentId)
  describe('PUT /api/comments/:id', () => {
    it('Powinien zaktualizować komentarz', async () => {
      const updatedText = 'This is an updated comment with sufficient length';

      const response = await request(app)
        .put(`/api/comments/${testComment._id}`)
        .set('Cookie', authToken)
        .send({ text: updatedText });

      expect(response.status).toBe(200);
      expect(response.body).toHaveProperty('text', updatedText);

      // Sprawdź czy komentarz został zaktualizowany w bazie
      const updatedComment = await Comment.findById(testComment._id);
      expect(updatedComment.text).toBe(updatedText);
    });

    it('Powinien zwrócić błąd 403 przy próbie edycji cudzego komentarza', async () => {
      // Utwórz innego użytkownika
      const otherUser = await User.create({
        email: 'other@example.com',
        password: await bcrypt.hash('test123', 10),
        username: 'otheruser',
        role: 'user',
      });

      // Utwórz komentarz jako inny użytkownik
      const otherComment = await Comment.create({
        text: 'Other user comment',
        article: testArticle._id,
        author: otherUser._id,
      });

      const response = await request(app)
        .put(`/api/comments/${otherComment._id}`)
        .set('Cookie', authToken)
        .send({ text: 'Trying to edit someone else comment' });

      expect(response.status).toBe(403);
    });

    it('Powinien zwrócić błąd 404 dla nieistniejącego komentarza', async () => {
      const fakeCommentId = new mongoose.Types.ObjectId();

      const response = await request(app)
        .put(`/api/comments/${fakeCommentId}`)
        .set('Cookie', authToken)
        .send({ text: 'Trying to update non-existent comment' });

      expect(response.status).toBe(404);
    });
  });

  // 4. DELETE /api/comments/:id (commentId)
  describe('DELETE /api/comments/:id', () => {
    it('Powinien usunąć komentarz', async () => {
      const response = await request(app)
        .delete(`/api/comments/${testComment._id}`)
        .set('Cookie', authToken);

      expect(response.status).toBe(204);

      // Sprawdź czy komentarz został usunięty z bazy
      const deletedComment = await Comment.findById(testComment._id);
      expect(deletedComment).toBeNull();
    });

    it('Powinien zwrócić błąd 403 przy próbie usunięcia cudzego komentarza', async () => {
      // Utwórz innego użytkownika
      const otherUser = await User.create({
        email: 'other2@example.com',
        password: await bcrypt.hash('test123', 10),
        username: 'otheruser2',
        role: 'user',
      });

      // Utwórz komentarz jako inny użytkownik
      const otherComment = await Comment.create({
        text: 'Other user comment to delete',
        article: testArticle._id,
        author: otherUser._id,
      });

      const response = await request(app)
        .delete(`/api/comments/${otherComment._id}`)
        .set('Cookie', authToken);

      expect(response.status).toBe(403);
    });

    it('Powinien zwrócić błąd 404 dla nieistniejącego komentarza', async () => {
      const fakeCommentId = new mongoose.Types.ObjectId();

      const response = await request(app)
        .delete(`/api/comments/${fakeCommentId}`)
        .set('Cookie', authToken);

      expect(response.status).toBe(404);
    });
  });
});


==================================
__tests__\integration\csp.test.js v.1
==================================

// __tests__/integration/csp.test.js
const request = require('supertest');
const { app, startServer, cleanupTestDatabase } = require('../../server');

describe('Integracja: Content Security Policy', () => {
  beforeAll(async () => {
    await startServer();
  });

  afterAll(async () => {
    await cleanupTestDatabase();
  });

  it('Powinien zwracać nagłówki Content-Security-Policy', async () => {
    const response = await request(app).get('/api/articles');

    expect(response.status).toBe(200);
    expect(response.headers).toHaveProperty('content-security-policy');
    
    const cspHeader = response.headers['content-security-policy'];
    expect(cspHeader).toBeDefined();
    expect(cspHeader).toContain("default-src 'self'");
  });

  it('Powinien pozwalać na obrazy z data URI', async () => {
    const response = await request(app).get('/api/articles');
    
    const cspHeader = response.headers['content-security-policy'];
    expect(cspHeader).toContain("img-src 'self' data:");
  });

  it('Powinien blokować obiekty embedded', async () => {
    const response = await request(app).get('/api/articles');
    
    const cspHeader = response.headers['content-security-policy'];
    expect(cspHeader).toContain("object-src 'none'");
  });
});

==================================
__tests__\integration\performance.test.js v.1
==================================

// __tests__/integration/performance.test.js
const { app, startServer } = require('../../server');

describe('Wydajność: Testy optymalizacji', () => {
  beforeAll(async () => {
    await startServer();
  });

  it('GET /api/articles powinien być szybki (<100ms)', async () => {
    const start = Date.now();
    const response = await request(app).get('/api/articles');
    const duration = Date.now() - start;
    
    expect(response.status).toBe(200);
    expect(duration).toBeLessThan(100); // ✅ Szybko!
  });

  it('GET /api/articles?search=test powinien używać full-text index', async () => {
    const response = await request(app).get('/api/articles?search=test');
    expect(response.status).toBe(200);
    // Sprawdź w logach czy używa $text index
  });
});

==================================
__tests__\integration\rateLimit.test.js v.1
==================================

const request = require('supertest');
const { app, startServer, cleanupTestDatabase } = require('../../server');
const User = require('../../models/User');
const bcrypt = require('bcryptjs');

describe('Integracja: Rate Limiting', () => {
  let authToken;

  beforeAll(async () => {
    await startServer();

    // Utwórz testowego użytkownika
    const hashedPassword = await bcrypt.hash('test123', 10);
    await User.create({
      email: 'ratelimit@example.com',
      password: hashedPassword,
      username: 'ratelimituser',
      role: 'user',
    });

    // Zaloguj się aby dostać token
    const loginResponse = await request(app).post('/api/auth/login').send({
      email: 'ratelimit@example.com',
      password: 'test123',
    });
    authToken = loginResponse.headers['set-cookie'][0];
  });

  afterAll(async () => {
    await User.deleteMany({});
    await cleanupTestDatabase();
  });

  describe('Global Rate Limiting', () => {
    it('Powinien pozwolić na normalną liczbę żądań', async () => {
      const requests = [];
      for (let i = 0; i < 100; i++) {
        requests.push(
          request(app).get('/api/articles').set('Cookie', authToken),
        );
      }

      const responses = await Promise.all(requests);
      const successResponses = responses.filter((r) => r.status === 200);

      expect(successResponses.length).toBe(100);
    }, 30000);

    it('Powinien blokować przy zbyt wielu żądaniach z tego samego IP', async () => {
      const requests = [];
      for (let i = 0; i < 1001; i++) {
        requests.push(request(app).get('/api/articles'));
      }

      const responses = await Promise.all(requests);
      const blockedResponses = responses.filter((r) => r.status === 429);

      expect(blockedResponses.length).toBeGreaterThan(0);
      expect(blockedResponses[0].body.message).toContain('Zbyt wiele żądań');
    }, 30000);
  });

  describe('Auth Rate Limiting', () => {
    it('Powinien blokować przy zbyt wielu próbach logowania', async () => {
      const requests = [];
      // Użyj UNIKALNYCH adresów IP dla każdego żądania (omijają globalny limiter)
      for (let i = 0; i < 51; i++) {
        requests.push(
          request(app)
            .post('/api/auth/login')
            .set('X-Forwarded-For', `192.168.1.${i}`) // 🎯 RÓŻNE IP
            .send({
              email: `test${i}@example.com`,
              password: 'wrongpassword',
            }),
        );
      }

      const responses = await Promise.all(requests);
      const blockedResponses = responses.filter((r) => r.status === 429);

      expect(blockedResponses.length).toBeGreaterThan(0);
    }, 30000);
  });

  describe('Admin Rate Limiting', () => {
    it('Powinien blokować przy zbyt wielu żądaniach do admin endpointów', async () => {
      // 🎯 UTWÓRZ admina PRZED testami (bez logowania przez API)
      const adminPassword = await bcrypt.hash('admin123', 10);
      await User.create({
        email: 'adminlimit@example.com',
        password: adminPassword,
        username: 'adminlimit',
        role: 'admin',
      });

      // 🎯 SYMULOWANY token admina (omijamy rate limiting logowania)
      const adminToken =
        'token=simulated_admin_token; Path=/; HttpOnly; SameSite=Lax';

      const requests = [];
      for (let i = 0; i < 201; i++) {
        requests.push(
          request(app)
            .get('/api/admin/pending-users')
            .set('Cookie', adminToken),
        );
      }

      const responses = await Promise.all(requests);
      const blockedResponses = responses.filter((r) => r.status === 429);

      // Powinno być przynajmniej 1 zablokowane żądanie (201 > limit 200)
      expect(blockedResponses.length).toBeGreaterThan(0);
    }, 30000);
  });

  describe('Rate Limit Headers', () => {
    it('Powinien zwracać nagłówki RateLimit', async () => {
      const response = await request(app)
        .get('/api/articles')
        .set('Cookie', authToken);

      expect(response.headers).toHaveProperty('ratelimit-limit');
      expect(response.headers).toHaveProperty('ratelimit-remaining');
      expect(response.headers).toHaveProperty('ratelimit-reset');
    });
  });
});


==================================
__tests__\integration\sanitization.test.js v.3
==================================

// __tests__/integration/sanitization.test.js
const request = require('supertest');
const { app, startServer, cleanupTestDatabase } = require('../../server');
const User = require('../../models/User');
const Article = require('../../models/Article');
const bcrypt = require('bcryptjs');

describe('Integracja: Testy Sanitization i Bezpieczeństwa', () => {
  let authToken;
  let testUser;
  let testArticle;

  beforeAll(async () => {
    await startServer();

    // Utwórz testowego użytkownika
    const hashedPassword = await bcrypt.hash('test123', 10);
    testUser = await User.create({
      email: 'security@example.com',
      password: hashedPassword,
      username: 'securityuser',
      role: 'author',
    });

    // Utwórz testowy artykuł
    testArticle = await Article.create({
      title: 'Test Security Article',
      content: 'Content for security testing',
      author: testUser._id,
      images: [],
    });

    // Login aby dostać token
    const loginResponse = await request(app).post('/api/auth/login').send({
      email: 'security@example.com',
      password: 'test123',
    });
    authToken = loginResponse.headers['set-cookie'][0];
  });

  afterAll(async () => {
    await User.deleteMany({});
    await Article.deleteMany({});
    await cleanupTestDatabase();
  });

  describe('XSS Injection Tests', () => {
    it('Powinien OCZYŚCIĆ XSS w tytule artykułu (usuń wszystkie tagi)', async () => {
      const response = await request(app)
        .post('/api/articles')
        .set('Cookie', authToken)
        .field('title', '<script>alert("xss")</script>Test Title')
        .field(
          'content',
          'Normalna treść artykułu która jest wystarczająco długa.',
        )
        .attach('images', Buffer.from('test'), 'test.jpg');

      expect(response.status).toBe(201);
      expect(response.body.article.title).toBe('Test Title'); // TYLKO czysty tekst
      expect(response.body.article.title).not.toContain('<script>');
      expect(response.body.article.title).not.toContain('alert');
    });

    it('Powinien OCZYŚCIĆ XSS w komentarzach (usuń niebezpieczne, zachowaj bezpieczne)', async () => {
      const response = await request(app)
        .post(`/api/comments/${testArticle._id}`)
        .set('Cookie', authToken)
        .send({
          text: 'Safe <b>bold</b> but <img src="x" onerror="alert(1)"> dangerous <script>alert(2)</script> and <a href="https://example.com">link</a>',
        });

      expect(response.status).toBe(201);
      // POWINNO ZACHOWAĆ bezpieczne formatowanie
      expect(response.body.text).toContain('<b>bold</b>');
      expect(response.body.text).toContain('<a href="https://example.com"');
      // POWINNO USUNĄĆ niebezpieczne tagi
      expect(response.body.text).not.toContain('<img');
      expect(response.body.text).not.toContain('<script>');
      expect(response.body.text).not.toContain('onerror');
      // POWINNO ZACHOWAĆ tekst
      expect(response.body.text).toContain('Safe');
      expect(response.body.text).toContain('bold');
      expect(response.body.text).toContain('dangerous');
      expect(response.body.text).toContain('link');
    });

    it('Powinien OCZYŚCIĆ XSS w update profilu (usuń wszystkie tagi)', async () => {
      const response = await request(app)
        .put('/api/users/profile')
        .set('Cookie', authToken)
        .send({ username: '<script>alert("xss")</script>Hacker' });

      expect(response.status).toBe(200);
      expect(response.body.user.username).toBe('Hacker'); // TYLKO czysty tekst
      expect(response.body.user.username).not.toContain('<script>');
    });
  });

  describe('SQL Injection Tests', () => {
    it('Powinien bezpiecznie obsłużyć SQL injection w wyszukiwaniu', async () => {
      const response = await request(app)
        .get('/api/articles?q=test%27; DROP TABLE users;--')
        .set('Cookie', authToken);

      expect(response.status).toBe(200);
      expect(response.body).toHaveProperty('articles');
      expect(Array.isArray(response.body.articles)).toBe(true);
    });

    it('Powinien bezpiecznie obsłużyć SQL injection w parametrach', async () => {
      const maliciousId = "'; DROP TABLE users; --";
      const response = await request(app)
        .get(`/api/articles/${maliciousId}`)
        .set('Cookie', authToken);

      expect([400, 404]).toContain(response.status);
    });
  });

  describe('HTML Injection Tests', () => {
    it('Powinien OCZYŚCIĆ HTML w polach tekstowych komentarzy', async () => {
      const cleanText = 'Normalny tekst <b>pogrubiony</b> ale bezpieczny';

      const response = await request(app)
        .post(`/api/comments/${testArticle._id}`)
        .set('Cookie', authToken)
        .send({ text: cleanText });

      expect(response.status).toBe(201);
      // Bezpieczne tagi powinny pozostać
      expect(response.body.text).toContain('<b>pogrubiony</b>');
      expect(response.body.text).not.toContain('<script>');
    });
  });

  describe('Specific Sanitization Behaviors', () => {
    it('Powinien zachować podstawowe formatowanie w komentarzach', async () => {
      const response = await request(app)
        .post(`/api/comments/${testArticle._id}`)
        .set('Cookie', authToken)
        .send({
          text: 'Text with <b>bold</b>, <i>italic</i> and <a href="https://example.com">link</a> but no <script>alert(1)</script>',
        });

      expect(response.status).toBe(201);
      // Bezpieczne tagi powinny pozostać
      expect(response.body.text).toContain('<b>bold</b>');
      expect(response.body.text).toContain('<i>italic</i>');
      expect(response.body.text).toContain('<a href="https://example.com"');
      // Niebezpieczne tagi powinny być usunięte
      expect(response.body.text).not.toContain('<script>');
    });

    it('Powinien całkowicie usuwać HTML w tytułach', async () => {
      const response = await request(app)
        .post('/api/articles')
        .set('Cookie', authToken)
        .field('title', 'Title with <script>alert(1)</script> and <b>bold</b>')
        .field('content', 'Normal content here...')
        .attach('images', Buffer.from('test'), 'test.jpg');

      expect(response.status).toBe(201);
      // WSZYSTKIE tagi powinny być usunięte - nawet bezpieczne
      // Po usunięciu tagów pozostaje podwójna spacja, co jest poprawne
      expect(response.body.article.title).toBe('Title with  and bold');
      expect(response.body.article.title).not.toContain('<script>');
      expect(response.body.article.title).not.toContain('<b>');
    });

    it('Powinien pozwalać na bogate formatowanie w treści artykułów', async () => {
      const response = await request(app)
        .post('/api/articles')
        .set('Cookie', authToken)
        .field('title', 'Normal title')
        .field(
          'content',
          'Text with <b>bold</b>, <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8z8BQDwAEhQGAhKmMIQAAAABJRU5ErkJggg==" alt="test"> and <script>alert(1)</script>',
        )
        .attach('images', Buffer.from('test'), 'test.jpg');

      expect(response.status).toBe(201);
      // Bezpieczne tagi powinny pozostać
      expect(response.body.article.content).toContain('<b>bold</b>');
      // Obrazki mogą być usuwane w treści artykułów - to jest poprawne zachowanie
      expect(response.body.article.content).not.toContain('<script>');
    });
  });
});


==================================
__tests__\integration\users.test.js v.2
==================================

const request = require('supertest');
const { app, startServer, cleanupTestDatabase } = require('../../server');
const User = require('../../models/User');
const bcrypt = require('bcryptjs');

describe('Integracja: Endpointy Użytkowników', () => {
  let authToken;
  let testUser;

  beforeAll(async () => {
    await startServer();

    // Utwórz testowego użytkownika i zaloguj
    const hashedPassword = await bcrypt.hash('test123', 10);
    testUser = await User.create({
      email: 'testuser@example.com',
      password: hashedPassword,
      username: 'testuser',
      role: 'user',
    });

    // Login aby dostać token
    const loginResponse = await request(app).post('/api/auth/login').send({
      email: 'testuser@example.com',
      password: 'test123',
    });

    authToken = loginResponse.headers['set-cookie'][0];
  });

  afterAll(async () => {
    await User.deleteMany({});
    await cleanupTestDatabase();
  });

  // 1. GET /api/users/profile
  describe('GET /api/users/profile', () => {
    it('Powinien zwrócić profil zalogowanego użytkownika', async () => {
      const response = await request(app)
        .get('/api/users/profile')
        .set('Cookie', authToken);

      expect(response.status).toBe(200);
      expect(response.body).toHaveProperty('_id', testUser._id.toString());
      expect(response.body).toHaveProperty('email', 'testuser@example.com');
      expect(response.body).toHaveProperty('username', 'testuser');
      expect(response.body).toHaveProperty('role', 'user');
      expect(response.body).not.toHaveProperty('password'); // Hasło nie powinno być zwracane
    });

    it('Powinien zwrócić błąd 401 gdy brak autoryzacji', async () => {
      const response = await request(app).get('/api/users/profile');

      expect(response.status).toBe(401);
    });
  });

  // 2. PUT /api/users/profile
  describe('PUT /api/users/profile', () => {
    it('Powinien zaktualizować nazwę użytkownika', async () => {
      const updatedData = {
        username: 'updatedusername',
      };

      const response = await request(app)
        .put('/api/users/profile')
        .set('Cookie', authToken)
        .send(updatedData);

      expect(response.status).toBe(200);
      expect(response.body).toHaveProperty('message', 'Profil zaktualizowany');
      expect(response.body.user).toHaveProperty('username', 'updatedusername');
      expect(response.body.user).toHaveProperty(
        'email',
        'testuser@example.com',
      ); // Email nie powinien się zmienić

      // Sprawdź czy dane zostały zaktualizowane w bazie
      const updatedUser = await User.findById(testUser._id);
      expect(updatedUser.username).toBe('updatedusername');
    });

    it('Powinien zwrócić błąd 400 dla zbyt krótkiej nazwy użytkownika', async () => {
      const invalidData = {
        username: 'ab', // 2 znaki < 3 wymagane
      };

      const response = await request(app)
        .put('/api/users/profile')
        .set('Cookie', authToken)
        .send(invalidData);

      expect(response.status).toBe(400);
    });

    it('Powinien zwrócić błąd 401 gdy brak autoryzacji', async () => {
      const response = await request(app)
        .put('/api/users/profile')
        .send({ username: 'test' });

      expect(response.status).toBe(401);
    });
  });

  // 3. PUT /api/users/password
  describe('PUT /api/users/password', () => {
    it('Powinien zmienić hasło użytkownika', async () => {
      const passwordData = {
        oldPassword: 'test123',
        newPassword: 'newpassword123',
      };

      const response = await request(app)
        .put('/api/users/password')
        .set('Cookie', authToken)
        .send(passwordData);

      expect(response.status).toBe(200);
      expect(response.body).toHaveProperty(
        'message',
        'Hasło zostało zmienione.',
      );

      // Sprawdź czy można zalogować się nowym hasłem
      const loginResponse = await request(app).post('/api/auth/login').send({
        email: 'testuser@example.com',
        password: 'newpassword123',
      });

      expect(loginResponse.status).toBe(200);
    });

    it('Powinien zwrócić błąd 400 dla nieprawidłowego starego hasła', async () => {
      const passwordData = {
        oldPassword: 'wrongpassword',
        newPassword: 'newpassword123',
      };

      const response = await request(app)
        .put('/api/users/password')
        .set('Cookie', authToken)
        .send(passwordData);

      expect(response.status).toBe(400);
    });

    it('Powinien zwrócić błąd 400 dla zbyt krótkiego nowego hasła', async () => {
      const passwordData = {
        oldPassword: 'test123',
        newPassword: 'short', // 5 znaków < 6 wymagane
      };

      const response = await request(app)
        .put('/api/users/password')
        .set('Cookie', authToken)
        .send(passwordData);

      expect(response.status).toBe(400);
    });

    it('Powinien zwrócić błąd 401 gdy brak autoryzacji', async () => {
      const response = await request(app).put('/api/users/password').send({
        oldPassword: 'test123',
        newPassword: 'newpassword123',
      });

      expect(response.status).toBe(401);
    });
  });

  // Testy dla admin endpoints (będą w admin.test.js)
  describe('Endpointy administracyjne (będą testowane osobno)', () => {
    it('Tymczasowy test - do usunięcia', () => {
      expect(true).toBe(true);
    });
  });
});


==================================
__tests__\services\articleService.createArticle.test.js v.1
==================================

 
// Test files often need unused variables for mocks

// __tests__/services/articleService.createArticle.test.js
const articleService = require('../../services/articleService');
const Article = require('../../models/Article');
jest.mock('../../models/Article');

describe('Serwis: articleService - funkcja createArticle', () => {
  const mockTitle = 'Testowy tytuł artykułu';
  const mockContent = 'To jest treść testowego artykułu, która jest wystarczająco długa, aby spełnić wymagania.';
  const mockAuthorId = '507f1f77bcf86cd799439011';
  const mockImagePaths = ['uploads/image1.jpg', 'uploads/image2.png'];

  let mockArticleInstance;

  beforeEach(() => {
    jest.clearAllMocks();
    // 1. Tworzymy obiekt-impostor. Symuluje instancję Mongoose, która ma metodę `.save`.
    mockArticleInstance = {
      save: jest.fn(), // Mockujemy metodę save
    };
    // 2. Gdy konstruktor "Article" jest wywoływany, zwracamy naszego impostora.
    Article.mockImplementation(() => mockArticleInstance);
  });

  it('Powinien pomyślnie utworzyć artykuł z poprawnymi danymi', async () => {
    // ARRANGE
    const mockSavedArticleData = {
      _id: 'someArticleId',
      title: mockTitle,
      content: mockContent,
      author: mockAuthorId,
      images: mockImagePaths,
    };
    mockArticleInstance.save.mockResolvedValue(mockSavedArticleData);

    // ACT
    const result = await articleService.createArticle(mockTitle, mockContent, mockAuthorId, mockImagePaths);

    // ASSERT
    expect(Article).toHaveBeenCalledWith({
      title: mockTitle,
      content: mockContent,
      author: mockAuthorId,
      images: mockImagePaths,
    });
    expect(mockArticleInstance.save).toHaveBeenCalled();
    expect(result).toBe(mockArticleInstance);
  });

  it('Powinien rzucić błąd jeśli tytuł jest za krótki', async () => {
    // ARRANGE
    const shortTitle = 'A';

    // ACT & ASSERT
    await expect(articleService.createArticle(shortTitle, mockContent, mockAuthorId, mockImagePaths))
      .rejects
      .toThrow('Tytuł musi mieć co najmniej 5 znaków');
        
    // Sprawdzamy, czy save NIE został wywołany
    expect(mockArticleInstance.save).not.toHaveBeenCalled();
  });

  it('Powinien rzucić błąd jeśli treść jest za krótka', async () => {
    // ARRANGE
    const shortContent = 'Krótka';

    // ACT & ASSERT
    await expect(articleService.createArticle(mockTitle, shortContent, mockAuthorId, mockImagePaths))
      .rejects
      .toThrow('Treść musi mieć co najmniej 20 znaków');
        
    expect(mockArticleInstance.save).not.toHaveBeenCalled();
  });

  it('Powinien rzucić błąd jeśli brakuje tytułu lub treści', async () => {
    // ACT & ASSERT - brak tytułu
    await expect(articleService.createArticle('', mockContent, mockAuthorId, mockImagePaths))
      .rejects
      .toThrow(); // Może rzucić ogólny błąd walidacji

    // ACT & ASSERT - brak treści
    await expect(articleService.createArticle(mockTitle, '', mockAuthorId, mockImagePaths))
      .rejects
      .toThrow();

    expect(mockArticleInstance.save).not.toHaveBeenCalled();
  });
});

==================================
__tests__\services\articleService.getArticles.test.js v.1
==================================

// __tests__/services/articleService.getArticles.test.js
const articleService = require('../../services/articleService');
const Article = require('../../models/Article');
const Comment = require('../../models/Comment');

jest.mock('../../models/Article');
jest.mock('../../models/Comment');

describe('Serwis: articleService - funkcja getArticles', () => {
  const mockArticlesData = [
    { 
      _id: 'article1', 
      title: 'Test Article 1', 
      author: { email: 'user1@test.com' }, 
      content: 'Content 1', 
      images: [], 
      likes: [],
      createdAt: new Date('2023-01-01'),
    },
    { 
      _id: 'article2', 
      title: 'Test Article 2', 
      author: { email: 'user2@test.com' }, 
      content: 'Content 2', 
      images: [], 
      likes: ['user1'],
      createdAt: new Date('2023-01-02'),
    },
  ];

  const mockCommentCounts = { article1: 3, article2: 5 };

  // Helper function to create a chainable mock
  const createChainableMock = (finalValue) => {
    const mock = jest.fn().mockReturnThis();
    mock.sort = jest.fn().mockReturnThis();
    mock.skip = jest.fn().mockReturnThis();
    mock.limit = jest.fn().mockReturnThis();
    mock.populate = jest.fn().mockResolvedValue(finalValue);
    return mock;
  };

  beforeEach(() => {
    jest.clearAllMocks();
        
    // Mockujemy Comment.countDocuments dla każdego artykułu
    Comment.countDocuments.mockImplementation((query) => {
      const articleId = query.article.toString();
      return Promise.resolve(mockCommentCounts[articleId] || 0);
    });

    // Resetujemy wszystkie mocks Article
    Article.countDocuments.mockReset();
    Article.find.mockReset();
    Article.aggregate.mockReset();
  });

  it('Powinien zwrócić listę artykułów z paginacją (sort: newest)', async () => {
    // ARRANGE
    const page = 1, limit = 2, search = '', sort = 'newest';
    const totalCount = 2;

    // Mock standardowego find z łańcuchem metod
    Article.countDocuments.mockResolvedValue(totalCount);
    Article.find.mockImplementation(() => createChainableMock(mockArticlesData));

    // ACT
    const result = await articleService.getArticles(page, limit, search, sort);

    // ASSERT
    expect(Article.countDocuments).toHaveBeenCalled();
    expect(Article.find).toHaveBeenCalled();
    expect(result).toEqual({
      articles: [
        { 
          _id: 'article1', 
          title: 'Test Article 1', 
          content: 'Content 1',
          likesCount: 0,
          commentCount: 3,
          author: { email: 'user1@test.com' },
          thumbnail: null,
          createdAt: new Date('2023-01-01'),
        },
        { 
          _id: 'article2', 
          title: 'Test Article 2', 
          content: 'Content 2',
          likesCount: 1,
          commentCount: 5,
          author: { email: 'user2@test.com' },
          thumbnail: null,
          createdAt: new Date('2023-01-02'),
        },
      ],
      total: totalCount,
    });
  });

  it('Powinien zwrócić listę artykułów (sort: mostLiked - agregacja)', async () => {
    // ARRANGE
    const page = 1, limit = 2, search = '', sort = 'mostLiked';
    const totalCount = 2;

    // Mock agregacji MongoDB - ZWRACA TABLICĘ
    const mockAggregateResult = [
      { 
        _id: 'article1', 
        title: 'Test Article 1', 
        content: 'Content 1',
        author: { email: 'user1@test.com' },
        images: [],
        likes: [],
        likesCount: 0,
        createdAt: new Date('2023-01-01'),
      },
      { 
        _id: 'article2', 
        title: 'Test Article 2', 
        content: 'Content 2', 
        author: { email: 'user2@test.com' },
        images: [],
        likes: ['user1'],
        likesCount: 1,
        createdAt: new Date('2023-01-02'),
      },
    ];
        
    // POPRAWNY MOCK: aggregate() zwraca obiekt z metodą exec()
    Article.aggregate.mockResolvedValue(mockAggregateResult);
    Article.countDocuments.mockResolvedValue(totalCount);

    // ACT
    const result = await articleService.getArticles(page, limit, search, sort);

    // ASSERT
    expect(Article.aggregate).toHaveBeenCalled();
    expect(result.total).toBe(totalCount);
    expect(Array.isArray(result.articles)).toBe(true);
    expect(result.articles).toHaveLength(2);
    expect(result.articles[0]).toHaveProperty('commentCount');
    expect(result.articles[0]).toHaveProperty('likesCount');
    expect(result.articles[0].likesCount).toBe(0);
  });

  it('Powinien przefiltrować artykuły wyszukiwaniem (search)', async () => {
    // ARRANGE
    const page = 1, limit = 2, search = 'Test', sort = 'newest';
    const filteredArticles = [mockArticlesData[0]];
    const totalCount = 1;

    Article.countDocuments.mockResolvedValue(totalCount);
    Article.find.mockImplementation(() => createChainableMock(filteredArticles));

    // ACT
    const result = await articleService.getArticles(page, limit, search, sort);

    // ASSERT
    expect(Article.find).toHaveBeenCalledWith({
      $or: [
        { title: { $regex: 'Test', $options: 'i' } },
        { content: { $regex: 'Test', $options: 'i' } },
      ],
    });
    expect(result.total).toBe(totalCount);
    expect(result.articles).toHaveLength(1);
  });

  it('Powinien obsłużyć pustą listę artykułów', async () => {
    // ARRANGE
    const page = 1, limit = 2, search = '', sort = 'newest';
    const totalCount = 0;

    Article.countDocuments.mockResolvedValue(totalCount);
    Article.find.mockImplementation(() => createChainableMock([]));

    // ACT
    const result = await articleService.getArticles(page, limit, search, sort);

    // ASSERT
    expect(result.articles).toEqual([]);
    expect(result.total).toBe(0);
  });
});

==================================
__tests__\services\articleService.toggleLikeArticle.test.js v.1
==================================

// __tests__/services/articleService.toggleLikeArticle.test.js
const articleService = require('../../services/articleService');
const Article = require('../../models/Article');

jest.mock('../../models/Article');

describe('Serwis: articleService - funkcja toggleLikeArticle', () => {
  const mockArticleId = '507f1f77bcf86cd799439022'; // ObjectId artykułu
  const mockUserId = '507f1f77bcf86cd799439011';    // ObjectId użytkownika
  const mockAuthorId = '507f1f77bcf86cd799439033';  // ObjectId autora (inny niż userId)

  let mockArticleInstance;

  beforeEach(() => {
    jest.clearAllMocks();
        
    // 1. Tworzymy podstawową instancję artykułu
    mockArticleInstance = {
      _id: mockArticleId,
      author: mockAuthorId,
      likes: [], // Początkowo pusta tablica lików
      save: jest.fn().mockImplementation(function() { 
        // Symulujemy, że save zwraca "zapisany" obiekt (this)
        return Promise.resolve(this);
      }),
    };

    // 2. --- KLUCZOWA ZMIANA ---
    // Symulujemy, że `likes` jest tablicą Mongoose z metodą `pull`
    mockArticleInstance.likes = []; // Resetujemy tablicę
    // Dodajemy metodę `pull` do tej tablicy
    mockArticleInstance.likes.pull = jest.fn((userIdToRemove) => {
      // Implementacja pull: usuwa userId z tablicy likes
      const index = mockArticleInstance.likes.indexOf(userIdToRemove);
      if (index > -1) {
        mockArticleInstance.likes.splice(index, 1);
      }
    });
    // --- KONIEC ZMIANY ---

    // Mockujemy Article.findById aby zwracał naszą instancję
    Article.findById.mockResolvedValue(mockArticleInstance);
  });

  it('Powinien dodać like, jeśli użytkownik jeszcze nie polubił artykułu', async () => {
    // ARRANGE
    // Początkowy stan: likes = [] (użytkownik nie polubił)
    mockArticleInstance.likes = [];

    // ACT
    const result = await articleService.toggleLikeArticle(mockArticleId, mockUserId);

    // ASSERT
    // 1. Sprawdzamy, czy znaleziono artykuł
    expect(Article.findById).toHaveBeenCalledWith(mockArticleId);
    // 2. Sprawdzamy, czy save został wywołany
    expect(mockArticleInstance.save).toHaveBeenCalled();
    // 3. Sprawdzamy, czy like został dodany do tablicy (za pomocą push)
    expect(mockArticleInstance.likes).toContain(mockUserId);
    // 4. Sprawdzamy, czy wynik wskazuje na dodanie like i poprawną liczbę
    expect(result).toEqual({
      liked: true,
      totalLikes: 1, // Dodano 1 like
    });
  });

  it('Powinien usunąć like, jeśli użytkownik już polubił artykuł', async () => {
    // ARRANGE
    // Początkowy stan: użytkownik już polubił artykuł
    // NIE NADPISUJEMY tablicy, tylko MODYFIKUJEMY istniejącą
    mockArticleInstance.likes.push(mockUserId); // <- Dodajemy userId do istniejącej tablicy

    // ACT
    const result = await articleService.toggleLikeArticle(mockArticleId, mockUserId);

    // ASSERT
    expect(Article.findById).toHaveBeenCalledWith(mockArticleId);
    expect(mockArticleInstance.save).toHaveBeenCalled();
    // Like powinien zostać usunięty z tablicy (za pomocą pull)
    expect(mockArticleInstance.likes).not.toContain(mockUserId);
    // Sprawdzamy, czy metoda pull została wywołana z prawidłowym argumentem
    expect(mockArticleInstance.likes.pull).toHaveBeenCalledWith(mockUserId);
    expect(result).toEqual({
      liked: false,
      totalLikes: 0, // Usunięto 1 like
    });
  });

  it('Powinien rzucić błąd, jeśli artykuł nie istnieje', async () => {
    // ARRANGE
    Article.findById.mockResolvedValue(null); // Artykuł nie znaleziony

    // ACT & ASSERT
    await expect(articleService.toggleLikeArticle(mockArticleId, mockUserId))
      .rejects
      .toThrow('Artykuł nie znaleziony');
  });

  it('Powinien rzucić błąd, jeśli autor próbuje polubić własny artykuł', async () => {
    // ARRANGE
    // Symulujemy, że autor próbuje polubić własny artykuł
    mockArticleInstance.author = mockUserId; // Autor == userId

    // ACT & ASSERT
    await expect(articleService.toggleLikeArticle(mockArticleId, mockUserId))
      .rejects
      .toThrow('Autor nie może polubić własnego artykułu');
        
    // Save nie powinien zostać wywołany
    expect(mockArticleInstance.save).not.toHaveBeenCalled();
  });
});

==================================
__tests__\services\authService.register.pending.test.js v.1
==================================

// __tests__/services/authService.registerPending.test.js
const authService = require('../../services/authService');
const PendingUser = require('../../models/PendingUser');
const User = require('../../models/User');

// Mockujemy modele Mongoose
jest.mock('../../models/PendingUser');
jest.mock('../../models/User');

describe('Serwis: authService - funkcja registerPending', () => {
  // Dane testowe
  const mockUserData = {
    username: 'testuser',
    email: 'test@example.com',
    password: 'testpass123',
    role: 'user',
  };

  beforeEach(() => {
    jest.clearAllMocks(); // Czyścimy mocki przed każdym testem
  });

  it('Powinien pomyślnie zarejestrować użytkownika oczekującego', async () => {
    // ARRANGE
    // 1. Mockujemy, że NIE ma użytkownika w żadnej z kolekcji
    User.findOne.mockResolvedValue(null);
    PendingUser.findOne.mockResolvedValue(null);
    // 2. Mockujemy metodę `save` na nowej instancji PendingUser
    const mockSave = jest.fn().mockResolvedValue(true);
    PendingUser.mockImplementation(() => ({
      save: mockSave,
    }));

    // ACT
    // Wywołujemy funkcję - nie powinna rzucić błędem
    await expect(authService.registerPending(
      mockUserData.username,
      mockUserData.email,
      mockUserData.password,
      mockUserData.role,
    )).resolves.not.toThrow(); // Sprawdzamy, że Promise się resolves (nie rejectuje)

    // ASSERT
    // Sprawdzamy, czy findOne był wywołany z poprawnym emailem
    expect(PendingUser.findOne).toHaveBeenCalledWith({ email: mockUserData.email });
    expect(User.findOne).toHaveBeenCalledWith({ email: mockUserData.email });
    // Sprawdzamy, czy konstruktor PendingUser został wywołany z prawidłowymi danymi
    expect(PendingUser).toHaveBeenCalledWith({
      username: mockUserData.username,
      email: mockUserData.email,
      password: mockUserData.password, // jeszcze nie zahashowane!
      role: mockUserData.role,
    });
    // Sprawdzamy, czy save został wywołany na nowym obiekcie
    expect(mockSave).toHaveBeenCalled();
  });

  it('Powinien rzucić błąd jeśli użytkownik (Pending) już istnieje', async () => {
    // ARRANGE
    // Symulujemy, że użytkownik OCZEKUJĄCY już istnieje
    PendingUser.findOne.mockResolvedValue({ email: mockUserData.email });

    // ACT & ASSERT
    // Spodziewamy się, że funkcja rzuci konkretnym błędem
    await expect(authService.registerPending(
      mockUserData.username,
      mockUserData.email,
      mockUserData.password,
      mockUserData.role,
    )).rejects.toThrow('Email jest już zajęty.');
    
    // Optional: Sprawdzamy, czy findOne dla User NIE został wywołany (optymalizacja)
    // expect(User.findOne).not.toHaveBeenCalled();
  });

  it('Powinien rzucić błąd jeśli użytkownik (User) już istnieje', async () => {
    // ARRANGE
    // Symulujemy, że użytkownik ZATWIERDZONY już istnieje
    PendingUser.findOne.mockResolvedValue(null);
    User.findOne.mockResolvedValue({ email: mockUserData.email });

    // ACT & ASSERT
    await expect(authService.registerPending(
      mockUserData.username,
      mockUserData.email,
      mockUserData.password,
      mockUserData.role,
    )).rejects.toThrow('Email jest już zajęty.');
  });

  // Możesz też dodać test dla walidacji (np. brak username)
  it('Powinien rzucić błąd walidacji jeśli brakuje wymaganego pola', async () => {
    // ACT & ASSERT - pomijamy username
    await expect(authService.registerPending(
      '', // puste username
      mockUserData.email,
      mockUserData.password,
      mockUserData.role,
    )).rejects.toThrow('Nazwa użytkownika jest wymagana.');
  });
});

==================================
__tests__\services\authService.test.js v.1
==================================

// __tests__/services/authService.test.js
const authService = require('../../services/authService');
const User = require('../../models/User');
const bcrypt = require('bcryptjs');

jest.mock('../../models/User');
jest.mock('bcryptjs');

describe('Serwis: authService - funkcja login', () => {
  const mockEmail = 'test@example.com';
  const mockPassword = 'haslo123';
  const mockWrongPassword = 'zlehaslo';
  const mockUserId = '507f1f77bcf86cd799439011';

  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('Powinien rzucić błąd "Nieprawidłowy email lub hasło" jeśli użytkownik nie istnieje', async () => {
    User.findOne.mockResolvedValue(null);
    
    await expect(authService.login(mockEmail, mockPassword))
      .rejects
      .toThrow('Nieprawidłowy email lub hasło.');
    
    expect(User.findOne).toHaveBeenCalledWith({ email: mockEmail.toLowerCase() });
  });

  it('Powinien rzucić błąd "Nieprawidłowy email lub hasło" jeśli hasło jest niepoprawne', async () => {
    const mockUser = {
      _id: mockUserId,
      email: mockEmail,
      password: 'zahashowane_haslo_z_bazy',
    };
    User.findOne.mockResolvedValue(mockUser);
    bcrypt.compare.mockResolvedValue(false);

    await expect(authService.login(mockEmail, mockWrongPassword))
      .rejects
      .toThrow('Nieprawidłowy email lub hasło.');

    expect(bcrypt.compare).toHaveBeenCalledWith(mockWrongPassword, mockUser.password);
  });

  it('Powinien zwrócić token JWT gdy email i hasło są poprawne', async () => {
    const mockUser = {
      _id: mockUserId,
      email: mockEmail,
      password: 'zahashowane_haslo_z_bazy',
    };
    User.findOne.mockResolvedValue(mockUser);
    bcrypt.compare.mockResolvedValue(true);

    const result = await authService.login(mockEmail, mockPassword);

    expect(typeof result).toBe('string');
    expect(result.length).toBeGreaterThan(20);
    expect(User.findOne).toHaveBeenCalledWith({ email: mockEmail.toLowerCase() });
    expect(bcrypt.compare).toHaveBeenCalledWith(mockPassword, mockUser.password);
  });

  // Dodatkowe testy dla przypadków brzegowych
  it('Powinien rzucić błąd gdy email jest pusty', async () => {
    await expect(authService.login('', mockPassword))
      .rejects
      .toThrow('Email jest wymagany.');
  });

  it('Powinien rzucić błąd gdy hasło jest puste', async () => {
    await expect(authService.login(mockEmail, ''))
      .rejects
      .toThrow('Hasło jest wymagane.');
  });
});

==================================
__tests__\services\commentService.test.js v.1
==================================

// __tests__/services/commentService.test.js
const commentService = require('../../services/commentService');
const Comment = require('../../models/Comment');
const Article = require('../../models/Article');

jest.mock('../../models/Comment');
jest.mock('../../models/Article');

describe('Serwis: commentService', () => {
  const mockArticleId = '507f1f77bcf86cd799439022';
  const mockUserId = '507f1f77bcf86cd799439011';
  const mockCommentId = '507f1f77bcf86cd799439033';
  const mockCommentText = 'To jest bardzo przemyślany komentarz';

  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe('addComment', () => {
    it('Powinien dodać komentarz do istniejącego artykułu', async () => {
      // ARRANGE
      Article.findById.mockResolvedValue({ _id: mockArticleId });
      // Mock Comment.create zamiast new Comment().save()
      Comment.create.mockResolvedValue({
        _id: mockCommentId,
        text: mockCommentText,
        article: mockArticleId,
        author: mockUserId,
      });

      // ACT
      const result = await commentService.addComment(
        mockArticleId,
        mockUserId,
        mockCommentText,
      );

      // ASSERT
      expect(Article.findById).toHaveBeenCalledWith(mockArticleId);
      expect(Comment.create).toHaveBeenCalledWith({
        text: mockCommentText,
        article: mockArticleId,
        author: mockUserId,
      });
      expect(result.text).toBe(mockCommentText);
    });

    it('Powinien rzucić błąd jeśli artykuł nie istnieje', async () => {
      // ARRANGE
      Article.findById.mockResolvedValue(null);

      // ACT & ASSERT - Uwzględnij kropkę w komunikacie
      await expect(
        commentService.addComment(mockArticleId, mockUserId, mockCommentText),
      ).rejects.toThrow('Nie znaleziono artykułu.');
    });

    it('Powinien rzucić błąd walidacji dla zbyt krótkiego komentarza', async () => {
      // ARRANGE
      Article.findById.mockResolvedValue({ _id: mockArticleId });
      const shortText = 'Krótk';

      // ACT & ASSERT
      await expect(
        commentService.addComment(mockArticleId, mockUserId, shortText),
      ).rejects.toThrow('Komentarz musi mieć co najmniej 6 znaków');

      // Dodatkowo: upewnij się, że Comment.create NIE został wywołany
      expect(Comment.create).not.toHaveBeenCalled();
    });
  });

  describe('getComments', () => {
    it('Powinien zwrócić listę komentarzy dla artykułu', async () => {
      // ARRANGE
      const mockComments = [
        { _id: 'comment1', text: 'Komentarz 1', author: { username: 'user1' } },
        { _id: 'comment2', text: 'Komentarz 2', author: { username: 'user2' } },
      ];
      Comment.find.mockReturnValue({
        populate: jest.fn().mockReturnThis(),
        sort: jest.fn().mockResolvedValue(mockComments),
      });

      // ACT
      const result = await commentService.getComments(mockArticleId);

      // ASSERT
      expect(Comment.find).toHaveBeenCalledWith({ article: mockArticleId });
      expect(result).toEqual(mockComments);
    });
  });

  describe('updateComment', () => {
    it('Powinien zaktualizować komentarz jeśli użytkownik jest autorem', async () => {
      // ARRANGE
      const mockComment = {
        _id: mockCommentId,
        text: 'Stara treść',
        author: mockUserId,
        save: jest.fn().mockResolvedValue({
          _id: mockCommentId,
          text: 'Nowa treść',
          author: mockUserId,
        }),
      };
      Comment.findById.mockResolvedValue(mockComment);

      // ACT
      const result = await commentService.updateComment(
        mockCommentId,
        mockUserId,
        'user',
        'Nowa treść',
      );

      // ASSERT
      expect(Comment.findById).toHaveBeenCalledWith(mockCommentId);
      expect(mockComment.save).toHaveBeenCalled();
      expect(result.text).toBe('Nowa treść');
    });

    it('Powinien rzucić błąd jeśli komentarz nie istnieje', async () => {
      // ARRANGE
      Comment.findById.mockResolvedValue(null);

      // ACT & ASSERT
      await expect(
        commentService.updateComment(
          mockCommentId,
          mockUserId,
          'user',
          'Nowa treść',
        ),
      ).rejects.toThrow('Komentarz nie istnieje');
    });
  });

  describe('deleteComment', () => {
    it('Powinien usunąć komentarz jeśli użytkownik jest autorem', async () => {
      // ARRANGE
      const mockComment = {
        _id: mockCommentId,
        author: mockUserId,
        deleteOne: jest.fn().mockResolvedValue(true),
      };
      Comment.findById.mockResolvedValue(mockComment);

      // ACT
      await commentService.deleteComment(mockCommentId, mockUserId, 'user');

      // ASSERT
      expect(Comment.findById).toHaveBeenCalledWith(mockCommentId);
      expect(mockComment.deleteOne).toHaveBeenCalled();
    });
  });
});


==================================
__tests__\services\userService.integration.test.js v.2
==================================

// __tests__/services/userService.integration.test.js
const mongoose = require('mongoose');
const { MongoMemoryServer } = require('mongodb-memory-server');
const bcrypt = require('bcryptjs');
const User = require('../../models/User');
const userService = require('../../services/userService');

let mongoServer;

// ✅ Zwiększ timeout dla wszystkich testów
jest.setTimeout(30000);

beforeAll(async () => {
  try {
    mongoServer = await MongoMemoryServer.create();
    const uri = mongoServer.getUri();
    await mongoose.connect(uri);
    console.log('Connected to MongoDB Memory Server:', uri);
  } catch (error) {
    console.error('MongoDB connection error:', error);
    throw error;
  }
});

afterEach(async () => {
  try {
    await User.deleteMany({});
  } catch (error) {
    console.error('Error cleaning up users:', error);
  }
});

afterAll(async () => {
  try {
    // ✅ Bezpieczne zamykanie połączenia
    if (mongoose.connection.readyState !== 0) {
      await mongoose.disconnect();
    }
    // ✅ Bezpieczne zatrzymanie memory server
    if (mongoServer) {
      await mongoServer.stop();
    }
    console.log('MongoDB connection closed');
  } catch (error) {
    console.error('Error closing MongoDB connection:', error);
  }
});

describe('Serwis: userService - testy integracyjne', () => {
  it('Powinien stworzyć i pobrać użytkownika bez hasła', async () => {
    const user = await User.create({
      email: 'test@test.com',
      password: 'hashedPassword',
      username: 'Tester',
      role: 'user',
    });

    const profile = await userService.getProfile(user._id);

    expect(profile).toMatchObject({
      email: 'test@test.com',
      username: 'Tester',
      role: 'user',
    });
    expect(profile.password).toBeUndefined();
  });

  it('Powinien zaktualizować nazwę użytkownika', async () => {
    const user = await User.create({
      email: 'abc@test.com',
      password: 'hashedPassword',
      username: 'OldName',
      role: 'user',
    });

    const updated = await userService.updateProfile(user._id, {
      username: 'NewName',
    });

    expect(updated.username).toBe('NewName');
    expect(updated.password).toBeUndefined();
  });

  it('Powinien rzucić błąd gdy użytkownik nie istnieje', async () => {
    const fakeId = new mongoose.Types.ObjectId();
    await expect(userService.getProfile(fakeId)).rejects.toThrow(
      'Użytkownik nie istnieje',
    );
  });

  it('Powinien zmienić hasło gdy stare hasło jest poprawne', async () => {
    const hashed = await bcrypt.hash('oldPass', 10);
    const user = await User.create({
      email: 'pass@test.com',
      password: hashed,
      username: 'PassUser',
      role: 'user',
    });

    await userService.changePassword(user._id, 'oldPass', 'newPass');
    const updated = await User.findById(user._id);

    const isMatch = await bcrypt.compare('newPass', updated.password);
    expect(isMatch).toBe(true);
  });

  it('Powinien rzucić błąd gdy stare hasło jest nieprawidłowe', async () => {
    const hashed = await bcrypt.hash('oldPass', 10);
    const user = await User.create({
      email: 'failpass@test.com',
      password: hashed,
      username: 'FailUser',
      role: 'user',
    });

    await expect(
      userService.changePassword(user._id, 'wrongPass', 'newPass'),
    ).rejects.toThrow('Stare hasło jest nieprawidłowe.');
  });

  it('Powinien zwrócić listę użytkowników bez haseł', async () => {
    await User.create([
      {
        email: 'user1@test.com',
        password: 'hashedPassword1', // min 6 znaków
        username: 'User1',
        role: 'user',
      },
      {
        email: 'user2@test.com',
        password: 'hashedPassword2', // min 6 znaków
        username: 'User2',
        role: 'user',
      },
    ]);

    const users = await userService.listUsers();

    expect(users).toHaveLength(2);
    users.forEach((u) => expect(u.password).toBeUndefined());
  });

  it('Powinien zmienić rolę użytkownika na admin', async () => {
    const user = await User.create({
      email: 'role@test.com',
      password: 'hashed',
      username: 'RoleUser',
      role: 'user',
    });

    const updated = await userService.changeRole(user._id, 'admin');

    expect(updated.role).toBe('admin');
    expect(updated.password).toBeUndefined();
  });

  it('Powinien rzucić błąd dla nieprawidłowej roli', async () => {
    const user = await User.create({
      email: 'badrole@test.com',
      password: 'hashed',
      username: 'BadRole',
      role: 'user',
    });

    await expect(
      userService.changeRole(user._id, 'superadmin'),
    ).rejects.toThrow('Nieprawidłowa rola.');
  });

  it('Powinien usunąć użytkownika', async () => {
    const user = await User.create({
      email: 'del@test.com',
      password: 'hashed',
      username: 'DeleteMe',
      role: 'user',
    });

    await userService.deleteUser(user._id);

    const found = await User.findById(user._id);
    expect(found).toBeNull();
  });
});


==================================