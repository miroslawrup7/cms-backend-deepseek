utils\emailTemplates.js v.1
==================================

// utils/emailTemplates.js
const { APP_NAME = 'CMS' } = process.env

function approvedUserEmail({ username }) {
  const subject = `[${APP_NAME}] Twoje konto zosta≈Ço zatwierdzone`
  const text = `Cze≈õƒá ${username || ''},

Twoje konto w ${APP_NAME} zosta≈Ço zatwierdzone. Mo≈ºesz siƒô teraz zalogowaƒá.

Pozdrawiamy,
Zesp√≥≈Ç ${APP_NAME}
`
  const html = `
  <p>Cze≈õƒá ${username || ''},</p>
  <p>Twoje konto w <b>${APP_NAME}</b> zosta≈Ço <b>zatwierdzone</b>. Mo≈ºesz siƒô teraz zalogowaƒá.</p>
  <p>Pozdrawiamy,<br>Zesp√≥≈Ç ${APP_NAME}</p>
  `
  return { subject, text, html }
}

function rejectedUserEmail({ username }) {
  const subject = `[${APP_NAME}] Wniosek rejestracyjny odrzucony`
  const text = `Cze≈õƒá ${username || ''},

Niestety Tw√≥j wniosek rejestracyjny do ${APP_NAME} zosta≈Ç odrzucony.

Pozdrawiamy,
Zesp√≥≈Ç ${APP_NAME}
`
  const html = `
  <p>Cze≈õƒá ${username || ''},</p>
  <p>Niestety Tw√≥j wniosek rejestracyjny do <b>${APP_NAME}</b> zosta≈Ç odrzucony.</p>
  <p>Pozdrawiamy,<br>Zesp√≥≈Ç ${APP_NAME}</p>
  `
  return { subject, text, html }
}

module.exports = { approvedUserEmail, rejectedUserEmail }


==================================
utils\logger.js v.1
==================================

// utils/logger.js
const winston = require('winston');
const path = require('path');

// Definiuj format log√≥w dla developmentu (kolorowy, czytelny)
const devFormat = winston.format.combine(
  winston.format.colorize(),
  winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
  winston.format.printf(({ timestamp, level, message, ...meta }) => {
    let metaStr = '';
    if (Object.keys(meta).length > 0) {
      metaStr = JSON.stringify(meta, null, 2);
    }
    return `${timestamp} [${level}]: ${message} ${metaStr}`;
  })
);

// Definiuj format log√≥w dla productionu (JSON, strukturalny)
const prodFormat = winston.format.combine(
  winston.format.timestamp(),
  winston.format.json() // Loguje jako JSON dla ≈Çatwego parsowania
);

// Okre≈õl, kt√≥ry format u≈ºyƒá w zale≈ºno≈õci od ≈õrodowiska
const format = process.env.NODE_ENV === 'production' ? prodFormat : devFormat;

// Konfiguruj transporty (gdzie logowaƒá)
const transports = [
  // Zawsze loguj do konsoli
  new winston.transports.Console(),
];

// W production dodaj r√≥wnie≈º logowanie do pliku errors.log
if (process.env.NODE_ENV === 'production') {
  transports.push(
    new winston.transports.File({
      filename: path.join(__dirname, '..', 'logs', 'errors.log'),
      level: 'error', // Loguj tylko b≈Çƒôdy do tego pliku
      maxsize: 5242880, // 5MB
      maxFiles: 5,
    })
  );
  // Mo≈ºesz dodaƒá te≈º transport dla wszystkich log√≥w
  // transports.push(new winston.transports.File({ filename: 'logs/combined.log' }));
}

// Utw√≥rz i eksportuj instancjƒô loggera
const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info', // Poziom logowania (np. 'debug', 'error')
  format: format,
  transports: transports,
});

module.exports = logger;

==================================
utils\mailer.js v.1
==================================

// utils/mailer.js
const nodemailer = require('nodemailer')

const {
  SMTP_HOST,
  SMTP_PORT,
  SMTP_SECURE,
  SMTP_USER,
  SMTP_PASS,
  MAIL_FROM = 'no-reply@example.com'
} = process.env

// pojedynczy transport ‚Äì wielokrotne u≈ºycie
const transporter = nodemailer.createTransport({
  host: SMTP_HOST,
  port: Number(SMTP_PORT) || 587,
  secure: String(SMTP_SECURE) === 'true',
  auth: SMTP_USER && SMTP_PASS ? { user: SMTP_USER, pass: SMTP_PASS } : undefined
})

// prosta funkcja wysy≈Çki
async function sendMail({ to, subject, text, html }) {
  if (!to) throw new Error('Brak adresata (to)')
  const info = await transporter.sendMail({
    from: MAIL_FROM,
    to,
    subject,
    text,
    html
  })
  return info
}

module.exports = { sendMail, transporter }


==================================
utils\queryLogger.js v.2
==================================

// utils/queryLogger.js
const mongoose = require('mongoose');

// W≈ÇƒÖcz logging zapyta≈Ñ MongoDB
mongoose.set('debug', function (coll, method, query, doc) {
  console.log(`üóÑÔ∏è MongoDB Query: ${coll}.${method}`, {
    query: JSON.stringify(query),
    doc: doc ? JSON.stringify(doc) : undefined,
  });
});

module.exports = mongoose;


==================================
utils\redisClient.js v.1
==================================

// utils/redisClient.js
const redis = require('redis');

class RedisClient {
  constructor() {
    this.client = null;
    this.isConnected = false;
  }

  async connect() {
    if (this.client) return this.client;

    try {
      this.client = redis.createClient({
        url: process.env.REDIS_URL || 'redis://localhost:6379',
        socket: {
          reconnectStrategy: (retries) => {
            if (retries > 10) {
              console.log('Too many retries on Redis. Connection terminated');
              return new Error('Too many retries');
            }
            return Math.min(retries * 100, 3000);
          },
        },
      });

      this.client.on('error', (err) => {
        console.error('Redis Client Error:', err);
        this.isConnected = false;
      });

      this.client.on('connect', () => {
        console.log('Redis Client Connected');
        this.isConnected = true;
      });

      this.client.on('end', () => {
        console.log('Redis Client Disconnected');
        this.isConnected = false;
      });

      await this.client.connect();
      return this.client;
    } catch (error) {
      console.error('Failed to connect to Redis:', error);
      this.isConnected = false;
      return null;
    }
  }

  async get(key) {
    if (!this.isConnected) return null;
    try {
      return await this.client.get(key);
    } catch (error) {
      console.error('Redis get error:', error);
      return null;
    }
  }

  async set(key, value, expiration = 3600) { // 1 godzina domy≈õlnie
    if (!this.isConnected) return null;
    try {
      return await this.client.setEx(key, expiration, value);
    } catch (error) {
      console.error('Redis set error:', error);
      return null;
    }
  }

  async del(key) {
    if (!this.isConnected) return null;
    try {
      return await this.client.del(key);
    } catch (error) {
      console.error('Redis delete error:', error);
      return null;
    }
  }

  async flushAll() {
    if (!this.isConnected) return null;
    try {
      return await this.client.flushAll();
    } catch (error) {
      console.error('Redis flushAll error:', error);
      return null;
    }
  }

  async disconnect() {
    if (this.client) {
      await this.client.quit();
      this.isConnected = false;
    }
  }
}

module.exports = new RedisClient();

==================================
utils\sanitize.js v.3
==================================

const sanitizeHtml = require('sanitize-html');

// Tytu≈Çy: bez HTML - CA≈ÅKOWICIE BEZ TAG√ìW
function sanitizeTitle(text) {
  const s = String(text ?? '');
  return sanitizeHtml(s, {
    allowedTags: [],
    allowedAttributes: {},
    disallowedTagsMode: 'discard',
  }).trim();
}

// Tre≈õƒá artyku≈Çu: bogate formatowanie
const BODY_CFG = {
  allowedTags: [
    'b',
    'i',
    'em',
    'strong',
    'a',
    'p',
    'br',
    'ul',
    'ol',
    'li',
    'blockquote',
    'code',
    'pre',
    'h1',
    'h2',
    'h3',
    'h4',
    'h5',
    'h6',
  ],
  allowedAttributes: {
    a: ['href', 'title', 'target', 'rel'],
    img: ['src', 'alt', 'width', 'height'],
    code: ['class'],
  },
  allowedSchemes: ['http', 'https', 'mailto', 'data'],
  disallowedTagsMode: 'discard',
  transformTags: {
    a: (tagName, attribs) => ({
      tagName: 'a',
      attribs: {
        ...attribs,
        target: '_blank',
        rel: 'noopener noreferrer nofollow ugc',
      },
    }),
  },
};

function sanitizeBody(html) {
  const s = String(html ?? '');
  return sanitizeHtml(s, BODY_CFG).trim();
}

// Komentarze: MINIMALNE formatowanie + FILTROWANIE NIEBEZPIECZNYCH TAG√ìW
function sanitizeComment(str = '') {
  const result = sanitizeHtml(String(str), {
    // DOZWOLONE podstawowe tagi formatujƒÖce
    allowedTags: ['b', 'i', 'em', 'strong', 'u', 'br', 'a', 'code', 'pre', 'p'],

    // DOZWOLONE atrybuty (tylko bezpieczne)
    allowedAttributes: {
      a: ['href', 'title', 'target', 'rel'],
    },

    // SCHEMATY tylko http/https/mailto
    allowedSchemes: ['http', 'https', 'mailto'],

    // BLOKUJ niebezpieczne tagi
    disallowedTagsMode: 'discard',

    // ZABEZPIECZ linki - BLOKUJ javascript:
    transformTags: {
      a: (tagName, attribs) => {
        // BLOKUJ linki z javascript: i inne niebezpieczne
        if (
          attribs.href &&
          attribs.href.toLowerCase().startsWith('javascript:')
        ) {
          return { tagName: false, text: '' }; // USU≈É CA≈ÅY TAG
        }

        // Bezpieczne linki - dodaj atrybuty zabezpieczajƒÖce
        return {
          tagName: 'a',
          attribs: {
            ...attribs,
            target: '_blank',
            rel: 'noopener noreferrer nofollow ugc',
          },
        };
      },
    },

    // DODATKOWO: Rƒôcznie blokuj niebezpieczne atrybuty
    exclusiveFilter: (frame) => {
      if (frame.attribs) {
        // Blokuj atrybuty zdarze≈Ñ (onclick, onerror, etc.)
        const dangerousAttrs = Object.keys(frame.attribs).filter(
          (attr) => attr.startsWith('on') && attr.length > 2, // wszystkie on*
        );

        // Blokuj niebezpieczne schematy URL
        const hasDangerousHref =
          frame.attribs.href &&
          frame.attribs.href.toLowerCase().startsWith('javascript:');

        return dangerousAttrs.length > 0 || hasDangerousHref;
      }
      return false;
    },
  }).trim();

  return result;
}

// BARDZO RESTRYKCYJNA SANITYZACJA - dla parametr√≥w, query string, etc.
const STRICT_SANITIZE_CONFIG = {
  allowedTags: [],
  allowedAttributes: {},
  disallowedTagsMode: 'discard',
};

function sanitizeStrict(text) {
  return sanitizeHtml(String(text || ''), STRICT_SANITIZE_CONFIG)
    .trim()
    .substring(0, 500);
}

module.exports = {
  sanitizeTitle,
  sanitizeBody,
  sanitizeComment,
  sanitizeStrict,
};


==================================
utils\validate.js v.1
==================================

module.exports = function validateFields(fields) {
    const errors = []
    for (const [, [value, msg]] of Object.entries(fields)) {
        if (typeof value === 'string' && value.trim() === '') {
            errors.push(msg)
        }
        if (value === undefined || value === null) {
            errors.push(msg)
        }
    }
    return errors
}
